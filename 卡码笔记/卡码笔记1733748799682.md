# Java
## Spring
### Spring框架的核心组件有哪些？它们各自的作用是什么？
#### 简洁回答
Spring 框架的核心组件主要包括：
1. **Spring Core（核心容器）**： 提供了控制反转（IoC） 和依赖注入（DI）功能。
2. **Spring Context（应用上下文）**： 基于 Core 提供了框架式的 Bean 访问方式。
3. **Spring AOP（面向切面编程）**：实现了横切关注点的模块化。
4. **Spring MVC（模型-视图-控制器）**： 用于构建基于 Web 的应用程序，提供了请求处理、视图解析等功能。
5. **Spring DAO（数据访问对象）**： 简化了数据访问层的开发，提供了对 JDBC、ORM 的支持。
6. **Spring Expression Language（SpEL）**： 提供了强大的表达式语言，支持在运行时查询和操作对象。

---

#### 延申问答
- Spring Core（核心容器）相关
	- [x] IoC 和 DI 的核心思想？区别？
	- [x] Spring Bean 的生命周期？作用域？
	- [x] 如何通过注解实现 Bean 的装配？
- Spring Context（应用上下文）相关
	- [x] BeanFactory 和 ApplicationContext 的区别是什么？
	- [x] Spring 事件机制是如何工作的？
	- [x] 如何加载外部资源文件（如配置文件或国际化资源）？
- Spring AOP（面向切面编程）相关
	- [x] AOP 的核心概念？（切面、连接点、切入点、通知等）
	- [x] Spring AOP 的实现原理是什么？基于动态代理还是 CGLIB？
	- [x] AOP 的应用场景有哪些？
- Spring Expression Language（SpEL）相关
	- [x] SpEL 常用的操作有哪些？（属性访问、方法调用、集合操作等）
	- [x] 在项目中如何通过 SpEL 动态注入值？
	- [x] 实际场景中，SpEL 能解决哪些问题？
- Spring MVC（模型-视图-控制器）相关
	- [x] Spring MVC 的工作流程？
	- [x] 如何处理 JSON 格式的请求和响应？如何进行数据绑定？
	- [x] 如何通过注解实现 RESTful API？
- Spring DAO（数据访问对象）相关
	- [x] 什么是 `JdbcTemplate`？如何使用它简化数据库操作？
	- [x] Spring 是如何处理数据访问异常的？
	- [x] ORM 集成（如 Hibernate 或 JPA）的具体实现方式是什么？


### 解释Spring中的IoC（控制反转）原理，并举例说明。
#### 简洁回答
- **控制反转（Inversion of Control, IoC）【思想】：** 指将对象的创建、初始化及依赖管理的控制权从应用代码转移到 Spring 容器。
	- 传统方式： 对象由程序创建，依赖通过硬编码传递（代码写死而不是通过配置动态控制），高耦合。
	- IoC 方式： Spring 容器负责对象创建和依赖，模块之间只需要声明依赖，低耦合。
- **依赖注入（Dependency Injection, DI）【实现方式】：** 容器根据配置将所需的依赖注入到对象中。
	1. Setter 注入。
		- 适用于可选依赖的注入、自己开发的模块的注入
		- 如果只有Setter方法，没有注入，会导致null对象出现。
		- 配置`<bean>`用`<property>`标签的`value`或`ref`属性。
	2. 构造器注入（推荐）。
		- 适用于强制依赖的注入、第三方不含setter的模块的注入
		- 构造器注入结合 `@Qualifier` 或策略模式明确依赖关系，可以避免多个依赖注入混乱。
		- 配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性。
	3. 自动装配（不推荐）
		- 不推荐原因：隐式依赖关系导致的可测试性差和不易维护。具体来说，不能通过构造器或 setter 方法修改依赖关系，因为 Spring 会在创建 Bean 时自动完成依赖注入，测试代码无法显式地控制 Mock （模仿）对象的注入，只能使用 `@InjectMocks` 和 `@Mock` 等注解来让 Mockito 和 Spring 协作进行注入，或者采用构造器注入来手动控制 Mock 对象的注入。
		- 如果必须使用字段注入，可以通过一些工具（如 `ReflectionTestUtils`）来在测试中设置字段值
		- 配置`<bean>`用`autowire="xx"`。

---

#### 详细回答
#####  **1. IoC入门案例**
**思路：**
- **如何将被管理的对象告知IoC容器？** 配置。
- **如何获取到IoC容器？** 接口。
- **如何从容其中获取bean？** 接口方法。

**实践：**
1. **导入和配置。** 导入坐标`spring-context`后新建配置文件`applicationContext.xml`并配置bean（包括id，class）
2. **获取IoC容器。** `new ClassPathXmlApplicationContext("applicationContext.xml")`
3. **获取bean。** `ctx.getBean("bookDao")`

#####  **2. DI的三种注入方法**
**思路：**
- **注入什么类型？** 
	- **简单类型（如int、String）**。用`<property>`标签的`value`属性
	- **引用类型**。用`<property>`标签的`ref`属性
	- **集合**。用`<property>`标签的`<array>``<list>``<set>``<map>``<props>`子标签

**实践：**
1. **Setter 注入**：通过 Setter 方法，配置`<bean>`用`<property>`标签的`value`或`ref`属性注入。
	- 如果只有Setter方法，没有注入，会导致null对象出现。
	- 适用于可选依赖的注入、自己开发的模块的注入。
	![image.png](http://cdn.kamacoder.com/67553ebac9455-phpelMxgP.png)
2. **构造器注入（Spring推荐）**：通过构造函数，配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性注入。
	- 形参名的耦合问题解决：用`type`属性替代`name`属性。
	- 多个同类型的解决：用`index`属性替代`type`属性。
	- 适用于强制依赖的注入、第三方不含setter的模块的注入。
3. **自动装配（不推荐）**：配置`<bean>`用`autowire="xx"`，通过Setter方法 或 直接在字段上使用 `@Autowired`注入。
	- `autowire="byType"`按类型装配（推荐）。
		- 发现有多个class相同的bean，那装配谁呢？失败。
		- ![image.png](http://cdn.kamacoder.com/67554631ea319-phpO8de4F.png)
	- `autowire="byName"`按名称装配。（不推荐，因为变量名与配置耦合）

---

#### 延申问题
- [x] [**Spring框架中的@Autowired和@Resource注解有什么区别？**](https://notes.kamacoder.com/question/100541)
- [x] [**Spring 是如何管理 Bean 的生命周期的？有哪些生命周期方法？**](https://notes.kamacoder.com/question/100530)
- [x] [**Bean 的作用域有哪些？如何配置不同作用域？**](https://notes.kamacoder.com/question/100531)
- [x] **如果需要动态注入依赖，比如运行时决定使用哪个实现，如何实现？**
	- 可使用 `@Qualifier` 指定 Bean，或通过 `@Conditional` 注解根据条件动态加载 Bean。
- [ ] **在依赖注入过程中，如何解决循环依赖问题？**
	- Spring 使用三级缓存解决循环依赖，允许提前暴露 Bean 引用，避免死循环。
		1. SingletonFactory
		2. Early Bean Reference
		3. Fully Initialized Bean

- [ ] **如何使用第三方库实现 IoC？Spring IoC 与其他 IoC 框架（如 Guice）相比有何优势？**
	- 第三方库： Guice IoC 框架。
	- Spring IoC 提供更丰富的生态（如 AOP、数据访问支持）和灵活的配置方式（XML、注解、JavaConfig）


### Spring容器是如何管理Bean的生命周期的？包括哪些阶段？
#### 简洁回答
Spring 容器通过**配置或注解**管理 **Bean 的生命周期**（从创建到销毁的整个过程），包括以下阶段：
1. **实例化：** 执行构造方法创建对象，分配内存
2. **属性赋值：** set操作
3. **初始化** `implements InitializingBean` ，调用其 `afterPropertiesSet()` 方法。
	1. `Aware` 接口的依赖注入
	2. `BeanPostProcessor` 在初始化前后的处理
	3. `InitializingBean` 和 `init-method` 的初始化操作
4. 使用bean执行业务操作
5. **销毁** `implements DisposableBean` ，调用其 `destroy()` 方法。

---

#### 前置知识
- bean作用范围
- bean默认单例
	- 适合交给容器管理的bean：Service、Dao层对象
	- 不适合交给容器管理的bean：封装实体的域对象（有指定值）
- bean实例化
	1. 构造方法：无参构造方法、反射获取
	3. 静态工厂：`factory-method`
		```xml
		<bean id="orderDao" class="com.itheima.factory.OrderDaoFactory" factory-method ="getorderDao"/>
		```
	3. 实例工厂：
		- factory-bean="xx"
			```xml
			<bean id="userFactory" class="com.itheima.factory.UserDaoFactory" >
			<bean id="userDao" factory-method="getuserDao" factory-bean="userFactory" />
			```
		- FactoryBean
			![image.png](http://cdn.kamacoder.com/6755657ee33e2-phpVOnGPM.png)

---

#### 详细回答
1. **实例化：** 执行构造方法创建对象，分配内存
2. **属性赋值：** set操作
3. **初始化**
	- 自定义配置： `@PostConstruct` 或`init-method="xx"`
	- 实现接口： `implements InitializingBean` ，调用其 `afterPropertiesSet()` 方法。
		- 注意：在set方法的属性设置之后才执行该方法
4.使用bean执行业务操作
5. **销毁**
	- 自定义配置： `@PreDestroy` 或`destroy-method="xx"`
		- 注意：容器关闭时调用销毁逻辑，要想看到destroy-method执行：
			1. 暴力手动关闭：在JVM结束前通过`ClassPathXmlApplication接口close()方法`关闭容器
			2. 注册关闭钩子：`ClassPathXmlApplication接口registerShutdownHook()方法`
	- 实现接口： `implements DisposableBean` ，调用其 `destroy()` 方法。

![spring-bean-lifestyle.png](http://cdn.kamacoder.com/67558de2a9c6e-phpjekGCZ.png) 

---

#### 延伸问答
- [x]  **如何自定义 Bean 的初始化和销毁行为？**
	- 在配置文件中指定 `init-method="xx"` 和 `destroy-method="xx"`
	- 使用注解 `@PostConstruct` 和 `@PreDestroy`：
- [ ]  **Spring Bean 生命周期的扩展点有哪些？**
	- 使用 `BeanPostProcessor` 在初始化前后执行自定义逻辑。
	- 使用 `BeanFactoryPostProcessor` 修改 Bean 的定义或属性。
- [ ]  **不同作用域的生命周期有何区别？**
	- `singleton`：与容器生命周期一致，容器关闭时销毁。
	- `prototype`：每次获取新实例，无全局生命周期管理，不执行销毁方法。

### Spring中Bean的作用域有哪些？分别适用于什么场景？
#### 简洁回答
**2基础作用域 + 4仅Web 应用可用：**
1. **singleton（默认）：** IoC 容器中只有唯一的 bean 实例，适用于无状态的共享资源。
	- 作用域对生命周期的影响：Spring 管理整个生命周期，容器会自动调用销毁逻辑。
2. **prototype：** 每次获取bean都创建一个新实例，适用于短期使用的有状态且非线程安全的对象。
	- 作用域对生命周期的影响：Spring 只负责创建，由客户端决定何时销毁。
	- 应用：唯一标识符（UUID 、验证码、Token）、用户临时数据（表单数据缓存、文件上传临时存储）
3. **request：** 每个 HTTP 请求创建一个实例，如表单数据处理。
4. **session：** 每个会话创建一个实例，如用户信息缓存。
5. **application/global-session：** 在Web应用启动时创建一个bean，如统计数据。
6. **websocket：** 每个 WebSocket 会话创建一个实例，适用于WebSocket 连接状态管理。

----

#### 延申问答
- [x] **如何指定 Bean 作用域？**
	1. xml 方式
		```
		<bean id="..." class="..." scope="singleton"></bean>
		```
	2. 注解方式
		```
		@Bean
		@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
		public Person personPrototype() {
			return new Person();
		}
		```
- [x] **如何测试作用域行为？**
	- 可通过使用 `bean1.hashCode()` 或`System.identityHashCode(bean1)` 打印 Bean 的哈希值验证是否是同一实例。
- [x] Bean是线程安全的吗？
	Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。
我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。
prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。
有状态 Bean 示例：
```
// 定义了一个购物车类，其中包含一个保存用户的购物车里商品的 List
@Component
public class ShoppingCart {
    private List<String> items = new ArrayList<>();

    public void addItem(String item) {
        items.add(item);
    }

    public List<String> getItems() {
        return items;
    }
}
```


不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。
无状态 Bean 示例：
```
// 定义了一个用户服务，它仅包含业务逻辑而不保存任何状态。
@Component
public class UserService {

    public User findUserById(Long id) {
        //...
    }
    //...
}
```


对于有状态单例 Bean 的线程安全问题，常见的三种解决办法是：
1. **避免可变成员变量**: 尽量设计 Bean 为无状态。
2. **使用`ThreadLocal`**: 将可变成员变量保存在 `ThreadLocal` 中，确保线程独立。
3. **使用同步机制**: 利用 `synchronized` 或 `ReentrantLock` 来进行同步控制，确保线程安全。

这里以 `ThreadLocal`为例，演示一下`ThreadLocal` 保存用户登录信息的场景：
```
public class UserThreadLocal {

    private UserThreadLocal() {}

    private static final ThreadLocal<SysUser> LOCAL = ThreadLocal.withInitial(() -> null);

    public static void put(SysUser sysUser) {
        LOCAL.set(sysUser);
    }

    public static SysUser get() {
        return LOCAL.get();
    }

    public static void remove() {
        LOCAL.remove();
    }
}
```

### 说一说你对Spring AOP的了解，它主要解决什么问题？
#### 简洁回答
**What（定义）：** Spring AOP（Aspect-Oriented Programming，面向切面编程）
**Why（作用）：** 减少重复代码，降低模块间耦合度，提高可扩展性和可维护性。
**How（实现）：** 基于动态代理和 Cglib ，封装通用逻辑（例如日志记录、事务管理、权限控制、性能监控等）。

----

#### 详细回答
#####  1. AOP 的工作机制
Spring AOP 基于动态代理和 CGLIB 实现：
- 对于实现了某个接口的对象： Spring AOP 会使用 JDK Proxy创建代理对象
- 对于没有实现接口的对象：使用 Cglib 生成一个被代理对象的子类来作为代理

#####  2. AOP的专业术语
- **切面(Aspect) = 切入点(Pointcut) + 通知(Advice)**
	- **切入点（Pointcut）：** 被切面拦截 / 增强的连接点
		- **连接点（Join Point）：** 目标对象的所属类中，定义的所有方法均为连接点
		- 切入点一定是连接点，连接点不一定是切入点
	- **通知（Advice）：** 增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情。
		- **目标(Target)：** 被通知的对象
		- **代理(Proxy)：** 向目标对象应用通知之后创建的代理对象
		- **Weaving(织入)：** 将通知应用到目标对象，进而生成代理对象的过程动作

----

#### 延伸问答
- [ ] **Spring AOP 和 AspectJ AOP 有什么区别？**
	- Spring AOP：运行时增强，基于代理，集成了 AspectJ且更简单方便
	- AspectJ：编译时增强，基于字节码操作，提供更全面的 AOP 支持（如字段、构造函数切点）。
		- 当切面太多时最好选择 AspectJ ，快很多。
- [x] **AOP 常见的通知类型有哪些？**
	- **Before**（前置通知）：目标对象的方法调用之前触发
	- **After** （后置通知）：目标对象的方法调用之后触发
	- **AfterReturning**（返回通知）：目标对象的方法调用完成，在返回结果值之后触发
	- **AfterThrowing**（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。
		- AfterReturning 和 AfterThrowing 两者互斥。
	- **Around** （环绕通知）：可操作范围最大，可以直接拿到目标对象以及要执行的方法，可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法
	![aspectj-advice-types.jpg](http://cdn.kamacoder.com/67559341b3761-phpqUAJOq.jpg) 
- [x] **多个切面的执行顺序如何控制？**
	1. 通常使用`@Order` 注解直接定义切面顺序，值越小优先级越高。
	2. `implements Ordered` 接口重写 `getOrder` 方法，返回值越小优先级越高。

### 说一说你对 Spring中IOC的理解。
#### 简洁回答
- **控制反转（Inversion of Control, IoC）【思想】：** 指将对象的创建、初始化及依赖管理的控制权从应用代码转移到 Spring 容器。
	- 传统方式： 对象由程序创建，依赖通过硬编码传递（代码写死而不是通过配置动态控制），高耦合。
	- IoC 方式： Spring 容器负责对象创建和依赖，模块之间只需要声明依赖，低耦合。
- **依赖注入（Dependency Injection, DI）【实现方式】：** 容器根据配置将所需的依赖注入到对象中。
	1. Setter 注入。
		- 适用于可选依赖的注入、自己开发的模块的注入
		- 如果只有Setter方法，没有注入，会导致null对象出现。
		- 配置`<bean>`用`<property>`标签的`value`或`ref`属性。
	2. 构造器注入（推荐）。
		- 适用于强制依赖的注入、第三方不含setter的模块的注入
		- 构造器注入结合 `@Qualifier` 或策略模式明确依赖关系，可以避免多个依赖注入混乱。
		- 配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性。
	3. 自动装配（不推荐）
		- 不推荐原因：隐式依赖关系导致的可测试性差和不易维护
			1. 可测试性差： 不能通过构造器或 setter 方法修改依赖关系，因为 Spring 会在创建 Bean 时自动完成依赖注入，测试代码无法显式地控制 Mock （模仿）对象的注入，增加了测试难度。
			2. 不易维护：因为它没有明确显示依赖项，导致代码难以理解和维护。
		- 如果必须使用字段注入，可以通过一些工具（如 `ReflectionTestUtils`）来在测试中设置字段值
		- 配置`<bean>`用`autowire="xx"`。

---

#### 详细回答
#####  **1. IoC入门案例**
**思路：**
- **如何将被管理的对象告知IoC容器？** 配置。
- **如何获取到IoC容器？** 接口。
- **如何从容其中获取bean？** 接口方法。

**实践：**
1. **导入和配置。** 导入坐标`spring-context`后新建配置文件`applicationContext.xml`并配置bean（包括id，class）
2. **获取IoC容器。** `new ClassPathXmlApplicationContext("applicationContext.xml")`
3. **获取bean。** `ctx.getBean("bookDao")`

#####  **2. DI的三种注入方法**
**思路：**
- **注入什么类型？** 
	- **简单类型（如int、String）**。用`<property>`标签的`value`属性
	- **引用类型**。用`<property>`标签的`ref`属性
	- **集合**。用`<property>`标签的`<array>``<list>``<set>``<map>``<props>`子标签

**实践：**
1. **Setter 注入**：通过 Setter 方法，配置`<bean>`用`<property>`标签的`value`或`ref`属性注入。
	- 如果只有Setter方法，没有注入，会导致null对象出现。
	- 适用于可选依赖的注入、自己开发的模块的注入。
	![image.png](http://cdn.kamacoder.com/67553ebac9455-phpelMxgP.png)
2. **构造器注入（Spring推荐）**：通过构造函数，配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性注入。
	- 形参名的耦合问题解决：用`type`属性替代`name`属性。
	- 多个同类型的解决：用`index`属性替代`type`属性。
	- 适用于强制依赖的注入、第三方不含setter的模块的注入。
3. **自动装配（不推荐）**：配置`<bean>`用`autowire="xx"`，通过Setter方法 或 直接在字段上使用 `@Autowired`注入。
	- `autowire="byType"`按类型装配（推荐）。
		- 发现有多个class相同的bean，那装配谁呢？失败。
		- ![image.png](http://cdn.kamacoder.com/67554631ea319-phpO8de4F.png)
	- `autowire="byName"`按名称装配。（不推荐，因为变量名与配置耦合）

---

#### 延申问题
- [x] [**Spring框架中的@Autowired和@Resource注解有什么区别？**](https://notes.kamacoder.com/question/100541)
- [x] [**Spring 是如何管理 Bean 的生命周期的？有哪些生命周期方法？**](https://notes.kamacoder.com/question/100530)
- [x] [**Bean 的作用域有哪些？如何配置不同作用域？**](https://notes.kamacoder.com/question/100531)
- [x] **如果需要动态注入依赖，比如运行时决定使用哪个实现，如何实现？**
	- 可使用 `@Qualifier` 指定 Bean，或通过 `@Conditional` 注解根据条件动态加载 Bean。
- [ ] **在依赖注入过程中，如何解决循环依赖问题？**
	- Spring 使用三级缓存解决循环依赖，允许提前暴露 Bean 引用，避免死循环。
		1. SingletonFactory
		2. Early Bean Reference
		3. Fully Initialized Bean

- [ ] **如何使用第三方库实现 IoC？Spring IoC 与其他 IoC 框架（如 Guice）相比有何优势？**
	- 第三方库： Guice IoC 框架。
	- Spring IoC 提供更丰富的生态（如 AOP、数据访问支持）和灵活的配置方式（XML、注解、JavaConfig）


### Spring中用到了那些设计模式。
#### 简洁回答
- **工厂设计模式** : Spring 使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。
- **单例设计模式** : Spring 中的 Bean 默认都是单例的。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式** : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。
- ……


### 描述一下 SpringMVC 的执行流程。
#### 简洁回答
1. **请求到达 DispatcherServlet：** 客户端发起请求，首先由 `DispatcherServlet` 接收。
2. **HandlerMapping 找到Controller：** `DispatcherServlet` 根据请求的 URL、HTTP 方法，使用 `HandlerMapping` 查找合适的Controller。
3. **Controller 执行业务逻辑** 
4. **视图解析：** 返回的 `ModelAndView` 对象交给 `ViewResolver` 解析视图（如 JSP、Thymeleaf 模板等）。
5. **响应结果：**  `ViewResolver` 找到视图后，视图渲染器（如 JSP 渲染引擎）负责渲染最终的 HTML 页面，并将响应返回给客户端。

----

#### 详细回答
MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。
##### Spring MVC 的核心组件
- **`DispatcherServlet`**：**中央处理器**，负责接收请求、分发，并给予客户端响应。
- **`HandlerMapping`**：**处理器映射器**，根据 URL 去匹配查找能处理的 `Handler` ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
- **`HandlerAdapter`**：**处理器适配器**，根据 `HandlerMapping` 找到的 `Handler` ，适配执行对应的 `Handler`；
- **`Handler`**：**请求处理器**，处理实际请求的处理器。
- **`ViewResolver`**：**视图解析器**，根据 `Handler` 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 `DispatcherServlet` 响应客户端

##### Spring MVC 的工作原理 / 执行流程
1. **请求到达 DispatcherServlet：** 客户端（浏览器）发送请求， `DispatcherServlet`拦截请求。
2. **HandlerMapping 找到Controller：** `DispatcherServlet` 根据请求信息调用 `HandlerMapping` 。`HandlerMapping` 根据 URL 去匹配查找能处理的 `Handler`（也就是我们平常说的 `Controller` 控制器） ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
3. **Controller 执行业务逻辑：**  `DispatcherServlet` 调用 `HandlerAdapter`适配器执行 `Handler` 。
4. **视图解析：** `Handler` 完成对用户请求的处理后，会返回一个 `ModelAndView` 对象给`DispatcherServlet`，`ModelAndView` 顾名思义，包含了数据模型以及相应的视图的信息。`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
5. **响应结果：** `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。`DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。把 `View` 返回给请求者（浏览器）

----

#### 延伸问答
- [ ] **如何自定义 SpringMVC 的 `HandlerMapping` 和 `ViewResolver`？**
	通过implements`WebMvcConfigurerAdapter` 或 `WebMvcConfigurer` 接口，在 `configureHandlerMapping()` 和 `configureViewResolvers()` 方法中自定义映射和视图解析器。
- [x] **SpringMVC 的拦截器如何工作？**
	- 通过实现 `HandlerInterceptor` 接口，在请求到达 Controller 之前和响应返回客户端之前执行，通常用于处理日志、权限验证等跨切面逻辑。
- [ ] **为什么需要前端控制器（DispatcherServlet）？**
	将所有的请求集中处理，简化了请求分发和响应管理，实现解耦、集中配置、增强扩展性。
- [ ] **SpringMVC 支持哪些类型的视图？**
	SpringMVC 支持多种视图解析技术，如 JSP、Thymeleaf、Freemarker、Velocity 等，也支持直接返回 JSON、XML 数据（使用 `@ResponseBody`）。

### SpringMVC 中的DispatcherServlet扮演什么角色？
#### 简洁回答
##### 1. 角色定位
**核心调度器 / 请求分发中心：** ：所有请求都由`DispatcherServlet`统一管理，根据请求 URL查找对应的处理器（Controller），并协调视图解析器生成最终的响应。
##### 2. 作用	
- **解耦：** `DispatcherServlet` 通过 HandlerMapping 和 ViewResolver 解耦了请求和处理逻辑。
- **灵活性：** 可配置多个 `HandlerMapping` 和 `ViewResolver` 实现，支持复杂的请求分发和视图解析。
- **扩展性：** 提供了拦截器（Interceptor）机制，可在请求处理前后执行额外的逻辑。

----

#### 详细回答

----

### **延伸回答：**
- [x] **`DispatcherServlet` 和传统 Front Controller 的区别是什么？**
	- `DispatcherServlet` 提供了完整的扩展机制（如拦截器、异常处理器等），而传统 Front Controller 逻辑通常较固定。
- [x] **`DispatcherServlet` 如何与其他组件协作？**
	- 使用 `HandlerMapping` 查找 Controller，`HandlerAdapter` 调用具体方法。
	- 使用 `ViewResolver` 解析逻辑视图名并返回渲染的结果。
- [ ] **是否可以自定义 `DispatcherServlet`？**
	- 可以通过扩展 `DispatcherServlet` 类自定义其行为，例如重写 `doDispatch()` 方法来调整请求处理逻辑。
	- 也可以通过配置文件调整其参数（如文件上传、初始化参数等）。

### SpringMVC 中如何配置控制器（Controller）？
#### 简洁回答
- **使用注解方式（推荐）：** 
	- 使用 `@Controller `标识类为控制器，并使用 `@RequestMapping` 指定 URL 映射关系。
	- 在 Spring 启动类中启用注解扫描`@ComponentScan`
- **使用 XML 配置方式：** 
	- 在 XML 文件中声明 `Controller` 的 Bean 。
	- 使用 `<mvc:annotation-driven />`配置请求映射。

---

#### 详细回答

---

#### 延伸问答
- [x] **如何配置多级 URL？**
	- 使用类级别和方法级别的 `@RequestMapping`：
	```java
	@Controller
	@RequestMapping("/users")
	public class UserController {
	    @GetMapping("/{userId}/orders")
	    public String getUserOrders(@PathVariable Long userId) {
	        return "orderView";
	    }
	}
	```

### Spring框架中的@Autowired和@Resource注解有什么区别？
#### 简洁回答
1. **`@Autowired`：** Spring 特有，默认**按类型（byType）** 自动注入。
	- 注解来源：Spring 特有，支持`@Autowired(required = false)`表示依赖项可选，即没有匹配到 Bean 时，不抛异常，而是注入 `null`。
	- 如果存在多个相同类型的 Bean，可结合 `@Qualifier` 注解指定注入的 Bean 名称。
2. **`@Resource`：** JSR-250 标准，默认**按名称（byName）** 注入。
	- JSR-250 标准，更适合标准化和跨框架使用。
	- 如果未指定名称且没有匹配的 Bean，会按类型注入。

---

#### 详细回答
1. **`@Autowired`：** 
	```java
	@Component
	public class UserService {
		@Autowired
		private UserRepository userRepository; // 默认按类型注入

		@Autowired
		@Qualifier("specialUserRepository") // 指定名称
		private UserRepository specialRepository;
	}
	```

2. **`@Resource`：** 
	```java
	@Component
	public class UserService {
		@Resource(name = "userRepository") // 默认按名称注入
		private UserRepository userRepository;

		@Resource(type = SpecialUserRepository.class) // 按类型注入
		private SpecialUserRepository specialRepository;
	}
	```


### Spring框架中的@Repository、@Service、@Controller注解的作用是什么？
#### 简洁回答
1. **`@Repository`：** 标记数据访问层（DAO）组件，能将数据库相关异常转换为 Spring 的数据访问异常（如 `DataAccessException`）
2. **`@Service`：** 标记业务逻辑层（Service）组件。
3. **`@Controller`：** 标记控制层（Controller）组件，常与 `@RequestMapping` 等注解结合，用于定义 Web 路由。

### SpringMVC 中如何处理文件上传和下载？
#### 简洁回答
1. **文件上传：**
	- 配置 `MultipartResolver` 以支持多部分文件请求。
	- 使用 `@RequestParam("file") MultipartFile file` 接收上传文件。
2. **文件下载：**
	- 设置响应头（`Content-Disposition`）指定下载文件名和类型。
	- 将文件内容写入响应的输出流。

----

#### 详细回答
##### **1. 文件上传**
1. **配置 MultipartResolver：** SpringMVC 使用 `MultipartResolver` 处理多部分请求。
2. **实现文件上传控制器：** `FileUploadController`
3. **前端表单：** 使用 `enctype="multipart/form-data"` 指定多部分上传：
##### **2. 文件下载**
1. 实现文件下载控制器：** 使用 `HttpServletResponse` 设置下载响应头，并写入文件流
2. 访问文件下载：用户访问 `/download/{fileName}` 即可触发下载。

----

#### 延伸问答
- [x] **如何限制上传文件大小？**
	- 在 `application.properties` 中设置限制：
		```properties
		spring.servlet.multipart.max-file-size=10MB
		spring.servlet.multipart.max-request-size=20MB
		```
	- 如果使用 `CommonsMultipartResolver`，可以设置 `maxUploadSize` 属性：
		```xml
		<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
			<property name="maxUploadSize" value="10485760" /> <!-- 10MB -->
		</bean>
		```
- [x] **如何处理多文件上传？**
	- 使用 `@RequestParam("files") MultipartFile[] files` 接收多个文件：```
- [x] **如何提升性能？**
	- 使用异步处理文件上传和下载，减少对主线程的阻塞。
	- 结合云存储（如 AWS S3）存储文件，降低本地服务器的负载。

### Spring框架中的@EnableWebMvc注解的作用是什么？它如何启用Spring MVC的高级特性？
#### 简洁回答
`@EnableWebMvc` 作用：提供Spring MVC的默认配置和高级特性。
- 自动注册注册 MVC 必需的组件（如 `HandlerMapping`、`HandlerAdapter`）
- 提供静态资源处理、全局异常处理、消息转换等功能。

----

#### 详细回答
##### 如何启用高级特性？
1. **消息转换器（Message Converters）：** 自动注册 `HttpMessageConverter`，支持 JSON 和 XML 数据的序列化与反序列化。使用场景：在 RESTful API 中直接返回或接收 JSON 数据。
2. **静态资源映射：** 提供对 `/resources/**` 等静态文件路径的默认映射。使用场景：直接访问 CSS、JS、图片等资源。
3. **全局异常处理：** 提供异常处理机制，可通过 `@ControllerAdvice` 或自定义 `HandlerExceptionResolver` 捕获和处理全局异常。
4. **视图解析：** 配置 `InternalResourceViewResolver`，将逻辑视图名映射为实际的 JSP 文件路径。
5. **自定义拦截器：** 通过实现`WebMvcConfigurer` 接口的`addInterceptors()`方法添加拦截器。

##### 使用注意事项
- 如果使用 `@EnableWebMvc`，Spring 会禁用一些默认的自动配置（例如静态资源处理）。需要通过实现 `WebMvcConfigurer` 接口手动配置相关功能。
- 如果不需要完全控制 MVC 配置，可以直接使用 `spring-boot-starter-web` 提供的自动配置。

----

#### 延伸问答
- [ ] **`@EnableWebMvc` 和 `WebMvcConfigurer` 的关系是什么？**
	- `@EnableWebMvc` 通过启用 `DelegatingWebMvcConfiguration` 实现了 Spring MVC 的配置。
	- `WebMvcConfigurer` 提供了扩展 MVC 配置的钩子方法（如 `addInterceptors` 和 `configureMessageConverters`）。
- [ ] **在 Spring Boot 中是否需要显式使用 `@EnableWebMvc`？**
	通常不需要，Spring Boot 自动配置了 Web MVC 功能。如果需要完全自定义配置，可以结合 `@EnableWebMvc` 和 `WebMvcConfigurer` 实现。
- [ ] **如何自定义消息转换器？**
	在实现 `WebMvcConfigurer` 的 `configureMessageConverters` 方法中添加或修改消息转换器：
	```java
	@Override
	public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
	    converters.add(new MappingJackson2HttpMessageConverter());
	}
	```

### Spring框架中如何配置和使用自定义的WebMvcConfigurer来定制Spring MVC的行为？
#### 简洁回答
将类标记为 `@Configuration` 并实现 `WebMvcConfigurer` 接口中的方法，可以自定义 Spring MVC 的行为。
例如，可以添加拦截器、格式化器、消息转换器或自定义静态资源映射。

----

#### 详细回答
##### 1、创建自定义 `WebMvcConfigurer`
```java
@Configuration
public class MyWebMvcConfigurer implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoggingInterceptor()).addPathPatterns("/**");
    }

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/home").setViewName("home");
    }
}
```
##### 2、常用的 `WebMvcConfigurer` 方法**
###### （1）`addInterceptors` 添加自定义拦截器。
```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
	registry.addInterceptor(new LoggingInterceptor()).addPathPatterns("/**");
}
```

###### （2）`addViewControllers` 配置简单的视图映射，无需控制器逻辑。
```java
@Override
public void addViewControllers(ViewControllerRegistry registry) {
	registry.addViewController("/login").setViewName("loginPage");
}
```
###### （3）`configureMessageConverters` 自定义消息转换器，用于 JSON/XML 的序列化与反序列化。
```java
@Override
public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
	converters.add(new MappingJackson2HttpMessageConverter());
}
```
###### （4）`addResourceHandlers` 配置静态资源的访问路径。
```java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
	registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
}
```
###### （5）`configureViewResolvers` 自定义视图解析器。
```java
@Override
public void configureViewResolvers(ViewResolverRegistry registry) {
	registry.jsp("/WEB-INF/views/", ".jsp");
}
```
###### （6）`configurePathMatch` 定制路径匹配规则，例如忽略 URL 后缀。
```java
@Override
public void configurePathMatch(PathMatchConfigurer configurer) {
	configurer.setUseSuffixPatternMatch(false);
}
```

----

#### 延伸问答
- [x] **`WebMvcConfigurer` 与 `@EnableWebMvc` 的关系是什么？**
	- `@EnableWebMvc` 会启用 Spring MVC 的核心配置
	-  `WebMvcConfigurer` 提供了扩展点，允许开发者在默认配置上添加自定义行为。
- [ ] **如何管理多个 `WebMvcConfigurer`？**
	- Spring 容器会自动识别所有实现了 `WebMvcConfigurer` 的 Bean，并按优先级顺序组合执行，优先级可以通过 `@Order` 注解控制。
- [ ] **与 `WebMvcConfigurationSupport` 的区别？**
	- `WebMvcConfigurer` 是轻量级的扩展机制，基于默认配置。
	- `WebMvcConfigurationSupport` 是完全接管 MVC 配置的高级机制，适合需要完全自定义 MVC 的场景。

## Spring Boot
### 什么是Spring Boot？
#### 定义
Spring Boot 旨在简化 Spring 应用的开发和部署。
#### 核心特点：
1. **自动配置**：基于类路径依赖智能化地配置 Spring 应用，避免手动 XML 配置或 Java 配置。
2. **内嵌服务器**：支持内嵌 Tomcat、Jetty 等，无需外部应用服务器。
3. **简化依赖管理**：通过 Spring Boot Starter 提供一站式依赖管理。
4. **生产级特性**：内置监控、健康检查、日志管理等功能。

### Spring Boot的主要特点是什么？
1. 自动配置
	- 核心注解：`@EnableAutoConfiguration`。
	- 例如：添加 `spring-boot-starter-web`，Spring Boot 会自动配置内嵌的 Tomcat 和 Spring MVC。
2. 内嵌服务器
	- 支持内嵌 Tomcat、Jetty、Undertow，无需单独部署应用服务器。
	- 通过 `java -jar` 即可运行，便于快速开发和部署。
3. 开箱即用的 Starter 组件
	- 提供了一系列 Starter，简化依赖管理。
	- 例如：`spring-boot-starter-data-jpa` 集成了 Hibernate 和 Spring Data JPA。
4. 生产级特性
	- 提供内置的监控、健康检查、性能指标。
	- 集成 `Spring Boot Actuator`，方便开发和运维团队实时监控应用。

### Spring Boot Starter有什么用？
#### 定义
- Spring Boot Starter 是一组**预定义依赖包**，旨在**简化依赖管理**。
- 提供一站式的依赖管理，通过一个单独的 Starter 依赖即可集成某种功能，而无需手动管理繁杂的依赖关系和版本。
#### 特点
1. 约定优于配置，无需手动配置
	- 每个 Starter 都包含一组经过验证的依赖及其版本，无需手动配置。
	- 例如，`spring-boot-starter-web` 自动引入 Spring MVC、Tomcat、Jackson 等依赖。
2. 提供默认配置**避免兼容性问题**
3. 支持扩展和自定义
#### 举例
- `spring-boot-starter-web`：构建 RESTful Web 应用。
- `spring-boot-starter-data-jpa`：集成 JPA 和 Hibernate。
- `spring-boot-starter-test`：集成 JUnit、Mockito 和 Spring Test。
- `spring-boot-starter-security`：集成 Spring Security。

### Spring Boot常用注解？
#### 核心配置相关
1. **`@SpringBootApplication`**
	- 功能：标记为 Spring Boot 应用的入口，集成了 `@Configuration`、`@EnableAutoConfiguration` 和 `@ComponentScan`。
#### RESTful API 开发相关
1. **`@RestController`**
	- 功能：标记类为 REST 控制器，等同于 `@Controller` + `@ResponseBody`。
2. **`@GetMapping` / `@PostMapping` / `@PutMapping` / `@DeleteMapping`**
	- 功能：用于定义 HTTP 请求的映射，对应 GET、POST、PUT、DELETE 方法。
3. **`@RequestParam` / `@PathVariable`**
	- 功能：获取 URL 参数或路径变量。

#### 数据访问相关
1. **`@Entity`**
	- 功能：标记类为 JPA 实体，与数据库表映射。
2. **`@Repository`**
	- 功能：标记类为持久层组件，用于异常转换。
3. **`@Transactional`**
	- 功能：声明事务，确保方法在事务范围内执行。


### 如何在Spring Boot中禁用Actuator端点安全性？
【待补充】
1. 修改配置文件
2. 自定义安全配置
3. 禁用Spring Security（开发环境推荐，生产环境慎用）
#### 修改配置文件
```properties
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always
spring.security.enabled=false
```

#### 自定义安全配置
```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .requestMatchers("/actuator/**").permitAll() // 允许所有用户访问 Actuator 端点
            .anyRequest().authenticated()
            .and().csrf().disable();
        return http.build();
    }
}
```

#### 禁用Spring Security
```properties
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration
```


### 如何在自定义端口上运行Spring Boot应用程序？
1.  在 `application.properties` 文件中，添加或修改 `server.port` 配置项
	```
	server.port=8081
	```
2. 如果使用 `application.yml` 文件
	```
	  port: 8081
	```
3. 可以通过命令行参数来指定端口
	```
	java -jar myapp.jar --server.port=8081
	```

### Spring Boot中的YAML配置与properties配置有什么区别？
#### 语法格式
- **`properties` 配置：** 基于键值对的格式，使用 `=` 或 `:` 分隔键和值。
- **`YAML` 配置：** 基于缩进的层级结构，使用冒号 `:` 分隔键和值，且支持复杂的嵌套结构。

#### 可读性
- **`properties` 配置：** 对于简单的配置项来说，`properties` 格式相对直观，但对于复杂的嵌套配置会显得冗长且难以管理。
- **`YAML` 配置：** 更具层次感，适合处理复杂的配置，配置文件更简洁且易于理解和维护。支持注释和文档化，易于组织和描述配置结构。

####  支持的数据结构
- **`properties` 配置：** 主要用于简单的键值对，支持基本类型的数据，如字符串、数字、布尔值等。
- **`YAML` 配置：** 支持复杂的层级结构，允许列表、字典、嵌套对象等数据类型。

#### 总结
- **简洁性：** YAML 更适合复杂的、多层次的配置，`properties` 更适合简单的配置。
- **可读性：** YAML 由于缩进和层级结构，通常更易于阅读和维护。
- **性能：** `properties` 稍快，但差异在大多数应用场景中并不显著。

### 如何在Spring Boot中实现应用程序的安全性？
【待学习】
在** Spring Boot** 中实现**应用程序安全性**主要依赖 **Spring Security**，具体可以通过以下步骤：
1. **引入依赖：** 添加 `spring-boot-starter-security` 启用默认安全配置（如 HTTP Basic 身份验证）。
	[追问：如何禁用默认安全配置](https://notes.kamacoder.com/question/100604)
3. **自定义安全规则：** 使用 `SecurityFilterChain` 配置 URL 访问权限和认证方式（如角色控制、表单登录）。
4. **密码加密和安全性增强：** 使用 `BCryptPasswordEncoder` 加密用户密码，并结合 HTTPS、JWT 等保护敏感数据。

### Spring Boot中的自动配置是如何工作的？
#### 关键词提示
-  `@EnableAutoConfiguration` `META-INF/spring.factories` 
-   扫描依赖、条件匹配、Bean注册
---
#### 面试版回答
##### 1. 核心机制
通过 `@EnableAutoConfiguration` 注解自动导入 `META-INF/spring.factories` 文件中指定的自动配置类。
##### 2. 工作流程
	1. **扫描依赖：** 根据类路径中的依赖（如 Starter）决定要加载的自动配置类。
	2. **条件匹配：** 通过 `@Conditional` 注解验证是否满足加载条件。
	3. **Bean 注册：** 满足条件的自动配置类会注册相关的 Spring Bean。
##### 3. 自定义与禁用
	- **禁用：** `spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration`
	- **自定义：** `org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.example.MyAutoConfiguration`


### 如何在Spring Boot中集成ActiveMQ？
【待学习】

---

#### 面试者回答
1. 引入依赖
2. 配置ActiveMQ的连接信息
3. 创建消息发送和接收逻辑

---

#### 详细回答
1. **引入依赖：**
	```xml
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-activemq</artifactId>
	</dependency>
	```

2. **配置 ActiveMQ的连接信息**
	```properties
	spring.activemq.broker-url=tcp://localhost:61616
	spring.activemq.user=admin
	spring.activemq.password=admin
	```

3. **创建消息发送和接收逻辑：**
	- **发送消息：**
		```java
		@Service
		public class Producer {
		    @Autowired
		    private JmsTemplate jmsTemplate;
		    public void sendMessage(String destination, String message) {
		        jmsTemplate.convertAndSend(destination, message);
		    }
		}
		```
	- **接收消息：**
		```java
		@Component
		public class Consumer {
		    @JmsListener(destination = "test-queue")
		    public void receiveMessage(String message) {
		        System.out.println("Received: " + message);
		    }
		}
		```

### AOP在Spring Boot中的应用是什么？
#### 面试者回答
AOP（Aspect-Oriented Programming，面向切面编程）主要应用于日志记录、性能监控、事务管理等。

---

#### 详细回答
##### 1. 日志记录
```java
@Aspect
@Component
public class LoggingAspect {
	@Before("execution(* com.example.service.*.*(..))")
	public void logBefore(JoinPoint joinPoint) {
		System.out.println("Executing: " + joinPoint.getSignature());
	}
}
```
##### 2. 性能监控
```java
@Around("execution(* com.example.service.*.*(..))")
public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
	long start = System.currentTimeMillis();
	Object result = joinPoint.proceed();
	long executionTime = System.currentTimeMillis() - start;
	System.out.println("Executed in: " + executionTime + "ms");
	return result;
}
```
##### 3. 事务管理
通过 AOP 自动管理方法的事务边界（Spring 已内置支持，`@Transactional` 注解即为 AOP 实现）。

# 前端开发
## Vue
### MVVM模式和MVC模式有什么区别？
#### 简洁回答
##### 主要区别
|**特性**|**MVC**|**MVVM**|
|:-:|:-:|:-:|
|**核心组件**|Model, View, Controller|Model, View, ViewModel|
|**交互方式**|View 和 Model 直接交互，由 Controller 调节|View 和 Model 不直接交互，依赖 ViewModel|
|**数据绑定**|手动通知 View 更新|双向绑定自动更新|
|**适用场景**|后端 Web 框架（Spring MVC）|前端框架（Angular、Vue、React 等）|

----

#### 详细回答
##### MVC 模式
- **组成：**
	- **Model（模型）：** 处理业务逻辑和数据，负责状态管理。
	- **View（视图）：** 展示数据给用户，负责用户界面。
	- **Controller（控制器）：** 接收用户输入，协调 Model 和 View 的交互。
- **特点：**
	- 控制器集中处理输入，视图直接依赖于模型。
	- 更新数据需要手动通知视图刷新，数据和视图耦合较高。
	- 适合后端系统，如传统 Web 应用（Spring MVC）。
- **示例：**
	用户点击按钮后，Controller 接收请求，调用 Model 更新数据，并将新数据传递给 View。

##### MVVM 模式
- **组成：**
	- **Model（模型）：** 数据和业务逻辑层，与 MVC 模式相同。
	- **View（视图）：** 展示数据给用户，用户操作通过绑定传递给 ViewModel。
	- **ViewModel（视图模型）：** 中介层，负责数据与视图的双向绑定。
- **特点：**
	- View 和 Model 之间没有直接联系，依赖于 ViewModel 作为桥梁。
	- 通过双向绑定（Data Binding），数据和界面实时同步，降低开发复杂度。
	- 适合前端框架（如 Angular、React+Redux、Vue）。
- **示例：**
	用户修改界面内容，ViewModel 通过双向绑定自动更新 Model，反之亦然。

----

#### 延伸问答
- [x] **为什么 MVVM 更适合前端框架？**
	- 前端应用需要频繁更新视图状态，而 MVVM 的双向绑定特性可以自动同步数据与界面，减少开发者手动更新的负担。

# 代码随想录
## 哈希表
### 《代码随想录》哈希表：哈希表理论基础
#### 基本概念
- 哈希表基于哈希函数通过 **键值对（key-value）** 存储数据。
- 哈希函数将任意大小的数据**映射**为固定大小的整数，通过哈希值可以快速**定位**存储位置。
- **目标**：提供快速的**增、删、查**操作，平均时间复杂度为 O(1)
- 负载因子 = 元素个数 / 数组长度
	- 负载因子越高，冲突越多，性能越差。
	- 合适的负载因子（如 α ≤ 0.75）能在性能和空间之间取得平衡。
	- 动态扩容：负载因子超过一定阈值，哈希表会扩容并重新分配已有元素到新的位置（ rehashing）。

---

#### 哈希冲突
哈希冲突：由于数组的大小有限，**不同的键**可能映射到**同一索引值**。
解决方法：
##### 1. 链地址法：链表存储
**缺点**：
	- 额外指针增加了空间消耗。
	- 链表长度过长时，查找性能可能退化为 O(n)。
##### 2. 开放寻址法：查找下一个可用位置
1. **线性探测**：按固定步长（通常为 1）依次查找。
2. **二次探测**：步长为二次方，避免聚集效应。
3. **双重哈希**：用第二个哈希函数决定步长。
- **缺点**：插入和查找效率在负载因子较高时下降。
#####  3. 再哈希法：冲突时重新计算哈希值，直到找到空位。
#####  4. 扩展数组：动态增加数组大小，重新分配元素（常见于 `HashMap` 等实现）

---

#### 哈希表的优缺点
- **空间换时间**：增删查的平均时间复杂度为 O(1)。
- **无法顺序存储**：哈希表中的元素通常是无序的。

---
#### 红黑树
#### 二叉搜索树（BST）
- 可以O（logn）的效率进行增删查
- 但当数据有序时，二叉搜索树的构建会变成链表状态且效率退化为O（n）
##### 二叉搜索树之 平衡二叉树（AVL）
- 通过旋转操作让树保持平衡
- 任一结点左右子树高度相差不超过1。（相比红黑树，对平衡的要求更加严格）
- 相比红黑树**查询更高效**。
##### 二叉搜索树之 红黑树
- 左根右，根叶黑，不红红，黑路同。
- 任一结点左右子树高度相差不超过两倍。
- 相比平衡二叉树**增删更高效**。
- 应用更广泛，如C++的STL的map和set。


## 二叉树
### 《代码随想录》二叉树：二叉树的层序遍历
#### Java知识
##### Java中queue.offer(null)时，size会++吗？
- 如果不做`if(root == null)    return res;`判断，那么`queue.offer(root);`不会报错且`queue.size()`正常增加。
- 但是后续`level.add(node.val);`会报错，所以尽量保持queue中不要有null。
##### Java中的Queue有哪些具体实现
- **`LinkedList`**：基于链表的常规队列实现，适合一般用途。
- **`PriorityQueue`**：优先级队列，按照优先级顺序处理元素。
- **`ArrayDeque`**：基于动态数组的高效队列实现，适用于需要高效队列操作的场景。
- **`ConcurrentLinkedQueue`**：线程安全的队列实现，适用于并发场景。
- **`BlockingQueue`**：用于线程间协调的阻塞队列，适用于多线程编程。
- **`Deque`**：双端队列，支持从两端进行插入和删除操作。

### 《代码随想录》二叉树：将有序数组转换为二叉搜索树
#### 分治
```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return help(nums, 0, nums.length-1);
    }

    public TreeNode help(int[] nums, int left, int right) {
        if (left > right)   return null;
        int mid = left + (right-left)/2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = help(nums, left, mid-1);
        node.right = help(nums, mid+1, right);
        return node;
    }
}
```

