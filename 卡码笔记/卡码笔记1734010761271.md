# Java
## Spring
### Spring框架的核心组件有哪些？它们各自的作用是什么？
#### 简洁回答
Spring 框架的核心组件主要包括：
1. **Spring Core（核心容器）**： 提供了控制反转（IoC） 和依赖注入（DI）功能。
2. **Spring Context（应用上下文）**： 基于 Core 提供了框架式的 Bean 访问方式。
3. **Spring AOP（面向切面编程）**：实现了横切关注点的模块化。
4. **Spring MVC（模型-视图-控制器）**： 用于构建基于 Web 的应用程序，提供了请求处理、视图解析等功能。
5. **Spring DAO（数据访问对象）**： 简化了数据访问层的开发，提供了对 JDBC、ORM 的支持。
6. **Spring Expression Language（SpEL）**： 提供了强大的表达式语言，支持在运行时查询和操作对象。

---

#### 延申问答
- Spring Core（核心容器）相关
	- [x] IoC 和 DI 的核心思想？区别？
	- [x] Spring Bean 的生命周期？作用域？
	- [x] 如何通过注解实现 Bean 的装配？
- Spring Context（应用上下文）相关
	- [x] BeanFactory 和 ApplicationContext 的区别是什么？
	- [x] Spring 事件机制是如何工作的？
	- [x] 如何加载外部资源文件（如配置文件或国际化资源）？
- Spring AOP（面向切面编程）相关
	- [x] AOP 的核心概念？（切面、连接点、切入点、通知等）
	- [x] Spring AOP 的实现原理是什么？基于动态代理还是 CGLIB？
	- [x] AOP 的应用场景有哪些？
- Spring Expression Language（SpEL）相关
	- [x] SpEL 常用的操作有哪些？（属性访问、方法调用、集合操作等）
	- [x] 在项目中如何通过 SpEL 动态注入值？
	- [x] 实际场景中，SpEL 能解决哪些问题？
- Spring MVC（模型-视图-控制器）相关
	- [x] Spring MVC 的工作流程？
	- [x] 如何处理 JSON 格式的请求和响应？如何进行数据绑定？
	- [x] 如何通过注解实现 RESTful API？
- Spring DAO（数据访问对象）相关
	- [x] 什么是 `JdbcTemplate`？如何使用它简化数据库操作？
	- [x] Spring 是如何处理数据访问异常的？
	- [x] ORM 集成（如 Hibernate 或 JPA）的具体实现方式是什么？


### 解释Spring中的IoC（控制反转）原理，并举例说明。
#### 简洁回答
- **控制反转（Inversion of Control, IoC）【思想】：** 指将对象的创建、初始化及依赖管理的控制权从应用代码转移到 Spring 容器。
	- 传统方式： 对象由程序创建，依赖通过硬编码传递（代码写死而不是通过配置动态控制），高耦合。
	- IoC 方式： Spring 容器负责对象创建和依赖，模块之间只需要声明依赖，低耦合。
- **依赖注入（Dependency Injection, DI）【实现方式】：** 容器根据配置将所需的依赖注入到对象中。
	1. Setter 注入。
		- 适用于可选依赖的注入、自己开发的模块的注入
		- 如果只有Setter方法，没有注入，会导致null对象出现。
		- 配置`<bean>`用`<property>`标签的`value`或`ref`属性。
	2. 构造器注入（推荐）。
		- 适用于强制依赖的注入、第三方不含setter的模块的注入
		- 构造器注入结合 `@Qualifier` 或策略模式明确依赖关系，可以避免多个依赖注入混乱。
		- 配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性。
	3. 自动装配（不推荐）
		- 不推荐原因：隐式依赖关系导致的可测试性差和不易维护。具体来说，不能通过构造器或 setter 方法修改依赖关系，因为 Spring 会在创建 Bean 时自动完成依赖注入，测试代码无法显式地控制 Mock （模仿）对象的注入，只能使用 `@InjectMocks` 和 `@Mock` 等注解来让 Mockito 和 Spring 协作进行注入，或者采用构造器注入来手动控制 Mock 对象的注入。
		- 如果必须使用字段注入，可以通过一些工具（如 `ReflectionTestUtils`）来在测试中设置字段值
		- 配置`<bean>`用`autowire="xx"`。

---

#### 详细回答
#####  **1. IoC入门案例**
**思路：**
- **如何将被管理的对象告知IoC容器？** 配置。
- **如何获取到IoC容器？** 接口。
- **如何从容其中获取bean？** 接口方法。

**实践：**
1. **导入和配置。** 导入坐标`spring-context`后新建配置文件`applicationContext.xml`并配置bean（包括id，class）
2. **获取IoC容器。** `new ClassPathXmlApplicationContext("applicationContext.xml")`
3. **获取bean。** `ctx.getBean("bookDao")`

#####  **2. DI的三种注入方法**
**思路：**
- **注入什么类型？** 
	- **简单类型（如int、String）**。用`<property>`标签的`value`属性
	- **引用类型**。用`<property>`标签的`ref`属性
	- **集合**。用`<property>`标签的`<array>``<list>``<set>``<map>``<props>`子标签

**实践：**
1. **Setter 注入**：通过 Setter 方法，配置`<bean>`用`<property>`标签的`value`或`ref`属性注入。
	- 如果只有Setter方法，没有注入，会导致null对象出现。
	- 适用于可选依赖的注入、自己开发的模块的注入。
	![image.png](http://cdn.kamacoder.com/67553ebac9455-phpelMxgP.png)
2. **构造器注入（Spring推荐）**：通过构造函数，配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性注入。
	- 形参名的耦合问题解决：用`type`属性替代`name`属性。
	- 多个同类型的解决：用`index`属性替代`type`属性。
	- 适用于强制依赖的注入、第三方不含setter的模块的注入。
3. **自动装配（不推荐）**：配置`<bean>`用`autowire="xx"`，通过Setter方法 或 直接在字段上使用 `@Autowired`注入。
	- `autowire="byType"`按类型装配（推荐）。
		- 发现有多个class相同的bean，那装配谁呢？失败。
		- ![image.png](http://cdn.kamacoder.com/67554631ea319-phpO8de4F.png)
	- `autowire="byName"`按名称装配。（不推荐，因为变量名与配置耦合）

---

#### 延申问题
- [x] [**Spring框架中的@Autowired和@Resource注解有什么区别？**](https://notes.kamacoder.com/question/100541)
- [x] [**Spring 是如何管理 Bean 的生命周期的？有哪些生命周期方法？**](https://notes.kamacoder.com/question/100530)
- [x] [**Bean 的作用域有哪些？如何配置不同作用域？**](https://notes.kamacoder.com/question/100531)
- [x] **如果需要动态注入依赖，比如运行时决定使用哪个实现，如何实现？**
	- 可使用 `@Qualifier` 指定 Bean，或通过 `@Conditional` 注解根据条件动态加载 Bean。
- [ ] **在依赖注入过程中，如何解决循环依赖问题？**
	- Spring 使用三级缓存解决循环依赖，允许提前暴露 Bean 引用，避免死循环。
		1. SingletonFactory
		2. Early Bean Reference
		3. Fully Initialized Bean

- [ ] **如何使用第三方库实现 IoC？Spring IoC 与其他 IoC 框架（如 Guice）相比有何优势？**
	- 第三方库： Guice IoC 框架。
	- Spring IoC 提供更丰富的生态（如 AOP、数据访问支持）和灵活的配置方式（XML、注解、JavaConfig）


### Spring容器是如何管理Bean的生命周期的？包括哪些阶段？
#### 简洁回答
Spring 容器通过**配置或注解**管理 **Bean 的生命周期**（从创建到销毁的整个过程），包括以下阶段：
1. **实例化：** 执行构造方法创建对象，分配内存
2. **属性赋值：** set操作
3. **初始化** `implements InitializingBean` ，调用其 `afterPropertiesSet()` 方法。
	1. `Aware` 接口的依赖注入
	2. `BeanPostProcessor` 在初始化前后的处理
	3. `InitializingBean` 和 `init-method` 的初始化操作
4. 使用bean执行业务操作
5. **销毁** `implements DisposableBean` ，调用其 `destroy()` 方法。

---

#### 前置知识
- bean作用范围
- bean默认单例
	- 适合交给容器管理的bean：Service、Dao层对象
	- 不适合交给容器管理的bean：封装实体的域对象（有指定值）
- bean实例化
	1. 构造方法：无参构造方法、反射获取
	3. 静态工厂：`factory-method`
		```xml
		<bean id="orderDao" class="com.itheima.factory.OrderDaoFactory" factory-method ="getorderDao"/>
		```
	3. 实例工厂：
		- factory-bean="xx"
			```xml
			<bean id="userFactory" class="com.itheima.factory.UserDaoFactory" >
			<bean id="userDao" factory-method="getuserDao" factory-bean="userFactory" />
			```
		- FactoryBean
			![image.png](http://cdn.kamacoder.com/6755657ee33e2-phpVOnGPM.png)

---

#### 详细回答
1. **实例化：** 执行构造方法创建对象，分配内存
2. **属性赋值：** set操作
3. **初始化**
	- 自定义配置： `@PostConstruct` 或`init-method="xx"`
	- 实现接口： `implements InitializingBean` ，调用其 `afterPropertiesSet()` 方法。
		- 注意：在set方法的属性设置之后才执行该方法
4.使用bean执行业务操作
5. **销毁**
	- 自定义配置： `@PreDestroy` 或`destroy-method="xx"`
		- 注意：容器关闭时调用销毁逻辑，要想看到destroy-method执行：
			1. 暴力手动关闭：在JVM结束前通过`ClassPathXmlApplication接口close()方法`关闭容器
			2. 注册关闭钩子：`ClassPathXmlApplication接口registerShutdownHook()方法`
	- 实现接口： `implements DisposableBean` ，调用其 `destroy()` 方法。

![spring-bean-lifestyle.png](http://cdn.kamacoder.com/67558de2a9c6e-phpjekGCZ.png) 

---

#### 延伸问答
- [x]  **如何自定义 Bean 的初始化和销毁行为？**
	- 在配置文件中指定 `init-method="xx"` 和 `destroy-method="xx"`
	- 使用注解 `@PostConstruct` 和 `@PreDestroy`：
- [ ]  **Spring Bean 生命周期的扩展点有哪些？**
	- 使用 `BeanPostProcessor` 在初始化前后执行自定义逻辑。
	- 使用 `BeanFactoryPostProcessor` 修改 Bean 的定义或属性。
- [ ]  **不同作用域的生命周期有何区别？**
	- `singleton`：与容器生命周期一致，容器关闭时销毁。
	- `prototype`：每次获取新实例，无全局生命周期管理，不执行销毁方法。

### Spring中Bean的作用域有哪些？分别适用于什么场景？
#### 简洁回答
**2基础作用域 + 4仅Web 应用可用：**
1. **singleton（默认）：** IoC 容器中只有唯一的 bean 实例，适用于无状态的共享资源。
	- 作用域对生命周期的影响：Spring 管理整个生命周期，容器会自动调用销毁逻辑。
2. **prototype：** 每次获取bean都创建一个新实例，适用于短期使用的有状态且非线程安全的对象。
	- 作用域对生命周期的影响：Spring 只负责创建，由客户端决定何时销毁。
	- 应用：唯一标识符（UUID 、验证码、Token）、用户临时数据（表单数据缓存、文件上传临时存储）
3. **request：** 每个 HTTP 请求创建一个实例，如表单数据处理。
4. **session：** 每个会话创建一个实例，如用户信息缓存。
5. **application/global-session：** 在Web应用启动时创建一个bean，如统计数据。
6. **websocket：** 每个 WebSocket 会话创建一个实例，适用于WebSocket 连接状态管理。

----

#### 延申问答
- [x] **如何指定 Bean 作用域？**
	1. xml 方式
		```
		<bean id="..." class="..." scope="singleton"></bean>
		```
	2. 注解方式
		```
		@Bean
		@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
		public Person personPrototype() {
			return new Person();
		}
		```
- [x] **如何测试作用域行为？**
	- 可通过使用 `bean1.hashCode()` 或`System.identityHashCode(bean1)` 打印 Bean 的哈希值验证是否是同一实例。
- [x] Bean是线程安全的吗？
	Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。
我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。
prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。
有状态 Bean 示例：
```
// 定义了一个购物车类，其中包含一个保存用户的购物车里商品的 List
@Component
public class ShoppingCart {
    private List<String> items = new ArrayList<>();

    public void addItem(String item) {
        items.add(item);
    }

    public List<String> getItems() {
        return items;
    }
}
```


不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。
无状态 Bean 示例：
```
// 定义了一个用户服务，它仅包含业务逻辑而不保存任何状态。
@Component
public class UserService {

    public User findUserById(Long id) {
        //...
    }
    //...
}
```


对于有状态单例 Bean 的线程安全问题，常见的三种解决办法是：
1. **避免可变成员变量**: 尽量设计 Bean 为无状态。
2. **使用`ThreadLocal`**: 将可变成员变量保存在 `ThreadLocal` 中，确保线程独立。
3. **使用同步机制**: 利用 `synchronized` 或 `ReentrantLock` 来进行同步控制，确保线程安全。

这里以 `ThreadLocal`为例，演示一下`ThreadLocal` 保存用户登录信息的场景：
```
public class UserThreadLocal {

    private UserThreadLocal() {}

    private static final ThreadLocal<SysUser> LOCAL = ThreadLocal.withInitial(() -> null);

    public static void put(SysUser sysUser) {
        LOCAL.set(sysUser);
    }

    public static SysUser get() {
        return LOCAL.get();
    }

    public static void remove() {
        LOCAL.remove();
    }
}
```

### 说一说你对Spring AOP的了解，它主要解决什么问题？
#### 简洁回答
1. 定义和目标：Spring AOP（Aspect-Oriented Programming，面向切面编程），目标是减少重复代码，降低模块间耦合度，提高可扩展性和可维护性。
2. 工作机制：Spring AOP 基于动态代理和 Cglib 实现，封装通用逻辑（例如日志记录、事务管理、权限控制、性能监控等）：
	- 对于实现了某个接口的对象： Spring AOP 会使用 JDK Proxy创建代理对象
	- 对于没有实现接口的对象：使用 Cglib 生成一个被代理对象的子类来作为代理
3. 专业术语
	- **切面(Aspect) = 切入点(Pointcut) + 通知(Advice)**
		- **切入点（Pointcut）：** 被切面拦截 / 增强的连接点
			- **连接点（Join Point）：** 目标对象的所属类中，定义的所有方法均为连接点
			- 切入点一定是连接点，连接点不一定是切入点
		- **通知（Advice）：** 增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情。
			- **目标(Target)：** 被通知的对象
			- **代理(Proxy)：** 向目标对象应用通知之后创建的代理对象
			- **Weaving(织入)：** 将通知应用到目标对象，进而生成代理对象的过程动作
----

#### 详细回答

----

#### 延伸问答
- [ ] **Spring AOP 和 AspectJ AOP 有什么区别？**
	- Spring AOP：运行时增强，基于代理，集成了 AspectJ且更简单方便
	- AspectJ：编译时增强，基于字节码操作，提供更全面的 AOP 支持（如字段、构造函数切点）。
		- 当切面太多时最好选择 AspectJ ，快很多。
- [x] **AOP 常见的通知类型有哪些？**
	- **Before**（前置通知）：目标对象的方法调用之前触发
	- **After** （后置通知）：目标对象的方法调用之后触发
	- **AfterReturning**（返回通知）：目标对象的方法调用完成，在返回结果值之后触发
	- **AfterThrowing**（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。
		- AfterReturning 和 AfterThrowing 两者互斥。
	- **Around** （环绕通知）：可操作范围最大，可以直接拿到目标对象以及要执行的方法，可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法
	![aspectj-advice-types.jpg](http://cdn.kamacoder.com/67559341b3761-phpqUAJOq.jpg) 
- [x] **多个切面的执行顺序如何控制？**
	1. 通常使用`@Order` 注解直接定义切面顺序，值越小优先级越高。
	2. `implements Ordered` 接口重写 `getOrder` 方法，返回值越小优先级越高。

### 说一说你对 Spring中IOC的理解。
#### 简洁回答
- **控制反转（Inversion of Control, IoC）【思想】：** 指将对象的创建、初始化及依赖管理的控制权从应用代码转移到 Spring 容器。
	- 传统方式： 对象由程序创建，依赖通过硬编码传递（代码写死而不是通过配置动态控制），高耦合。
	- IoC 方式： Spring 容器负责对象创建和依赖，模块之间只需要声明依赖，低耦合。
- **依赖注入（Dependency Injection, DI）【实现方式】：** 容器根据配置将所需的依赖注入到对象中。
	1. Setter 注入。
		- 适用于可选依赖的注入、自己开发的模块的注入
		- 如果只有Setter方法，没有注入，会导致null对象出现。
		- 配置`<bean>`用`<property>`标签的`value`或`ref`属性。
	2. 构造器注入（推荐）。
		- 适用于强制依赖的注入、第三方不含setter的模块的注入
		- 构造器注入结合 `@Qualifier` 或策略模式明确依赖关系，可以避免多个依赖注入混乱。
		- 配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性。
	3. 自动装配（不推荐）
		- 不推荐原因：隐式依赖关系导致的可测试性差和不易维护
			1. 可测试性差： 不能通过构造器或 setter 方法修改依赖关系，因为 Spring 会在创建 Bean 时自动完成依赖注入，测试代码无法显式地控制 Mock （模仿）对象的注入，增加了测试难度。
			2. 不易维护：因为它没有明确显示依赖项，导致代码难以理解和维护。
		- 如果必须使用字段注入，可以通过一些工具（如 `ReflectionTestUtils`）来在测试中设置字段值
		- 配置`<bean>`用`autowire="xx"`。

---

#### 详细回答
#####  **1. IoC入门案例**
**思路：**
- **如何将被管理的对象告知IoC容器？** 配置。
- **如何获取到IoC容器？** 接口。
- **如何从容其中获取bean？** 接口方法。

**实践：**
1. **导入和配置。** 导入坐标`spring-context`后新建配置文件`applicationContext.xml`并配置bean（包括id，class）
2. **获取IoC容器。** `new ClassPathXmlApplicationContext("applicationContext.xml")`
3. **获取bean。** `ctx.getBean("bookDao")`

#####  **2. DI的三种注入方法**
**思路：**
- **注入什么类型？** 
	- **简单类型（如int、String）**。用`<property>`标签的`value`属性
	- **引用类型**。用`<property>`标签的`ref`属性
	- **集合**。用`<property>`标签的`<array>``<list>``<set>``<map>``<props>`子标签

**实践：**
1. **Setter 注入**：通过 Setter 方法，配置`<bean>`用`<property>`标签的`value`或`ref`属性注入。
	- 如果只有Setter方法，没有注入，会导致null对象出现。
	- 适用于可选依赖的注入、自己开发的模块的注入。
	![image.png](http://cdn.kamacoder.com/67553ebac9455-phpelMxgP.png)
2. **构造器注入（Spring推荐）**：通过构造函数，配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性注入。
	- 形参名的耦合问题解决：用`type`属性替代`name`属性。
	- 多个同类型的解决：用`index`属性替代`type`属性。
	- 适用于强制依赖的注入、第三方不含setter的模块的注入。
3. **自动装配（不推荐）**：配置`<bean>`用`autowire="xx"`，通过Setter方法 或 直接在字段上使用 `@Autowired`注入。
	- `autowire="byType"`按类型装配（推荐）。
		- 发现有多个class相同的bean，那装配谁呢？失败。
		- ![image.png](http://cdn.kamacoder.com/67554631ea319-phpO8de4F.png)
	- `autowire="byName"`按名称装配。（不推荐，因为变量名与配置耦合）

---

#### 延申问题
- [x] [**Spring框架中的@Autowired和@Resource注解有什么区别？**](https://notes.kamacoder.com/question/100541)
- [x] [**Spring 是如何管理 Bean 的生命周期的？有哪些生命周期方法？**](https://notes.kamacoder.com/question/100530)
- [x] [**Bean 的作用域有哪些？如何配置不同作用域？**](https://notes.kamacoder.com/question/100531)
- [x] **如果需要动态注入依赖，比如运行时决定使用哪个实现，如何实现？**
	- 可使用 `@Qualifier` 指定 Bean，或通过 `@Conditional` 注解根据条件动态加载 Bean。
- [ ] **在依赖注入过程中，如何解决循环依赖问题？**
	- Spring 使用三级缓存解决循环依赖，允许提前暴露 Bean 引用，避免死循环。
		1. SingletonFactory
		2. Early Bean Reference
		3. Fully Initialized Bean

- [ ] **如何使用第三方库实现 IoC？Spring IoC 与其他 IoC 框架（如 Guice）相比有何优势？**
	- 第三方库： Guice IoC 框架。
	- Spring IoC 提供更丰富的生态（如 AOP、数据访问支持）和灵活的配置方式（XML、注解、JavaConfig）


### Spring中用到了那些设计模式。
#### 简洁回答
- **工厂设计模式** : Spring 使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。
- **单例设计模式** : Spring 中的 Bean 默认都是单例的。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式** : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。
- ……


### 描述一下 SpringMVC 的执行流程。
#### 简洁回答
1. **请求、到达** 客户端发起请求 ->  `DispatcherServlet` 
2. **查找、处理、返回**  （2-5）
	- 查找：用`HandlerMapping` 根据请求的 URL、HTTP 方法查找合适的Controller。
	- 处理：用`HandlerAdapter`调用Controller处理
	- 返回：返回 `ModelAndView` 对象
3. **解析、渲染、返回** （6-8）
	- 解析：用`ViewResolver` 将逻辑视图名称解析为具体的视图对象（如 JSP 文件）。
	- 渲染： 根据 `Model` 中的数据渲染页面，并将响应返回给客户端。

![de6d2b213f112297298f3e223bf08f28.png](http://cdn.kamacoder.com/6756edd2e2399-phpODdSF3.png) 

----

#### 详细回答
MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。
##### Spring MVC 的核心组件
- **`DispatcherServlet`**：**中央处理器**，负责接收请求、分发，并给予客户端响应。
- **`HandlerMapping`**：**处理器映射器**，根据 URL 去匹配查找能处理的 `Handler` ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
- **`HandlerAdapter`**：**处理器适配器**，根据 `HandlerMapping` 找到的 `Handler` ，适配执行对应的 `Handler`；
- **`ModelAndView`**：**模型和视图**，包含模型数据和视图名称，用于在处理器和视图之间传递数据。
- **`ViewResolver`**：**视图解析器**，将视图名称解析为具体的视图对象，支持多种视图技术（如 JSP、Thymeleaf）。

##### Spring MVC 的工作流程
1. **请求、到达** 客户端发起请求 ->  `DispatcherServlet` 
2. **查找、处理、返回**  （2-5）
	- 查找：用`HandlerMapping` 根据请求的 URL、HTTP 方法查找合适的Controller。
	- 处理：用`HandlerAdapter`调用Controller处理
	- 返回：返回 `ModelAndView` 对象
3. **解析、渲染、返回** （6-8）
	- 解析：用`ViewResolver` 将逻辑视图名称解析为具体的视图对象（如 JSP 文件）。
	- 渲染： 根据 `Model` 中的数据渲染页面，并将响应返回给客户端。

![de6d2b213f112297298f3e223bf08f28.png](http://cdn.kamacoder.com/6756edd2e2399-phpODdSF3.png) 

----

#### 延伸问答
- [ ] **如何自定义 SpringMVC 的 `HandlerMapping` 和 `ViewResolver`？**
	通过implements`WebMvcConfigurerAdapter` 或 `WebMvcConfigurer` 接口，在 `configureHandlerMapping()` 和 `configureViewResolvers()` 方法中自定义映射和视图解析器。
- [x] **SpringMVC 的拦截器如何工作？**
	- 通过实现 `HandlerInterceptor` 接口，在请求到达 Controller 之前和响应返回客户端之前执行，通常用于处理日志、权限验证等跨切面逻辑。
- [ ] **为什么需要前端控制器（DispatcherServlet）？**
	将所有的请求集中处理，简化了请求分发和响应管理，实现解耦、集中配置、增强扩展性。
- [ ] **SpringMVC 支持哪些类型的视图？**
	SpringMVC 支持多种视图解析技术，如 JSP、Thymeleaf、Freemarker、Velocity 等，也支持直接返回 JSON、XML 数据（使用 `@ResponseBody`）。

### SpringMVC 中的DispatcherServlet扮演什么角色？
#### 简洁回答
##### 1. 地位（角色）
**核心调度器 / 请求分发中心：** ：所有请求都由`DispatcherServlet`统一管理，根据请求 URL查找对应的处理器（Controller），并协调视图解析器生成最终的响应。
##### 2. 作用	
- **解耦：** `DispatcherServlet` 通过 HandlerMapping 和 ViewResolver 解耦了请求和处理逻辑。
- **灵活性：** 可配置多个 `HandlerMapping` 和 `ViewResolver` 实现，支持复杂的请求分发和视图解析。
- **扩展性：** 提供了拦截器（Interceptor）机制，可在请求处理前后执行额外的逻辑。

----

#### 详细回答

----

#### 延伸回答
- [x] **`DispatcherServlet` 和传统 Front Controller 的区别是什么？**
	- `DispatcherServlet` 提供了完整的扩展机制（如拦截器、异常处理器等），而传统 Front Controller 逻辑通常较固定。
- [x] **`DispatcherServlet` 如何与其他组件协作？**
	- 使用 `HandlerMapping` 查找 Controller，`HandlerAdapter` 调用具体方法。
	- 使用 `ViewResolver` 解析逻辑视图名并返回渲染的结果。
- [ ] **是否可以自定义 `DispatcherServlet`？**
	- 可以通过扩展 `DispatcherServlet` 类自定义其行为，例如重写 `doDispatch()` 方法来调整请求处理逻辑。
	- 也可以通过配置文件调整其参数（如文件上传、初始化参数等）。

### SpringMVC 中如何配置控制器（Controller）？
#### 简洁回答
- **使用注解方式（推荐）：** 
	- 使用 `@Controller `标识类为控制器，并使用 `@RequestMapping` 指定 URL 映射关系。
	- 在 Spring 启动类中启用注解扫描`@ComponentScan`
- **使用 XML 配置方式：** 
	- 在 XML 文件中声明 `Controller` 的 Bean 。
	- 使用 `<mvc:annotation-driven />`配置请求映射。

---

#### 详细回答

---

#### 延伸问答
- [x] **如何配置多级 URL？**
	- 使用类级别和方法级别的 `@RequestMapping`：
	```java
	@Controller
	@RequestMapping("/users")
	public class UserController {
	    @GetMapping("/{userId}/orders")
	    public String getUserOrders(@PathVariable Long userId) {
	        return "orderView";
	    }
	}
	```

### Spring中如何配置和使用事务管理？有哪些事务传播行为？
#### 简洁回答
##### 事务管理
1. 配置事务
	- 引入依赖`spring-boot-starter-data-jpa`
	-  使用`@EnableTransactionManagement` 启用事务支持
	- Spring自动配置了数据源和事务管理器，也可以自定义 `DataSourceTransactionManager`或`JpaTransactionManager`Bean。
2. 使用事务
	- 在类或方法上添加 `@Transactional` 注解，Spring 自动管理事务的开启、提交和回滚。
##### 事务传播行为
Spring 提供了 7 种事务传播行为（Propagation）来定义方法如何加入或创建事务：
|**传播行为**|**描述**|
|:-:|:-:|
|`REQUIRED`|默认值，加入当前事务，如果没有事务则创建新事务。|
|`REQUIRES_NEW`|总是创建一个新事务，挂起当前事务。|
|`SUPPORTS`|如果有事务则加入事务，没有事务则以非事务方式运行。|
|`NOT_SUPPORTED`|总是以非事务方式运行，挂起当前事务。|
|`MANDATORY`|必须在事务中运行，如果没有事务则抛出异常。|
|`NEVER`|必须在非事务环境中运行，如果存在事务则抛出异常。|
|`NESTED`|如果当前有事务，则在嵌套事务中运行，否则创建新事务（需要底层数据库支持 Savepoint）。|

----

#### 详细回答

----

#### 延伸问答
- [ ] **如何配置事务回滚规则？**
	- 默认情况下，`@Transactional` 会对所有 `RuntimeException` 和子类进行回滚。
	- 如果需要指定回滚规则，可以使用 `rollbackFor`
		```java
		@Transactional(rollbackFor = {IOException.class, SQLException.class})
		public void saveData() throws IOException {
		    // 业务逻辑
		}
		```
- [ ] **事务的隔离级别有哪些？**
	- Spring 提供 5 种隔离级别，与数据库事务隔离级别对应：- `DEFAULT`：使用数据库默认隔离级别。
		- `READ_UNCOMMITTED`：允许读取未提交的数据（脏读）。
		- `READ_COMMITTED`：防止脏读，默认隔离级别。
		- `REPEATABLE_READ`：防止脏读和不可重复读。
		- `SERIALIZABLE`：防止所有并发问题，性能最低。
- [ ] **事务嵌套与传播行为的区别？**
	- 嵌套事务（`NESTED`）：在当前事务中创建子事务，回滚只影响子事务。
	- 传播事务（`REQUIRES_NEW`）：创建独立事务，与当前事务无关。

### 解释一下Spring中的@Transactional注解及其属性。
#### 简洁回答
`@Transactional` 是 Spring 用于声明式事务管理的注解，支持自动控制事务的开启、提交和回滚。
常用属性包括：
1. **`propagation`：** 定义事务传播行为（如 `REQUIRED`、`REQUIRES_NEW` 等）。
2. **`isolation`：** 指定事务的隔离级别（如 `READ_COMMITTED`、`SERIALIZABLE`）。
3. **`timeout`：** 设置事务的超时时间（单位：秒）。如果事务在超时时间内未完成，则强制回滚。
4. **`rollbackFor` 和 `noRollbackFor`：** 定义哪些异常会触发回滚或不触发回滚。
5. **`readOnly`：** 标记事务为只读，提高查询性能。

----

#### 详细回答
1. **`propagation`（事务传播行为）：** 定义方法的事务如何与现有事务交互。
	- `REQUIRED`（默认）：加入当前事务，没有则新建。
	- `REQUIRES_NEW`：挂起当前事务，创建新事务。
	- `SUPPORTS`：在事务中运行，没有事务则以非事务方式运行。
2. **`isolation`（事务隔离级别）：** 定义事务如何隔离并发操作，避免脏读、不可重复读、幻读等问题。
	- `DEFAULT`（默认值）：使用数据库的默认隔离级别。
	- `READ_COMMITTED`：防止脏读。
	- `REPEATABLE_READ`：防止脏读和不可重复读。
	- `SERIALIZABLE`：防止所有并发问题，但性能最低。
3. **`timeout`（超时时间）：** 设置事务的超时时间（单位：秒）。如果事务在超时时间内未完成，则强制回滚。
4. **`rollbackFor` 和 `noRollbackFor`（回滚规则）：** 指定哪些异常会触发或不触发事务回滚。默认情况下，`RuntimeException` 或 `Error` 会触发回滚。
5. **`readOnly`（只读事务）：** 标记事务为只读，优化性能（主要用于查询操作）。

----

#### 延伸问答

- [ ] **如何自定义事务管理器？**
	- 如果有多个数据源，可以通过 `@Transactional(transactionManager = "customTransactionManager")` 指定特定事务管理器：

- [ ] **`@Transactional` 注解的局限性：**
	- 不支持构造方法。
	- 只能作用于 Spring 管理的 Bean。
	- 事务方法需要通过代理调用才能生效（不能直接在同一个类中调用）。
- [ ] **事务嵌套与传播行为的选择：**
	- 嵌套事务可以通过 `NESTED` 实现，适合保存点场景。
	- `REQUIRES_NEW` 独立事务适合关键操作，不受外层事务影响。

### Spring框架中如何定义和使用自定义事件和监听器？
#### 简洁回答
通过自定义事件和监听器，Spring 提供了一种解耦组件之间通信的机制，适用于跨模块事件驱动的开发场景，例如异步通知和任务触发。
1. **定义事件类：** 继承 `ApplicationEvent` 或使用任意 POJO。
2. **发布事件：** 使用 `ApplicationEventPublisher` 的 `publishEvent()` 方法发布事件。
3. **监听事件：** 使用 `@EventListener` （推荐）或实现 `ApplicationListener` 接口处理事件。

---

#### 详细回答

---

#### 延伸问答
- [ ] **如何处理异步事件？**
	- 在 `@EventListener` 上添加 `@Async` 注解，并确保项目中配置了异步支持
- [ ] **如何监听多个事件？**
	- 一个监听器可以监听多个事件，通过 `@EventListener` 方法参数指定：
	```java
	@EventListener
	public void handleMultipleEvents(Object event) {
		if (event instanceof CustomEvent) {
			System.out.println("CustomEvent: " + ((CustomEvent) event).getMessage());
		} else if (event instanceof AnotherEvent) {
			System.out.println("AnotherEvent received.");
		}
	}
	```
- [ ] **如何使用条件监听？**
	- 在 `@EventListener` 中添加 `condition` 属性：
	```java
	@EventListener(condition = "#event.message == 'specific'")
	public void handleConditionalEvent(CustomEvent event) {
		System.out.println("Condition met: " + event.getMessage());
	}
	```



### Spring框架中的@Autowired和@Resource注解有什么区别？
#### 简洁回答
1. **`@Autowired`：** Spring 特有，默认**按类型（byType）** 自动注入。
	- 注解来源：Spring 特有，支持`@Autowired(required = false)`表示依赖项可选，即没有匹配到 Bean 时，不抛异常，而是注入 `null`。
	- 如果存在多个相同类型的 Bean，可结合 `@Qualifier` 注解指定注入的 Bean 名称。
2. **`@Resource`：** JSR-250 标准，默认**按名称（byName）** 注入。
	- JSR-250 标准，更适合标准化和跨框架使用。
	- 如果未指定名称且没有匹配的 Bean，会按类型注入。

---

#### 详细回答
1. **`@Autowired`：** 
	```java
	@Component
	public class UserService {
		@Autowired
		private UserRepository userRepository; // 默认按类型注入

		@Autowired
		@Qualifier("specialUserRepository") // 指定名称
		private UserRepository specialRepository;
	}
	```

2. **`@Resource`：** 
	```java
	@Component
	public class UserService {
		@Resource(name = "userRepository") // 默认按名称注入
		private UserRepository userRepository;

		@Resource(type = SpecialUserRepository.class) // 按类型注入
		private SpecialUserRepository specialRepository;
	}
	```


### Spring框架如何支持JDBC模板（JdbcTemplate）来简化数据库操作？
#### 知识索引
- **Spring 数据访问 → 数据库操作 → JdbcTemplate**

----

#### 简洁回答
Spring 的 `JdbcTemplate`  **简化 JDBC 操作**，帮助开发者高效地执行数据库查询、更新和调用存储过程。
它通过**封装常见的资源管理和异常处理**，避免了冗余的代码，提高了开发效率。

----

#### 详细回答
1. **优势：**
	- 自动管理资源：如 `Connection`、`PreparedStatement` 和 `ResultSet`。
	- 简化异常处理：将检查型异常（如 `SQLException`）转换为 Spring 的 `DataAccessException`。
	- 提供模板方法：减少重复代码，开发者只需专注于 SQL 和业务逻辑。
2. **核心功能：**
	- **查询操作（查询单行、多行）：**
		```java
		String sql = "SELECT name FROM users WHERE id = ?";
		String name = jdbcTemplate.queryForObject(sql, new Object[]{1}, String.class);
		```
	- **更新操作（插入、修改、删除）：**
		```java
		String sql = "UPDATE users SET name = ? WHERE id = ?";
		int rowsAffected = jdbcTemplate.update(sql, "NewName", 1);
		```
	- **批量更新：**
		```java
		String sql = "INSERT INTO users (name, age) VALUES (?, ?)";
		List<Object[]> batchArgs = Arrays.asList(
		    new Object[]{"Alice", 30},
		    new Object[]{"Bob", 25}
		);
		jdbcTemplate.batchUpdate(sql, batchArgs);
		```
	- **自定义结果映射：**
		使用 `RowMapper` 将结果集转换为 Java 对象：
		```java
		String sql = "SELECT id, name, age FROM users";
		List<User> users = jdbcTemplate.query(sql, new RowMapper<User>() {
		    @Override
		    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
		        return new User(rs.getInt("id"), rs.getString("name"), rs.getInt("age"));
		    }
		});
		```
3. **配置步骤：**
	- **配置数据源：**
		Spring 需要通过 `DataSource` 提供数据库连接。
		```java
		@Bean
		public DataSource dataSource() {
		    return new DriverManagerDataSource("jdbc:mysql://localhost:3306/testdb", "username", "password");
		}
		```
	- **创建 `JdbcTemplate` Bean：**
		```java
		@Bean
		public JdbcTemplate jdbcTemplate(DataSource dataSource) {
		    return new JdbcTemplate(dataSource);
		}
		```
	- **使用 `JdbcTemplate`：**
		在需要的地方注入并使用：
		```java
		@Autowired
		private JdbcTemplate jdbcTemplate;
		```

----

#### 延伸问答
1. **`JdbcTemplate` 如何简化事务管理？**
	- 与 Spring 的声明式事务管理结合，`JdbcTemplate` 支持自动事务管理，确保在事务边界内完成操作，减少手动管理事务的代码。
2. **与 ORM 框架（如 JPA）的区别？**
	- `JdbcTemplate` 直接基于 SQL 和 JDBC，灵活性更高，适合执行复杂查询或调用存储过程。
	- ORM 框架（如 JPA）通过对象模型抽象了数据库交互，简化了实体管理。
3. **如何处理大批量数据查询？**
	- 使用 `jdbcTemplate.query` 的回调接口 `ResultSetExtractor`，逐行处理结果，避免将所有数据加载到内存中：
	```java
	jdbcTemplate.query("SELECT * FROM large_table", rs -> {
		    while (rs.next()) {
		        // Process each row
		    }
		});
		```

Spring 的 `JdbcTemplate` 是一个轻量级、灵活的数据库操作工具，非常适合场景化开发，尤其是需要高度定制的 SQL 操作。

### Spring框架中的@Repository、@Service、@Controller注解的作用是什么？
#### 简洁回答
1. **`@Repository`：** 标记数据访问层（DAO）组件，能将数据库相关异常转换为 Spring 的数据访问异常（如 `DataAccessException`）
2. **`@Service`：** 标记业务逻辑层（Service）组件。
3. **`@Controller`：** 标记控制层（Controller）组件，常与 `@RequestMapping` 等注解结合，用于定义 Web 路由。

### Spring框架中的@RequestMapping注解有哪些属性？如何配置RESTful风格的URL？
#### 简洁回答
##### @RequestMapping注解的属性
`@RequestMapping` 注解用于映射请求到控制器的方法或类。常用属性包括：
1. **`value`/`path`：** 指定 URL 路径。
2. **`method`：** 限定 HTTP 请求方法（如 GET、POST 等）。
3. **`params` 和 `headers`：** 限定请求参数或请求头。
4. **`consumes` 和 `produces`：** 指定请求的媒体类型（MIME 类型）。
通过在类和方法上使用 `@RequestMapping` 或其简化注解（如 `@GetMapping`），可以轻松配置 RESTful 风格的 URL。

##### REST
**REST**（Representational State Transfer）表现形式状态转换,它是一种软件架构风格。根据REST风格对资源进行访问称为**RESTful**。
**REST的优点**:
- 隐藏资源的访问行为：无法通过地址得知对资源是何种操作
- 书写简化

---

#### 详细回答
##### REST风格举例
- 传统风格资源描述形式
	- `http://localhost/user/getById?id=1` 查询id为1的用户信息
	- `http://localhost/user/saveUser` 保存用户信息
- REST风格描述形式
	- `http://localhost/user/1` 
	- `http://localhost/user`

##### REST入门案例
1. 设定Http请求动作：`@RequestMapping(value="", method = RequestMethod.POST|GET|PUT|DELETE)`
2. `@PathVariable`设定请求参数（路径变量）
@RequestMapping(value="/users/{id}",method = RequestMethod.DELETE)
@ReponseBody
public String delete(@PathVariable Integer id){
}

##### **@PathVariable传递路径参数**
**问题：** 删除方法没有携带所要删除数据的id,所以针对RESTful的开发，如何携带数据参数?
**解决：** 前端发送请求的时候使用:`http://localhost/users/1`,路径中的`1`就是我们想要传递的参数。
	- 修改@RequestMapping的value属性，将其中修改为`/users/{id}`，目的是和路径匹配
	- 在方法的形参前添加@PathVariable注解

**1. 如果方法形参的名称和路径`{}`中的值不一致，该怎么办?**
	![1630506231379.png](http://cdn.kamacoder.com/6759029fe0ae7-phpIzd4tP.png)

**2. 如果有多个参数需要传递该如何编写?**
	```java
	@Controller
	public class UserController {
		//设置当前请求方法为DELETE，表示REST风格中的删除操作
		@RequestMapping(value = "/users/{id}/{name}",method = RequestMethod.DELETE)
		@ResponseBody
		public String delete(@PathVariable Integer id,@PathVariable String name) {
			System.out.println("user delete..." + id+","+name);
			return "{'module':'user delete'}";
		}
	}
	```
---

#### 延伸问答
- [x] **`@RequestBody`、`@RequestParam`、`@PathVariable`的区别？**
	- **@RequestParam用于接收url地址传参或表单传参：** 发送非json格式数据，选用@RequestParam接收请求参数
	- **@RequestBody用于接收json数据：** 发送请求参数超过1个时，以json格式为主，@RequestBody应用较广
	- **@PathVariable用于接收路径参数，使用{参数名称}描述路径参数：** 采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值


### Spring框架中的@ModelAttribute注解的作用是什么？
#### 知识索引
- **Spring MVC → 控制器相关 → @ModelAttribute注解**

----

#### 简洁回答
`@ModelAttribute` 注解用于将请求参数**自动绑定**到方法参数或方法返回值上。它可用于在控制器方法执行前，预先填充模型数据，或者在方法上直接传递对象。

----

#### 详细回答

----

#### 延伸问答

1. **`@ModelAttribute` 与 `@RequestParam` 的区别：**
	- `@RequestParam` 用于将**单个请求参数**绑定到方法参数上
	-  `@ModelAttribute` 通常用于绑定**整个对象**，且可以自动从请求中提取**多个参数**。
2. **`@ModelAttribute` 与 `@RequestBody` 的区别：**
	- `@RequestBody` 用于将**请求体**中的数据绑定到方法参数，通常用于处理 JSON 或 XML 数据；
	- `@ModelAttribute` 处理的是**请求参数**。
3. **如何在控制器中全局使用 `@ModelAttribute` ？**
	- 可以在类级别上使用 `@ModelAttribute`，这样每次调用该控制器方法时，都会先调用该方法来填充数据。

### SpringMVC 中如何处理文件上传和下载？
#### 简洁回答
1. **文件上传：**
	- 配置 `MultipartResolver` 以支持多部分文件请求。
	- 使用 `@RequestParam("file") MultipartFile file` 接收上传文件。
2. **文件下载：**
	- 设置响应头（`Content-Disposition`）指定下载文件名和类型。
	- 将文件内容写入响应的输出流。

----

#### 详细回答
##### **1. 文件上传**
1. **配置 MultipartResolver：** SpringMVC 使用 `MultipartResolver` 处理多部分请求。
2. **实现文件上传控制器：** `FileUploadController`
3. **前端表单：** 使用 `enctype="multipart/form-data"` 指定多部分上传：
##### **2. 文件下载**
1. 实现文件下载控制器：** 使用 `HttpServletResponse` 设置下载响应头，并写入文件流
2. 访问文件下载：用户访问 `/download/{fileName}` 即可触发下载。

----

#### 延伸问答
- [x] **如何限制上传文件大小？**
	- 在 `application.properties` 中设置限制：
		```properties
		spring.servlet.multipart.max-file-size=10MB
		spring.servlet.multipart.max-request-size=20MB
		```
	- 如果使用 `CommonsMultipartResolver`，可以设置 `maxUploadSize` 属性：
		```xml
		<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
			<property name="maxUploadSize" value="10485760" /> <!-- 10MB -->
		</bean>
		```
- [x] **如何处理多文件上传？**
	- 使用 `@RequestParam("files") MultipartFile[] files` 接收多个文件：```
- [x] **如何提升性能？**
	- 使用异步处理文件上传和下载，减少对主线程的阻塞。
	- 结合云存储（如 AWS S3）存储文件，降低本地服务器的负载。

### Spring框架中的异常处理机制是怎样的？
#### 知识索引
- **Spring 基础 → 异常处理机制**

----

#### 黑马
- 编译时异常（如文件名不存在）通过trychatch捕获
- 运行时异常（如int i = 1 / 0）不可预期
##### 异常处理流程
SpringMVC 处理异常的思路是，一路向上抛，都抛给前端控制器 DispatcherServlet ，DispatcherServlet 在调用异常处理器ExceptionResolver进行处理。
##### 异常处理方式
1. 简单异常处理器：使用SpringMVC 内置的异常处理器处理 `SimpleMappingExceptionResolver`； 
	- ![image.png](http://cdn.kamacoder.com/675aa9494982e-phpUjYIR2.png)
	- ![image.png](http://cdn.kamacoder.com/675aa958acd93-phpd9jbQ2.png)
2. 自定义异常处理器：实现`HandlerExceptionResolver`接口，自定义异常进行处理； 
	- ![image.png](http://cdn.kamacoder.com/675aaa6cc5558-phpARhEGp.png)
3. **（推荐）注解方式：** 使用`@ControllerAdvice` + `@ExceptionHandler` 来处理。
	- @ControllerAdvice 注解本质是一个 @Component，也会被扫描到，与此同时，具备AOP功能，默认情况下对所有的Controller都进行拦截操作
	- 拦截后干什么呢？就需要在结合@ExceptionHandler、@InitBinder、@ModelAttribute 注解一起使用了，此处我们讲解的是异常，所以是@ControllerAdvice + @ExceptionHandler的组合形式。
	- ![image.png](http://cdn.kamacoder.com/675aac2fa8d53-phpcUd1gh.png)
##### 异常处理机制原理剖析
- 初始化加载的处理器异常解析器，SpringMVC 的前置控制器在进行初始化的时候，会初始化处理器异常解析器 HandlerExceptionResolver
- 加载DispatcherServlet.properties中默认的异常处理器
- 配置了自定义的异常处理器后，默认的异常处理器就不会被加载，当配置<mvc:annotation-driven /> 或配置了注解@EnableWebMvc后，默认异常处理器和自定的处理器异常解析器都会被注册
- 异常处理器加载完毕后，当发生异常时，就会进行处理，跟踪 DispatcherServlet 的 doDispatch() 方法
- 跟踪processDispatchResult方法
##### 常用的异常解析器
![image.png](http://cdn.kamacoder.com/675aaddf1a8c1-php4X2H2F.png)

---

#### 简洁回答
Spring 框架的异常处理机制分为两部分：
1. **数据访问异常**：Spring 提供统一的 `DataAccessException`，屏蔽底层数据库驱动差异。
2. **MVC 异常处理**：通过 `@ExceptionHandler`、`@ControllerAdvice` 或实现 `HandlerExceptionResolver` 来捕获并处理全局或局部异常。

----

#### 详细回答
##### **1. 数据访问异常**
Spring 提供了 `DataAccessException` 作为统一的异常层次结构，用于屏蔽底层数据库驱动（如 JDBC、Hibernate）的异常差异。
1. **`DataAccessException` 的特点：**
	- 是一个运行时异常，无需强制捕获。
	- 统一管理数据库操作的异常，便于开发者处理和记录。
2. **常见子类：**
	- `BadSqlGrammarException`：SQL 语法错误。
	- `DataIntegrityViolationException`：违反数据库约束（如唯一键）。
	- `EmptyResultDataAccessException`：查询结果为空。
3. **示例：**
	```java
	try {
	    String sql = "SELECT name FROM users WHERE id = ?";
	    jdbcTemplate.queryForObject(sql, new Object[]{1}, String.class);
	} catch (DataAccessException e) {
	    System.err.println("Database error: " + e.getMessage());
	}
	```
##### **2. MVC 异常处理**
###### **2.1 局部异常处理**
1. **`@ExceptionHandler` 注解：**
	通过在控制器中添加 `@ExceptionHandler` 方法，处理特定的异常：
	```java
	@Controller
	public class MyController {
	    @RequestMapping("/test")
	    public String test() {
	        throw new IllegalArgumentException("Invalid argument!");
	    }
	    @ExceptionHandler(IllegalArgumentException.class)
	    public String handleIllegalArgumentException(IllegalArgumentException ex, Model model) {
	        model.addAttribute("error", ex.getMessage());
	        return "errorPage";
	    }
	}
	```

###### **2.2 全局异常处理**

1. **`@ControllerAdvice` 注解：**
	`@ControllerAdvice` 用于定义全局异常处理器，可以跨控制器捕获异常：
	```java
	@ControllerAdvice
	public class GlobalExceptionHandler {
	    @ExceptionHandler(Exception.class)
	    public String handleException(Exception ex, Model model) {
	        model.addAttribute("error", ex.getMessage());
	        return "globalErrorPage";
	    }
	}
	```

###### **2.3 自定义异常解析器**

1. **实现 `HandlerExceptionResolver` 接口：**
	Spring 提供 `HandlerExceptionResolver`，允许开发者自定义异常解析逻辑：
	```java
	public class CustomExceptionResolver implements HandlerExceptionResolver {
	    @Override
	    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
	        ModelAndView mav = new ModelAndView("errorPage");
	        mav.addObject("error", ex.getMessage());
	        return mav;
	    }
	}
	```
2. **注册自定义解析器：**
	在 Spring 配置文件中注册：
	```java
	@Configuration
	public class AppConfig implements WebMvcConfigurer {
	    @Override
	    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
	        resolvers.add(new CustomExceptionResolver());
	    }
	}
	```


----
#### 延伸问答
1. **`@ExceptionHandler` 和 `@ControllerAdvice` 的区别？**
	- `@ExceptionHandler` 是局部异常处理，仅适用于当前控制器。
	- `@ControllerAdvice` 是全局异常处理，可以跨控制器捕获异常。
2. **Spring Boot 如何简化异常处理？**
	- 提供默认的全局异常处理机制（如 `ErrorController`）。
	- 可通过 `@RestControllerAdvice` 处理 RESTful API 的异常，返回 JSON 格式的错误信息。
3. **如何在 RESTful 应用中返回标准化的错误信息？**
	- 使用 `@RestControllerAdvice` 和 `@ExceptionHandler`：
		```java
		@RestControllerAdvice
		public class RestExceptionHandler {
		    @ExceptionHandler(IllegalArgumentException.class)
		    public ResponseEntity<Map<String, String>> handleIllegalArgument(IllegalArgumentException ex) {
		        Map<String, String> error = new HashMap<>();
		        error.put("message", ex.getMessage());
		        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
		    }
		}
		```

### Spring框架中如何配置和使用自定义的PropertyPlaceholderConfigurer？
#### 简洁回答
`PropertyPlaceholderConfigurer` 是 Spring 中用于解析占位符 (`${}`) 并注入外部属性值的工具。通过配置它，可以加载自定义的属性文件，将外部配置注入到 Spring Bean 中。
`PropertyPlaceholderConfigurer` 提供了灵活的外部配置加载方式，适用于传统 XML 配置项目，但在现代 Spring 应用中已被注解和环境配置替代。

----

#### 详细回答
#####  **1. 配置自定义的 `PropertyPlaceholderConfigurer`**
1. **添加自定义属性文件：** 创建一个 `custom.properties` 文件：
	```properties
	app.name=MyCustomApp
	app.version=2.0
	```
2. **XML 配置方式：** 在 Spring 配置文件中声明 `PropertyPlaceholderConfigurer`：
	```xml
	<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	    <property name="locations">
	        <list>
	            <value>classpath:custom.properties</value>
	        </list>
	    </property>
	</bean>
	```
3. **Java 配置方式：** 使用 `@Bean` 创建 `PropertyPlaceholderConfigurer`：
	```java
	@Configuration
	public class AppConfig {
	    @Bean
	    public static PropertyPlaceholderConfigurer propertyPlaceholderConfigurer() {
	        PropertyPlaceholderConfigurer configurer = new PropertyPlaceholderConfigurer();
	        configurer.setLocation(new ClassPathResource("custom.properties"));
	        return configurer;
	    }
	}
	```

##### **2. 使用属性值**
1. **注入属性值：** 使用 `@Value` 注解注入属性值：
	```java
	@Component
	public class MyBean {
	    @Value("${app.name}")
	    private String appName;
	    @Value("${app.version}")
	    private String appVersion;
	    public void printProperties() {
	        System.out.println("App Name: " + appName);
	        System.out.println("App Version: " + appVersion);
	    }
	}
	```
2. **注入到 XML Bean：** 使用占位符配置 XML 中的属性：
	```xml
	<bean id="myBean" class="com.example.MyBean">
	    <property name="appName" value="${app.name}" />
	    <property name="appVersion" value="${app.version}" />
	</bean>
	```

----

#### 延申问答
- [ ] **如何支持多个属性文件？**
	在 `locations` 中配置多个文件路径：
	```xml
	<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	    <property name="locations">
	        <list>
	            <value>classpath:custom.properties</value>
	            <value>classpath:application.properties</value>
	        </list>
	    </property>
	</bean>
	```
- [ ] **如何设置占位符解析失败时的默认行为？**
	配置 `ignoreUnresolvablePlaceholders` 属性，防止未解析占位符抛出异常：
	`configurer.setIgnoreUnresolvablePlaceholders(true);`
- [ ] **`PropertyPlaceholderConfigurer` 与 `@PropertySource` 的区别？**
	- `PropertyPlaceholderConfigurer` 是 XML 配置方式，适合早期 Spring 版本。
	- `@PropertySource` 是基于注解的方式，与现代 Java 配置（`@Configuration`）结合使用。
4. **`PropertyPlaceholderConfigurer` 已过时的替代方案：**
	从 Spring 3.1 开始，推荐使用 `Environment` 和 `@PropertySource` 代替：
	```java
	@Configuration
	@PropertySource("classpath:custom.properties")
	public class AppConfig {
	    @Autowired
	    private Environment env;
	    @Bean
	    public MyBean myBean() {
	        return new MyBean(env.getProperty("app.name"), env.getProperty("app.version"));
	    }
	}
	```

### Spring框架中的@Value注解是如何工作的？它如何注入属性值？
#### 简洁回答

##### 使用示例：
1. **从 `application.properties` 注入值：**
	```properties
	app.name=MyApp
	app.version=1.0
	```
	```java
	@Component
	public class AppConfig {
	    @Value("${app.name}")
	    private String appName;
	    @Value("${app.version}")
	    private String appVersion;
	    public void printConfig() {
	        System.out.println("App Name: " + appName);
	        System.out.println("App Version: " + appVersion);
	    }
	}
	```
2. **注入默认值：** 如果配置属性不存在，可以通过 `:` 指定默认值：
	```java
	@Value("${app.description:Default Description}")
	private String appDescription;
	```
3. **使用 SpEL 表达式：** 支持 Spring 表达式语言（SpEL）进行动态计算：
	```java
	@Value("#{systemProperties['user.home']}")
	private String userHome;
	```

##### 工作原理
1. **属性解析器：** Spring 使用 `PropertySourcesPlaceholderConfigurer` 或 `Environment` 接口解析 `@Value` 注解中的占位符。
2. **解析顺序：**
	- 优先从 `application.properties` 或 `application.yml` 中读取。
	- 支持系统环境变量和 JVM 系统属性。
3. **注入时机：** 属性值在 Bean 实例化阶段（通过 IoC 容器）注入。

### Spring框架中的BeanPostProcessor接口的作用是什么？
#### 知识索引
- **Spring IoC → Bean生命周期 → BeanPostProcessor接口**

----

#### 简洁回答
`BeanPostProcessor` 接口用于在 Bean 初始化前后执行自定义逻辑。通过实现 `postProcessBeforeInitialization` 和 `postProcessAfterInitialization` 方法，可以在 Bean 初始化过程插入额外操作，如属性修改、代理增强等。

----

#### 详细回答
`BeanPostProcessor` 初始化 Bean 时添加自定义逻辑。
1. **接口定义：**
	`BeanPostProcessor` 提供两个回调方法：
	- `postProcessBeforeInitialization`: 在 Bean 初始化方法（如 `@PostConstruct` 或 `afterPropertiesSet`）之前执行。
	- `postProcessAfterInitialization`: 在 Bean 初始化方法之后执行。
	接口定义：
	```java
	public interface BeanPostProcessor {
	    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
	    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
	}
	```
2. **用法示例：**
	自定义一个 `BeanPostProcessor`，在 Bean 初始化前后打印日志：
	```java
	@Component
	public class CustomBeanPostProcessor implements BeanPostProcessor {
	    @Override
	    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
	        System.out.println("Before Initialization: " + beanName);
	        return bean;
	    }
	    @Override
	    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
	        System.out.println("After Initialization: " + beanName);
	        return bean;
	    }
	}
	```
3. **特点：**
	- 可用于修改或替换 Bean 的实例（如动态代理）。
	- 在 Spring 容器中，所有 Bean 都会经过 `BeanPostProcessor` 的处理。
4. **典型应用：**
	- **自动代理机制：** Spring 的 AOP 使用 `BeanPostProcessor` 创建代理对象。
	- **自定义注解解析：** 解析 Bean 中的特定注解并执行相关逻辑。
	- **属性增强：** 在初始化前动态添加或修改属性值。


----

#### 延伸问答
1. **`BeanPostProcessor` 的执行时机是什么？**
	- 在 Bean 的依赖注入完成后、初始化方法执行前后。
	- 不会处理 `@Configuration` 标注的类和部分内部管理的特殊 Bean。
2. **`postProcessBeforeInitialization` 和 `postProcessAfterInitialization` 的区别？**
	- `postProcessBeforeInitialization`: 在初始化方法调用之前执行，适合用于属性值的校验或修改。
	- `postProcessAfterInitialization`: 在初始化方法调用之后执行，适合用于代理增强或其他操作。
3. **如何在项目中禁用特定的 `BeanPostProcessor`？**
	- 可以通过条件注解（如 `@Conditional`）或在配置文件中控制是否注册该 `BeanPostProcessor`。
4. **与 `InitializingBean` 和 `@PostConstruct` 的关系？**
	- `BeanPostProcessor` 是对所有 Bean 的全局增强。
	- 而 `InitializingBean` 和 `@PostConstruct` 是针对某个具体 Bean 的生命周期回调。

### Spring框架中的FactoryBean接口的作用是什么？
#### 简洁回答
- `FactoryBean` 是一种工厂模式的实现，它允许开发者通过实现 `FactoryBean` 接口，自定义 Bean 的创建逻辑。实现该接口的类本身不会作为 Bean，而是由它生成的对象被注入到容器中。
- 适用场景：
	- 创建复杂对象，例如单例模式类的代理对象。
	- 动态配置对象实例，比如根据运行时参数返回不同的 Bean。

----

#### 详细回答
##### `FactoryBean` 接口的主要方法
|方法|作用|
|:-:|:-:|
|`Object getObject()`|定义工厂逻辑，返回创建的对象实例。|
|`Class<?> getObjectType()`|返回工厂生成对象的类型。|
|`boolean isSingleton()`|指定生成的对象是否是单例，返回 `true` 或 `false`。|

----

#### 延申问答
- [ ] **`FactoryBean` 和普通 Bean 的区别？**
	- 普通 Bean：Spring 管理的标准对象，由容器直接实例化。
	- `FactoryBean`：一个创建对象的工厂，它的职责是返回目标对象。
- [ ] **`FactoryBean` 和 `BeanFactory` 的区别？**
	- **`FactoryBean`：** 是用户自定义的工厂类，专注于创建某种特定类型的 Bean。
	- **`BeanFactory`：** 是 Spring 提供的 IOC 容器接口，用于管理和创建 Bean。
- [ ] **常见的内置 `FactoryBean`：**
	- `ProxyFactoryBean`：创建代理对象。
	- `SqlSessionFactoryBean`：用于配置 MyBatis 的 SQL 会话工厂。
	- `JndiObjectFactoryBean`：用于从 JNDI 获取对象。

### Spring框架中如何配置和使用自定义的Scope？
#### 知识索引
- **Spring IoC → Bean作用域 → 自定义Scope**

----

#### 简洁回答
实现步骤如下：
1. **实现 `Scope` 接口：** 定义自定义作用域的逻辑。
2. **注册自定义 Scope：** 使用 `CustomScopeConfigurer` 或 `ConfigurableBeanFactory` 注册。
3. **使用自定义 Scope：** 在 Bean 配置中通过 `@Scope` 指定作用域名称。

----

#### 详细回答
##### **1. 实现自定义 Scope**
自定义 Scope 需要实现 `org.springframework.beans.factory.config.Scope` 接口，主要方法包括：
- `Object get(String name, ObjectFactory<?> objectFactory)`：返回作用域内的对象，如果没有则创建。
- `Object remove(String name)`：移除作用域内的对象。
- `String getConversationId()`：返回作用域的标识。

----

##### **2. 注册自定义 Scope**
###### 配置方式一：通过 `CustomScopeConfigurer`

使用 `CustomScopeConfigurer` 注册：
```java
@Configuration
public class ScopeConfig {

    @Bean
    public static CustomScopeConfigurer customScopeConfigurer() {
        CustomScopeConfigurer configurer = new CustomScopeConfigurer();
        configurer.addScope("thread-local", new ThreadLocalScope());
        return configurer;
    }
}
```

###### 配置方式二：直接使用 `ConfigurableBeanFactory`
```java
@Configuration
public class ScopeConfig {

    @Bean
    public BeanFactoryPostProcessor scopePostProcessor() {
        return (beanFactory) -> {
            if (beanFactory instanceof ConfigurableBeanFactory) {
                ((ConfigurableBeanFactory) beanFactory).registerScope("thread-local", new ThreadLocalScope());
            }
        };
    }
}
```

##### **3. 使用自定义 Scope**
```java
@Component
@Scope("thread-local")
public class MyThreadLocalBean {
    public void doSomething() {
        System.out.println("Instance: " + this);
    }
}
```
XML 配置方式：
`<bean id="myThreadLocalBean" class="com.example.MyThreadLocalBean" scope="thread-local" />`

----

#### 延申问答
1. **自定义 Scope 的典型应用场景是什么？**
	- **线程作用域：** 每个线程独立的实例（类似 `ThreadLocal`）。
	- **请求作用域：** 模拟 Web 应用中的 HTTP 请求作用域。
	- **会话作用域：** 在非 Web 环境中实现会话级实例管理。
2. **如何支持销毁回调？**
	- 通过 `registerDestructionCallback` 注册销毁逻辑，并在作用域结束时手动调用回调。
3. **与 Spring 内置作用域的区别？**
	- 自定义 Scope 则用于更灵活的场景，如多线程或动态范围。

通过自定义 Scope，Spring 提供了灵活的扩展点来管理 Bean 的生命周期，满足复杂应用的需求。

### Spring框架中的@Qualifier注解的作用是什么？
#### 简洁回答
`@Qualifier` 注解用于在自动装配（`@Autowired`）时指定具体的 Bean：当有多个同类型的 Bean 可供注入时，用于消除歧义，明确指定注入哪个 Bean。
作用：
- 在多 Bean 环境中解决冲突。
- 与 `@Primary` 搭配使用，进一步控制注入逻辑。

### Spring框架中的@Profile注解是如何实现环境隔离的？
#### 知识索引
- **Spring 基础 → 配置管理 → @Profile注解**

----

#### 简洁回答
`@Profile` 注解用于实现环境隔离，通过激活不同的配置文件（如 `dev`、`test`、`prod`），控制哪些 Bean 被加载到 Spring 容器中。它结合 `application.properties` 或编程方式指定当前活跃的环境，实现按需加载。

----

#### 详细回答

##### **1. @Profile 的作用**
`@Profile` 用于指定某些组件或配置类在特定环境下加载。通过设置 `spring.profiles.active` 属性，Spring 会根据激活的环境加载对应的 Bean。

##### **2. 使用方式**
1. 在 Bean 定义中使用
通过 `@Profile` 指定该 Bean 仅在特定环境下加载：
```java
@Configuration
public class AppConfig {

    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new DriverManagerDataSource("jdbc:mysql://localhost:3306/devdb", "dev", "password");
    }

    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        return new DriverManagerDataSource("jdbc:mysql://localhost:3306/proddb", "prod", "password");
    }
}
```
2. 在配置类上使用
标记整个配置类仅在特定环境下生效：
```java
@Profile("test")
@Configuration
public class TestConfig {
    @Bean
    public DataSource testDataSource() {
        return new DriverManagerDataSource("jdbc:h2:mem:testdb", "sa", "");
    }
}
```


##### **3. 激活环境**
1. `application.properties` 或 `application.yml`**
```properties
spring.profiles.active=dev
```

2. 命令行参数
通过启动参数指定环境：
```bash
java -jar app.jar --spring.profiles.active=prod
```

3. 编程方式
在测试或启动代码中通过 `ConfigurableEnvironment` 设置：
```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
    context.getEnvironment().setActiveProfiles("dev");
    context.register(AppConfig.class);
    context.refresh();
}
```

##### **4. 环境隔离的典型场景**
1. **数据库配置：** 在开发、测试、生产环境中使用不同的数据源。
2. **Bean 实例配置：** 根据环境加载不同的实现类，如日志管理（开发用控制台日志，生产用文件日志）。
3. **第三方服务：** 开发时使用 Mock 服务，生产环境使用真实服务。

----

#### 延申问答
1. **`@Profile` 和 `@Conditional` 的区别？**
	- `@Profile` 是基于**环境**的 Bean 加载注解，使用更直观。
	- `@Conditional` 提供更强的条件控制，可结合自定义逻辑控制 Bean 的加载。
2. **如何为默认环境设置 `@Profile`？**
	- 使用 `@Profile("default")`，当未指定激活的 Profile 时加载对应的配置。
3. **多个 Profile 的使用？**
	- 可以同时激活多个 Profile，Spring 会按顺序加载：
		```properties
		spring.profiles.active=dev,test
		```
4. **如何在测试中隔离环境？**
	- 使用 `@ActiveProfiles` 注解指定测试环境：
		```java
		@RunWith(SpringRunner.class)
		@SpringBootTest
		@ActiveProfiles("test")
		public class MyServiceTest {
		}
		```

### Spring框架中的@Async注解是如何实现异步方法的？
#### 知识索引
- **Spring 基础 → 多线程与异步处理 → @Async注解**

----

#### 简洁回答
`@Async` 注解用于将标注的方法声明为异步方法。Spring 会通过代理机制调用这些方法，将其运行在独立的线程中，从而实现异步执行。需要配置 `@EnableAsync` 并提供线程池以支持异步任务的管理。

----

#### 详细回答

##### 使用步骤
1. 启用异步支持
```java
@Configuration
@EnableAsync
public class AsyncConfig {
}
```
2. 定义异步方法
在方法上添加 `@Async` 注解，声明该方法为异步方法：
```java
@Service
public class AsyncService {

    @Async
    public void performAsyncTask() {
        System.out.println("Async Task Start: " + Thread.currentThread().getName());
        try {
            Thread.sleep(2000); // 模拟耗时操作
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Async Task End");
    }
}
```

3. 调用异步方法
通过 Spring 容器管理的 Bean 调用异步方法：
```java
@RestController
public class AsyncController {

    @Autowired
    private AsyncService asyncService;

    @GetMapping("/async")
    public String executeAsync() {
        asyncService.performAsyncTask();
        return "Task Submitted";
    }
}
```

---

##### 配置线程池
Spring 默认使用一个简单的线程池（`SimpleAsyncTaskExecutor`）。为提升性能和控制线程管理，可配置自定义线程池。
```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "customTaskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("CustomExecutor-");
        executor.initialize();
        return executor;
    }
}
```
##### 指定线程池：
```java
@Async("customTaskExecutor")
public void performAsyncTask() {
    System.out.println("Executing with custom executor: " + Thread.currentThread().getName());
}
```

----

##### 特点与限制
1. **基于代理机制：**
	- `@Async` 使用 Spring AOP 代理异步方法，调用方法时，Spring 将其提交给线程池管理。
2. **方法调用限制：**
	- 必须通过 Spring 容器管理的 Bean 调用，直接在同类中调用无法生效。
3. **返回值支持：**
	- 异步方法可以返回 `void` 或 `Future`：
	```java
		@Async
		public CompletableFuture<String> asyncMethod() {
		    return CompletableFuture.completedFuture("Completed");
		}
	```
4. **异常处理：**
	- 异步方法的异常不会直接抛出，可通过 `AsyncUncaughtExceptionHandler` 捕获：
		```java
		@Configuration
		public class AsyncExceptionHandler implements AsyncConfigurer {
		    @Override
		    public void configureAsyncUncaughtExceptionHandler(AsyncUncaughtExceptionHandler handler) {
		        handler = (ex, method, params) -> {
		            System.err.println("Exception in async method: " + method.getName());
		        };
		    }
		}
		```


----

#### 延申问答
1. **如何实现全局异步异常处理？**
	- 通过实现 `AsyncUncaughtExceptionHandler` 接口，集中管理异步任务的未捕获异常。
2. **`@Async` 与自定义线程池的结合方式？**
	- 配置多个线程池，并在 `@Async` 中通过名称指定不同任务使用的线程池。
3. **与 Spring Scheduler 的区别？**
	- `@Async` 是事件驱动的异步处理，通常由方法调用触发。
	- Spring Scheduler 通过 `@Scheduled` 定时触发任务。
4. **如何调试异步任务的执行？**
	- 自定义线程池时设置线程名称前缀，结合日志系统（如 SLF4J）打印线程名称，方便调试。

### Spring框架中的@InitBinder注解的作用是什么？
#### 知识索引
- **Spring MVC → 控制器相关 → @InitBinder注解**

----
#### 简洁回答
`@InitBinder` 注解用于**初始化Web 数据绑定**，允许定制 Web 请求参数的绑定行为。常用于自定义数据格式转换（如日期格式）或其他字段的绑定规则。

----
#### 详细回答
1. **作用：**
	- `@InitBinder` 可以注册自定义的属性编辑器，用于将**请求参数**自动转换为** Java 对象**。例如，转换日期格式或将字符串转换为特定的对象。
2. **用法：**
	```java
	@Controller
	public class MyController {
	    @InitBinder
	    public void initBinder(WebDataBinder binder) {
	        // 注册自定义日期格式编辑器
	        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
	        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
	    }
	    @RequestMapping("/submit")
	    public String submitForm(@RequestParam Date startDate) {
	        // startDate 会自动根据自定义的格式进行绑定
	        return "formSubmitted";
	    }
	}
	```
3. **特点：**
	- `@InitBinder` 可以绑定到类级别的方法或特定的方法上，控制器中的多个方法可以拥有自己的数据绑定初始化器。
	- 通常用于格式化字段或做类型转换，使得 Web 请求中的数据更加灵活。

----

#### 延伸问答
1. **`@InitBinder` 与 `@ModelAttribute` 的区别：**
	- `@InitBinder` 用于配置数据绑定器，处理**请求参数的转换（如格式化、类型转换）**；
	-  `@ModelAttribute` 用于将请求参数**绑定**到方法参数或模型对象中，通常用于**预处理或填充模型数据**。
2. **如何自定义多个字段的格式化？**
	- 使用 `@InitBinder` 可以通过注册多个 `CustomEditor` 或自定义的 `Converter` 来处理不同类型字段的转换和格式化。
3. **如何处理复杂对象的绑定？**
	- 对于复杂对象，可以通过在 `@InitBinder` 方法中注册多个编辑器，或在自定义的 `PropertyEditor` 中实现更复杂的逻辑，如处理嵌套对象或集合的绑定。

### Spring框架中的@RequestParam、@PathVariable、@RequestBody等注解的作用是什么？
#### 知识索引

- **Spring MVC → 控制器相关 → @RequestParam、@PathVariable、@RequestBody 注解**


----
#### 简洁回答

- `@RequestParam` 用于绑定**请求参数**到方法参数。
- `@PathVariable` 用于从**URL 路径**中提取参数。
- `@RequestBody` 用于将**请求体**中的内容绑定到方法参数，通常用于**处理 JSON 或 XML 数据**。


----
#### 详细回答
1. **@RequestParam**
	- 例如，`/search?keyword=java` 中的 `keyword` 会被绑定到方法参数上。
	```java复制代码
	@RequestMapping("/search")
	public String search(@RequestParam String keyword) {
	    // keyword 会自动绑定到请求中的参数
	    return "searchResult";
	}
	```
2. **@PathVariable**
	- 例如，URL 模式 `/user/{id}`，`id` 会绑定到方法参数中。
	```java
	@RequestMapping("/user/{id}")
	public String getUser(@PathVariable("id") Long userId) {
	    // userId 会自动绑定到路径中的 id 变量
	    return "userDetails";
	}
	```
3. **@RequestBody**
	- 用于将 HTTP 请求体中的数据绑定到方法参数，通常用于处理 JSON 或 XML 格式的数据。
	- 在 RESTful 风格的 API 中常用，用于接收客户端传递的对象。
	```java
	@PostMapping("/user")
	public String createUser(@RequestBody User user) {
	    // user 会从请求体中解析并绑定到参数
	    return "userCreated";
	}
	```


----
#### 延伸问答
1. **`@RequestParam` 和 `@PathVariable` 的区别：**
	- `@RequestParam` 绑定的是查询参数或表单数据
	-  `@PathVariable` 绑定的是路径中的变量。
2. **`@RequestBody` 在处理 JSON 数据时的常见用法：**
	- 需要配置 `HttpMessageConverter`，Spring 会自动将请求体中的 JSON 数据转换为 Java 对象，反之亦然。

### Spring框架中的@ResponseBody注解的作用是什么？
#### 知识索引

- **Spring MVC → 控制器相关 → @ResponseBody 注解**


----
#### 简洁回答

`@ResponseBody` 注解用于将控制器方法的**返回值**直接写入 **HTTP 响应体**，而不是解析为视图。通常用于构建 RESTful API，返回 JSON、XML 或其他类型的数据。通常与 `@RequestMapping` 或其他请求映射注解一起使用。


----
#### 详细回答
1. **作用：**
	- 将方法的返回对象转换为指定格式（如 JSON、XML）并直接写入响应体。
	- 在处理 RESTful API 请求时特别常用，可以返回数据而不需要视图解析。
2. **用法：**
	```java
	@RestController
	public class MyController {
	    @RequestMapping("/user")
	    @ResponseBody
	    public User getUser() {
	        User user = new User("John", 30);
	        return user; // 返回的数据会被转换为 JSON 格式并写入响应体
	    }
	}
	```
3. **与 `@RestController` 的关系：**
	- `@RestController` 是 `@Controller` 和 `@ResponseBody` 的组合注解，表示该类中的每个方法都默认以 `@ResponseBody` 方式处理返回值。


----
#### 延伸问答

1. **`@ResponseBody` 与 `@RequestBody` 的区别：**
	- `@RequestBody` 用于将**请求体**中的数据绑定到方法参数
	- `@ResponseBody` 用于将方法的返回值写入**响应体**。
2. **如何设置 `@ResponseBody` 返回 JSON 格式：**
	- Spring 会自动根据方法返回类型和请求头中的 `Accept` 字段来决定返回的数据格式（默认 JSON）。可以使用 `@JsonFormat` 等注解控制返回的 JSON 格式。

### Spring框架中的@Lazy注解的作用是什么？
#### 简洁回答
`@Lazy` 注解用于延迟加载 Bean：只有在第一次访问该 Bean 时，Spring 才会初始化它，而不是在容器启动时立即创建。
有助于在 Bean 的初始化成本较高或并非总是需要的情况下优化启动性能。

----

#### 详细回答
##### 使用方式
1. **类级别：** 在类上使用 `@Lazy`，标记该类的所有 Bean 都采用延迟加载策略。
2. **方法级别：** 在 `@Bean` 方法上使用 `@Lazy`，延迟加载特定的 Bean。
3. **依赖注入中的延迟加载：** 延迟注入某个依赖，通过 `@Lazy` 标注在字段或参数上。
4. **与 `@Configuration` 配合：** 在整个配置类上使用 `@Lazy`，延迟加载配置类内的所有 Bean。

##### 应用场景
1. **性能优化：** 在大型项目中，有些 Bean 初始化较耗时但并非启动时必须加载，比如某些外部服务的连接配置或缓存管理 Bean。
2. **减少启动时间：** 延迟加载的 Bean 可以显著降低应用启动时间，特别是开发和测试环境中。
3. **解决循环依赖：** 对于发生循环依赖的 Bean，可以使用 `@Lazy` 延迟初始化一个 Bean，以打破依赖循环。

----

#### 延伸问答
- [ ] **@Lazy 是否适用于所有 Bean 作用域？**
	- **单例作用域（`singleton`）：** `@Lazy` 通常与单例作用域一起使用，效果最佳。
	- **非单例作用域（如 `prototype`）：** 无需使用 `@Lazy`，因为 `prototype` 本身就按需实例化。
- [ ] **@Lazy 与惰性初始化（Lazy Initialization）的区别？**
	- `@Lazy` 是针对特定 Bean 的延迟加载。
	- 全局惰性初始化可以通过配置文件启用：`spring.main.lazy-initialization=true`
3. **@Lazy 的局限性：**
	- 仅在第一次访问时延迟加载，之后的访问不会延迟。
	- 如果 Bean 是通过反射、拦截器等间接访问，可能会导致未按预期加载。

### 解释Spring框架中的循环依赖问题，并说明Spring是如何解决Bean之间的循环依赖的。
#### 简洁回答
- 循环依赖问题是指多个 Bean 循环引用、相互依赖，导致 Spring 容器无法正常初始化它们。
- Spring 通过 **三级缓存机制** 来解决循环依赖，如果发生循环依赖的话，就去 三级缓存`singletonFactories`中拿到三级缓存中存储的`ObjectFactory`并调用它的`getObject()`方法来获取这个循环依赖对象的**前期暴露对象**（虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了），并且放到二级缓存中，这样在循环依赖时，就不会重复初始化了！

----

#### 详细回答
##### Spring三级缓存机制
1. **一级缓存（singletonObjects）：** 存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。（原型 Bean 不在里面）
2. **二级缓存（earlySingletonObjects）：** 存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中ObjectFactory产生的对象，与三级缓存配合使用，，可以防止 AOP 的情况下，每次调用ObjectFactory.getObject()都是会产生新的代理对象。
3. **三级缓存（singletonFactories）：** 存放ObjectFactory，ObjectFactory的getObject()方法（最终调用的是getEarlyBeanReference()方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。

##### Spring 创建 Bean 的流程
1. 先去 **一级缓存 `singletonObjects`** 中获取，存在就返回；
2. 如果不存在或者对象正在创建中，于是去 **二级缓存 `earlySingletonObjects`** 中获取；
3. 如果还没有获取到，就去 **三级缓存 `singletonFactories`** 中获取，通过执行 `ObjectFacotry` 的 `getObject()` 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。
- **举例：** 
	1. 当 Spring 创建 A 之后，发现 A 依赖了 B ，又去创建 B，B 依赖了 A ，又去创建 A；
	2. 在 B 创建 A 的时候，那么此时 A 就发生了循环依赖，由于 A 此时还没有初始化完成，因此在 一二级缓存 中肯定没有 A；
	3. 那么此时就去三级缓存中调用 getObject() 方法去获取 A 的 前期暴露的对象 ，也就是调用上边加入的 getEarlyBeanReference() 方法，生成一个 A 的 前期暴露对象；
	4. 然后就将这个 ObjectFactory 从三级缓存中移除，并且将前期暴露对象放入到二级缓存中，那么 B 就将这个前期暴露对象注入到依赖，来支持循环依赖。
	5. 完成 `BeanB` 的初始化后，`BeanA` 的初始化继续完成。

##### 只用两级缓存够吗？
在没有 AOP 的情况下，可以只使用一级和三级缓存来解决循环依赖问题。但当涉及到 AOP 时，二级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了“同一个 Bean 有多个代理对象”的问题。

##### 注意事项 
1. 增加了内存开销（需要维护三级缓存，也就是三个 Map），降低了性能（需要进行多次检查和转换）
2. Spring 三级缓存机制仅适用于单例 Bean。对于非单例的 bean 和`@Async`注解的 bean不支持循环依赖，会抛出异常。
3. 如果循环依赖发生在构造器注入时，Spring 无法通过三级缓存解决，因为 Bean 在构造器阶段需要完全实例化。


----

#### 延伸问答
- [ ] **SpringBoot 允许循环依赖发生么？**
	- SpringBoot 2.6 默认允许循环依赖，SpringBoot 2.6以后官方不再推荐。（循环依赖本身就是一种设计缺陷，不应忽视编码的规范和质量。）
	- SpringBoot 2.6以后的循环依赖解决方式：
		1. （暴力）可以通过配置设置允许循环依赖存在：`spring.main.allow-circular-references=true`
		2. （推荐）在导致循环依赖的 Bean 上添加 `@Lazy` 注解标识需要懒加载/延迟加载
- [ ] **构造器注入的循环依赖如何解决？**
	- 使用 `@Lazy` 标识需要懒加载/延迟加载

### Spring框架中的@EnableWebMvc注解的作用是什么？它如何启用Spring MVC的高级特性？
#### 简洁回答
`@EnableWebMvc` 作用：提供Spring MVC的默认配置和高级特性。
- 自动注册注册 MVC 必需的组件（如 `HandlerMapping`、`HandlerAdapter`）
- 提供静态资源处理、全局异常处理、消息转换等功能。

----

#### 详细回答
##### 如何启用高级特性？
1. **消息转换器（Message Converters）：** 自动注册 `HttpMessageConverter`，支持 JSON 和 XML 数据的序列化与反序列化。使用场景：在 RESTful API 中直接返回或接收 JSON 数据。
2. **静态资源映射：** 提供对 `/resources/**` 等静态文件路径的默认映射。使用场景：直接访问 CSS、JS、图片等资源。
3. **全局异常处理：** 提供异常处理机制，可通过 `@ControllerAdvice` 或自定义 `HandlerExceptionResolver` 捕获和处理全局异常。
4. **视图解析：** 配置 `InternalResourceViewResolver`，将逻辑视图名映射为实际的 JSP 文件路径。
5. **自定义拦截器：** 通过实现`WebMvcConfigurer` 接口的`addInterceptors()`方法添加拦截器。

##### 使用注意事项
- 如果使用 `@EnableWebMvc`，Spring 会禁用一些默认的自动配置（例如静态资源处理）。需要通过实现 `WebMvcConfigurer` 接口手动配置相关功能。
- 如果不需要完全控制 MVC 配置，可以直接使用 `spring-boot-starter-web` 提供的自动配置。

----

#### 延伸问答
- [ ] **`@EnableWebMvc` 和 `WebMvcConfigurer` 的关系是什么？**
	- `@EnableWebMvc` 通过启用 `DelegatingWebMvcConfiguration` 实现了 Spring MVC 的配置。
	- `WebMvcConfigurer` 提供了扩展 MVC 配置的钩子方法（如 `addInterceptors` 和 `configureMessageConverters`）。
- [ ] **在 Spring Boot 中是否需要显式使用 `@EnableWebMvc`？**
	通常不需要，Spring Boot 自动配置了 Web MVC 功能。如果需要完全自定义配置，可以结合 `@EnableWebMvc` 和 `WebMvcConfigurer` 实现。
- [ ] **如何自定义消息转换器？**
	在实现 `WebMvcConfigurer` 的 `configureMessageConverters` 方法中添加或修改消息转换器：
	```java
	@Override
	public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
	    converters.add(new MappingJackson2HttpMessageConverter());
	}
	```

### Spring框架中如何配置和使用自定义的WebMvcConfigurer来定制Spring MVC的行为？
#### 简洁回答
将类标记为 `@Configuration` 并实现 `WebMvcConfigurer` 接口中的方法，可以自定义 Spring MVC 的行为。
例如，可以添加拦截器、格式化器、消息转换器或自定义静态资源映射。

----

#### 详细回答
##### 1、创建自定义 `WebMvcConfigurer`
```java
@Configuration
public class MyWebMvcConfigurer implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoggingInterceptor()).addPathPatterns("/**");
    }

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/home").setViewName("home");
    }
}
```
##### 2、常用的 `WebMvcConfigurer` 方法**
###### （1）`addInterceptors` 添加自定义拦截器。
```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
	registry.addInterceptor(new LoggingInterceptor()).addPathPatterns("/**");
}
```

###### （2）`addViewControllers` 配置简单的视图映射，无需控制器逻辑。
```java
@Override
public void addViewControllers(ViewControllerRegistry registry) {
	registry.addViewController("/login").setViewName("loginPage");
}
```
###### （3）`configureMessageConverters` 自定义消息转换器，用于 JSON/XML 的序列化与反序列化。
```java
@Override
public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
	converters.add(new MappingJackson2HttpMessageConverter());
}
```
###### （4）`addResourceHandlers` 配置静态资源的访问路径。
```java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
	registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
}
```
###### （5）`configureViewResolvers` 自定义视图解析器。
```java
@Override
public void configureViewResolvers(ViewResolverRegistry registry) {
	registry.jsp("/WEB-INF/views/", ".jsp");
}
```
###### （6）`configurePathMatch` 定制路径匹配规则，例如忽略 URL 后缀。
```java
@Override
public void configurePathMatch(PathMatchConfigurer configurer) {
	configurer.setUseSuffixPatternMatch(false);
}
```

----

#### 延伸问答
- [x] **`WebMvcConfigurer` 与 `@EnableWebMvc` 的关系是什么？**
	- `@EnableWebMvc` 会启用 Spring MVC 的核心配置
	-  `WebMvcConfigurer` 提供了扩展点，允许开发者在默认配置上添加自定义行为。
- [ ] **如何管理多个 `WebMvcConfigurer`？**
	- Spring 容器会自动识别所有实现了 `WebMvcConfigurer` 的 Bean，并按优先级顺序组合执行，优先级可以通过 `@Order` 注解控制。
- [ ] **与 `WebMvcConfigurationSupport` 的区别？**
	- `WebMvcConfigurer` 是轻量级的扩展机制，基于默认配置。
	- `WebMvcConfigurationSupport` 是完全接管 MVC 配置的高级机制，适合需要完全自定义 MVC 的场景。

## Spring Boot
### 什么是Spring Boot？
#### 定义
Spring Boot 旨在简化 Spring 应用的开发和部署。
#### 核心特点：
1. **自动配置**：基于类路径依赖智能化地配置 Spring 应用，避免手动 XML 配置或 Java 配置。
2. **内嵌服务器**：支持内嵌 Tomcat、Jetty 等，无需外部应用服务器。
3. **简化依赖管理**：通过 Spring Boot Starter 提供一站式依赖管理。
4. **生产级特性**：内置监控、健康检查、日志管理等功能。

### Spring Boot的主要特点是什么？
1. 自动配置
	- 核心注解：`@EnableAutoConfiguration`。
	- 例如：添加 `spring-boot-starter-web`，Spring Boot 会自动配置内嵌的 Tomcat 和 Spring MVC。
2. 内嵌服务器
	- 支持内嵌 Tomcat、Jetty、Undertow，无需单独部署应用服务器。
	- 通过 `java -jar` 即可运行，便于快速开发和部署。
3. 开箱即用的 Starter 组件
	- 提供了一系列 Starter，简化依赖管理。
	- 例如：`spring-boot-starter-data-jpa` 集成了 Hibernate 和 Spring Data JPA。
4. 生产级特性
	- 提供内置的监控、健康检查、性能指标。
	- 集成 `Spring Boot Actuator`，方便开发和运维团队实时监控应用。

### Spring Boot Starter有什么用？
#### 定义
- Spring Boot Starter 是一组**预定义依赖包**，旨在**简化依赖管理**。
- 提供一站式的依赖管理，通过一个单独的 Starter 依赖即可集成某种功能，而无需手动管理繁杂的依赖关系和版本。
#### 特点
1. 约定优于配置，无需手动配置
	- 每个 Starter 都包含一组经过验证的依赖及其版本，无需手动配置。
	- 例如，`spring-boot-starter-web` 自动引入 Spring MVC、Tomcat、Jackson 等依赖。
2. 提供默认配置**避免兼容性问题**
3. 支持扩展和自定义
#### 举例
- `spring-boot-starter-web`：构建 RESTful Web 应用。
- `spring-boot-starter-data-jpa`：集成 JPA 和 Hibernate。
- `spring-boot-starter-test`：集成 JUnit、Mockito 和 Spring Test。
- `spring-boot-starter-security`：集成 Spring Security。

### Spring Boot常用注解？
#### 核心配置相关
1. **`@SpringBootApplication`**
	- 功能：标记为 Spring Boot 应用的入口，集成了 `@Configuration`、`@EnableAutoConfiguration` 和 `@ComponentScan`。
#### RESTful API 开发相关
1. **`@RestController`**
	- 功能：标记类为 REST 控制器，等同于 `@Controller` + `@ResponseBody`。
2. **`@GetMapping` / `@PostMapping` / `@PutMapping` / `@DeleteMapping`**
	- 功能：用于定义 HTTP 请求的映射，对应 GET、POST、PUT、DELETE 方法。
3. **`@RequestParam` / `@PathVariable`**
	- 功能：获取 URL 参数或路径变量。

#### 数据访问相关
1. **`@Entity`**
	- 功能：标记类为 JPA 实体，与数据库表映射。
2. **`@Repository`**
	- 功能：标记类为持久层组件，用于异常转换。
3. **`@Transactional`**
	- 功能：声明事务，确保方法在事务范围内执行。


### 如何在Spring Boot中禁用Actuator端点安全性？
【待补充】
1. 修改配置文件
2. 自定义安全配置
3. 禁用Spring Security（开发环境推荐，生产环境慎用）
#### 修改配置文件
```properties
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always
spring.security.enabled=false
```

#### 自定义安全配置
```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .requestMatchers("/actuator/**").permitAll() // 允许所有用户访问 Actuator 端点
            .anyRequest().authenticated()
            .and().csrf().disable();
        return http.build();
    }
}
```

#### 禁用Spring Security
```properties
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration
```


### 如何在自定义端口上运行Spring Boot应用程序？
1.  在 `application.properties` 文件中，添加或修改 `server.port` 配置项
	```
	server.port=8081
	```
2. 如果使用 `application.yml` 文件
	```
	  port: 8081
	```
3. 可以通过命令行参数来指定端口
	```
	java -jar myapp.jar --server.port=8081
	```

### Spring Boot中的YAML配置与properties配置有什么区别？
#### 语法格式
- **`properties` 配置：** 基于键值对的格式，使用 `=` 或 `:` 分隔键和值。
- **`YAML` 配置：** 基于缩进的层级结构，使用冒号 `:` 分隔键和值，且支持复杂的嵌套结构。

#### 可读性
- **`properties` 配置：** 对于简单的配置项来说，`properties` 格式相对直观，但对于复杂的嵌套配置会显得冗长且难以管理。
- **`YAML` 配置：** 更具层次感，适合处理复杂的配置，配置文件更简洁且易于理解和维护。支持注释和文档化，易于组织和描述配置结构。

####  支持的数据结构
- **`properties` 配置：** 主要用于简单的键值对，支持基本类型的数据，如字符串、数字、布尔值等。
- **`YAML` 配置：** 支持复杂的层级结构，允许列表、字典、嵌套对象等数据类型。

#### 总结
- **简洁性：** YAML 更适合复杂的、多层次的配置，`properties` 更适合简单的配置。
- **可读性：** YAML 由于缩进和层级结构，通常更易于阅读和维护。
- **性能：** `properties` 稍快，但差异在大多数应用场景中并不显著。

### 如何在Spring Boot中实现应用程序的安全性？
【待学习】
在** Spring Boot** 中实现**应用程序安全性**主要依赖 **Spring Security**，具体可以通过以下步骤：
1. **引入依赖：** 添加 `spring-boot-starter-security` 启用默认安全配置（如 HTTP Basic 身份验证）。
	[追问：如何禁用默认安全配置](https://notes.kamacoder.com/question/100604)
3. **自定义安全规则：** 使用 `SecurityFilterChain` 配置 URL 访问权限和认证方式（如角色控制、表单登录）。
4. **密码加密和安全性增强：** 使用 `BCryptPasswordEncoder` 加密用户密码，并结合 HTTPS、JWT 等保护敏感数据。

### Spring Boot中的自动配置是如何工作的？
#### 关键词提示
-  `@EnableAutoConfiguration` `META-INF/spring.factories` 
-   扫描依赖、条件匹配、Bean注册
---
#### 面试版回答
##### 1. 核心机制
通过 `@EnableAutoConfiguration` 注解自动导入 `META-INF/spring.factories` 文件中指定的自动配置类。
##### 2. 工作流程
	1. **扫描依赖：** 根据类路径中的依赖（如 Starter）决定要加载的自动配置类。
	2. **条件匹配：** 通过 `@Conditional` 注解验证是否满足加载条件。
	3. **Bean 注册：** 满足条件的自动配置类会注册相关的 Spring Bean。
##### 3. 自定义与禁用
	- **禁用：** `spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration`
	- **自定义：** `org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.example.MyAutoConfiguration`


### 如何在Spring Boot中集成ActiveMQ？
【待学习】

---

#### 面试者回答
1. 引入依赖
2. 配置ActiveMQ的连接信息
3. 创建消息发送和接收逻辑

---

#### 详细回答
1. **引入依赖：**
	```xml
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-activemq</artifactId>
	</dependency>
	```

2. **配置 ActiveMQ的连接信息**
	```properties
	spring.activemq.broker-url=tcp://localhost:61616
	spring.activemq.user=admin
	spring.activemq.password=admin
	```

3. **创建消息发送和接收逻辑：**
	- **发送消息：**
		```java
		@Service
		public class Producer {
		    @Autowired
		    private JmsTemplate jmsTemplate;
		    public void sendMessage(String destination, String message) {
		        jmsTemplate.convertAndSend(destination, message);
		    }
		}
		```
	- **接收消息：**
		```java
		@Component
		public class Consumer {
		    @JmsListener(destination = "test-queue")
		    public void receiveMessage(String message) {
		        System.out.println("Received: " + message);
		    }
		}
		```

### 什么是Swagger？如何在Spring Boot中集成Swagger？
#### 知识索引
Spring Boot → API 文档工具集成 → Swagger 集成

---

#### 简洁回答
Swagger 是一个用于生成、描述、调用和可视化 RESTful 风格的 Web 服务的工具。
在 Spring Boot 中集成 Swagger，需要添加相关依赖，配置 Swagger 相关信息，然后使用注解来描述 API。

---

#### 详细回答
##### **Swagger 简介**
Swagger 可以帮助开发人员**设计、构建、记录和使用 RESTful Web 服务**。它提供了一种**交互式的文档**方式
	- 让后端开发人员可以**清晰地定义 API** 的接口信息，包括接口路径、请求方法、请求参数、返回值等
	- 方便前端开发人员或其他使用者**理解和测试 API**。
##### **在 Spring Boot 中集成 Swagger 步骤**：
- - **添加依赖**：在项目的 pom.xml 文件中添加 Swagger 相关的依赖，通常是`springfox - swagger2`和`springfox - swagger - ui`。例如：
```xml
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox - swagger2</artifactId>
        <version>2.9.2</version>
    </dependency>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox - swagger - ui</artifactId>
        <version>2.9.2</version>
    </dependency>
```

- **配置 Swagger**：创建一个配置类，用于配置 Swagger 的相关信息。例如：
```java
    @Configuration
    @EnableSwagger2
    public class SwaggerConfig {
        @Bean
        public Docket api() {
            return new Docket(DocumentationType.SWAGGER_2)
                   .select()
                   .apis(RequestHandlerSelectors.basePackage("com.example.demo.controller"))
                   .paths(PathSelectors.any())
                   .build();
        }
    }
```
- 这个配置类中，`@Configuration`注解表示这是一个配置类，`@EnableSwagger2`注解用于启用 Swagger 2。`Docket`对象用于定制 Swagger 的文档信息，在这里通过`apis`方法指定了要扫描的控制器包路径，`paths`方法表示扫描所有的路径。

- **使用注解描述 API**：在控制器类和方法中使用 Swagger 的注解来详细描述 API。例如：
```java
    @RestController
    @RequestMapping("/api")
    public class MyController {
        @ApiOperation("获取用户信息")
        @GetMapping("/user/{id}")
        public User getUser(@ApiParam("用户ID") @PathVariable("id") Long id) {
            // 实现获取用户信息的逻辑
            User user = new User();
            user.setId(id);
            user.setName("John");
            return user;
        }
    }
```
- 其中，`@ApiOperation`注解用于描述方法的功能，`@ApiParam`注解用于描述方法的参数。

---

#### 延申问答
- **问题 1：如何在 Swagger 文档中添加认证信息？**
	- **回答**：可以在 Swagger 配置类中添加安全相关的配置。例如，对于基本认证（Basic Authentication），可以这样配置：
	```java
		@Configuration
		@EnableSwagger2
		public class SwaggerConfig {
			@Bean
			public Docket api() {
				return new Docket(DocumentationType.SWAGGER_2)
					   .select()
					   .apis(RequestHandlerSelectors.basePackage("com.example.demo.controller"))
					   .paths(PathSelectors.any())
					   .build()
					   .securitySchemes(Arrays.asList(basicAuthScheme()))
					   .securityContexts(Arrays.asList(securityContext()));
			}
			private SecurityScheme basicAuthScheme() {
				return new BasicAuth("basicAuth");
			}
			private SecurityContext securityContext() {
				return SecurityContext.builder()
					   .securityReferences(Arrays.asList(basicAuthReference()))
					   .forPaths(PathSelectors.any())
					   .build();
			}
			private SecurityReference basicAuthReference() {
				return new SecurityReference("basicAuth", new AuthorizationScope[0]);
			}
		}
	```
	- 这样在 Swagger UI 中就会出现认证输入框，用户可以输入用户名和密码进行认证。
- **问题 2：如何自定义 Swagger 文档的外观和布局？**
	- **回答**：可以通过修改 Swagger - ui 的 HTML 和 CSS 文件来定制外观和布局。不过这相对复杂一些。更简单的方法是通过一些已有的 Swagger - ui 主题插件或者通过修改 Swagger - ui 的 JavaScript 配置来实现部分定制。例如，可以通过修改`index.html`文件中 Swagger - ui 的初始化参数来改变一些显示效果，如隐藏某些组件或者修改标题等。另外，也可以通过在后端的 Swagger 配置类中进一步定制`Docket`对象的属性来控制文档的内容展示方式，比如可以控制哪些接口显示、如何分组等。

### 如何在Spring Boot中使用FreeMarker模板引擎？
#### 知识索引
Spring Boot → 模板引擎集成 → FreeMarker 集成

---

#### 简洁回答
- 在 pom.xml 添加 FreeMarker 依赖。
- 在 application.properties 配置属性。
- 在控制器返回视图名称来使用。

#### 详细回答
- **添加依赖**：在项目的 pom.xml 文件里加入 FreeMarker 的 starter 依赖：
```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring - boot - starter - freemarker</artifactId>
    </dependency>
```

- **配置属性（可选）**：在 application.properties（或 application.yml）中配置 FreeMarker 的属性。
	- `spring.freemarker.suffix=.ftl`用于指定 FreeMarker 模板文件的后缀，默认是.ftl。
	- `spring.freemarker.charset=UTF - 8`用来设置模板文件的编码。

- **创建模板文件**：在 resources/templates 目录下创建 FreeMarker 模板文件（.ftl 文件）

- **在控制器中使用**：首先创建一个 Spring MVC 控制器类，如下：
```java
    @Controller
    public class HelloController {
        @RequestMapping("/hello")
        public String hello(Model model) {
            model.addAttribute("name", "World");
            return "hello";
        }
    }
```

- 对于这个例子，`/hello`这个请求会进入`hello`方法。`model.addAttribute`方法会把一个名为`name`，值为`World`的属性添加到模型里。最后返回的`hello`就是模板文件的名字（去掉后缀.ftl），Spring Boot 会自动使用 FreeMarker 引擎来渲染这个模板，然后返回给客户端。

#### 延申问答
- **问题 1：如果想在 FreeMarker 模板中使用自定义的函数或者工具类，该怎么做？**
	- **回答**：可以通过在配置类中定义一个`FreeMarkerConfigurer`类型的 Bean，然后使用`getConfiguration().setSharedVariable`方法来添加自定义的函数或者工具类到 FreeMarker 的共享变量中。
- **问题 2：FreeMarker 模板中的数据格式化是如何实现的？**
	- **回答**：FreeMarker 提供了多种内置的格式化指令。例如，`${date?string("yyyy - MM - dd")}`可以将一个日期类型的数据格式化为指定的字符串格式。同时，也可以自定义格式化工具类，通过上述共享变量的方式添加到模板中使用。

### AOP在Spring Boot中的应用是什么？
#### 面试者回答
AOP（Aspect-Oriented Programming，面向切面编程）主要应用于日志记录、性能监控、事务管理等。

---

#### 详细回答
##### 1. 日志记录
```java
@Aspect
@Component
public class LoggingAspect {
	@Before("execution(* com.example.service.*.*(..))")
	public void logBefore(JoinPoint joinPoint) {
		System.out.println("Executing: " + joinPoint.getSignature());
	}
}
```
##### 2. 性能监控
```java
@Around("execution(* com.example.service.*.*(..))")
public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
	long start = System.currentTimeMillis();
	Object result = joinPoint.proceed();
	long executionTime = System.currentTimeMillis() - start;
	System.out.println("Executed in: " + executionTime + "ms");
	return result;
}
```
##### 3. 事务管理
通过 AOP 自动管理方法的事务边界（Spring 已内置支持，`@Transactional` 注解即为 AOP 实现）。

### Spring Boot与Spring框架的区别是什么？
#### 知识索引
Spring Boot → 与 Spring 框架对比 → 基本概念对比

---

#### 简洁回答
Spring Boot 是对 Spring 框架的进一步封装，简化配置，快速构建。

---

#### 详细回答
- **Spring ** ：配置复杂、大量使用 XML 配置文件来定义 Bean、依赖关系、事务管理等诸多内容。
- **Spring Boot**：采用**约定优于配置**的原则，简化配置。

---

#### 延申问答
- **问题 1：Spring Boot 在简化 Spring 框架配置的同时，会不会失去灵活性？**
	- **回答**：不会。Spring Boot 虽然有很多默认的自动配置，但开发者可以通过自定义配置来覆盖这些默认配置。例如，在自动配置的数据源不符合要求时，可以在`application.properties`中指定自己的数据源相关配置，或者通过创建一个自定义的`DataSource`类型的 Bean 来完全替换自动配置的数据源。
- **问题 2：如果已经有一个基于 Spring 框架的大型项目，能否逐步引入 Spring Boot？**
	- **回答**：可以。可以在项目的部分模块中先尝试使用 Spring Boot 的相关特性。例如，在一个新的微服务模块中使用 Spring Boot 来构建，利用它的自动配置和快速启动的优势。同时，对于与原有 Spring 框架模块的交互，可以通过合适的接口或者服务调用方式来实现整合。

### 如何在Spring Boot中读取配置文件的信息？
#### 知识索引
Spring Boot → 配置管理 → 读取配置文件信息

---

#### 简洁回答
- @Value 注解注入单个属性
- 使用 @ConfigurationProperties 注解将配置文件中的一组属性绑定到一个 Java 对象上。

---

#### 详细回答
- **使用 @Value 注解**：- 首先，在 application.properties（或 application.yml）中定义属性，例如：`myapp.name=My Application`。
	- 然后，在需要使用该属性的类中，通过 @Value 注解来注入属性。例如：
```java
    @Component
    public class MyComponent {
        @Value("${myapp.name}")
        private String applicationName;
        // 可以在类的其他方法中使用applicationName这个变量
    }
```

- 这种方式适用于读取单个属性，比较简单直接。但是如果要读取多个相关属性，代码会比较分散。
- **使用 @ConfigurationProperties 注解**：- 假设在 application.yml 中有如下配置：
```yaml
    myapp:
      name: My Application
      version: 1.0
      settings:
        timeout: 5000
        maxConnections: 100
```

- 可以创建一个 Java 类来绑定这些属性，例如：
```java
    @Component
    @ConfigurationProperties(prefix = "myapp")
    public class MyAppProperties {
        private String name;
        private String version;
        private Settings settings;
        // 对应的getter和setter方法
        public static class Settings {
            private int timeout;
            private int maxConnections;
            // 对应的getter和setter方法
        }
    }
```
- 这样，Spring Boot 会自动将配置文件中`myapp`前缀下的属性绑定到`MyAppProperties`类的相应属性上。在其他类中，可以通过注入`MyAppProperties`对象来使用这些属性。

---

#### 延伸问答
- **问题 1：如果配置文件中的属性名和 Java 类中的属性名不一致，如何处理？**
	- **回答**：当使用 @ConfigurationProperties 注解时，可以在注解中使用`ignoreUnknownFields = false`来禁止绑定不存在的属性，并且可以通过在 Java 类的属性上添加`@JsonProperty`（如果是 JSON 格式的配置文件，如 application.yml）或者其他自定义的转换注解来指定属性名的映射关系。
- **问题 2：如何读取不同环境下的配置文件（如开发环境、生产环境）？**
	- **回答**：Spring Boot 支持多环境配置。可以通过在配置文件命名上遵循一定的规则，如`application - dev.properties`（开发环境）、`application - prod.properties`（生产环境）等。然后在启动应用时，可以通过`--spring.profiles.active=dev`（激活开发环境配置）这样的命令行参数或者在 IDE 中设置环境变量来指定使用哪个环境的配置文件。同时，也可以在配置文件中使用`spring.profiles`属性来指定某个配置块所属的环境，例如：


收起

yaml

```
    spring:
      profiles: dev
      myapp:
        name: Dev Application
```

这个配置块只有在开发环境下才会被加载。

# 前端开发
## Vue
### MVVM模式和MVC模式有什么区别？
#### 简洁回答
##### 主要区别
|**特性**|**MVC**|**MVVM**|
|:-:|:-:|:-:|
|**核心组件**|Model, View, Controller|Model, View, ViewModel|
|**交互方式**|View 和 Model 直接交互，由 Controller 调节|View 和 Model 不直接交互，依赖 ViewModel|
|**数据绑定**|手动通知 View 更新|双向绑定自动更新|
|**适用场景**|后端 Web 框架（Spring MVC）|前端框架（Angular、Vue、React 等）|

----

#### 详细回答
##### MVC 模式
- **组成：**
	- **Model（模型）：** 处理业务逻辑和数据，负责状态管理。
	- **View（视图）：** 展示数据给用户，负责用户界面。
	- **Controller（控制器）：** 接收用户输入，协调 Model 和 View 的交互。
- **特点：**
	- 控制器集中处理输入，视图直接依赖于模型。
	- 更新数据需要手动通知视图刷新，数据和视图耦合较高。
	- 适合后端系统，如传统 Web 应用（Spring MVC）。
- **示例：**
	用户点击按钮后，Controller 接收请求，调用 Model 更新数据，并将新数据传递给 View。

##### MVVM 模式
- **组成：**
	- **Model（模型）：** 数据和业务逻辑层，与 MVC 模式相同。
	- **View（视图）：** 展示数据给用户，用户操作通过绑定传递给 ViewModel。
	- **ViewModel（视图模型）：** 中介层，负责数据与视图的双向绑定。
- **特点：**
	- View 和 Model 之间没有直接联系，依赖于 ViewModel 作为桥梁。
	- 通过双向绑定（Data Binding），数据和界面实时同步，降低开发复杂度。
	- 适合前端框架（如 Angular、React+Redux、Vue）。
- **示例：**
	用户修改界面内容，ViewModel 通过双向绑定自动更新 Model，反之亦然。

----

#### 延伸问答
- [x] **为什么 MVVM 更适合前端框架？**
	- 前端应用需要频繁更新视图状态，而 MVVM 的双向绑定特性可以自动同步数据与界面，减少开发者手动更新的负担。

# 代码随想录
## 哈希表
### 《代码随想录》哈希表：哈希表理论基础
#### 基本概念
- 哈希表基于哈希函数通过 **键值对（key-value）** 存储数据。
- 哈希函数将任意大小的数据**映射**为固定大小的整数，通过哈希值可以快速**定位**存储位置。
- **目标**：提供快速的**增、删、查**操作，平均时间复杂度为 O(1)
- 负载因子 = 元素个数 / 数组长度
	- 负载因子越高，冲突越多，性能越差。
	- 合适的负载因子（如 α ≤ 0.75）能在性能和空间之间取得平衡。
	- 动态扩容：负载因子超过一定阈值，哈希表会扩容并重新分配已有元素到新的位置（ rehashing）。

---

#### 哈希冲突
哈希冲突：由于数组的大小有限，**不同的键**可能映射到**同一索引值**。
解决方法：
##### 1. 链地址法：链表存储
**缺点**：
	- 额外指针增加了空间消耗。
	- 链表长度过长时，查找性能可能退化为 O(n)。
##### 2. 开放寻址法：查找下一个可用位置
1. **线性探测**：按固定步长（通常为 1）依次查找。
2. **二次探测**：步长为二次方，避免聚集效应。
3. **双重哈希**：用第二个哈希函数决定步长。
- **缺点**：插入和查找效率在负载因子较高时下降。
#####  3. 再哈希法：冲突时重新计算哈希值，直到找到空位。
#####  4. 扩展数组：动态增加数组大小，重新分配元素（常见于 `HashMap` 等实现）

---

#### 哈希表的优缺点
- **空间换时间**：增删查的平均时间复杂度为 O(1)。
- **无法顺序存储**：哈希表中的元素通常是无序的。

---
#### 红黑树
#### 二叉搜索树（BST）
- 可以O（logn）的效率进行增删查
- 但当数据有序时，二叉搜索树的构建会变成链表状态且效率退化为O（n）
##### 二叉搜索树之 平衡二叉树（AVL）
- 通过旋转操作让树保持平衡
- 任一结点左右子树高度相差不超过1。（相比红黑树，对平衡的要求更加严格）
- 相比红黑树**查询更高效**。
##### 二叉搜索树之 红黑树
- 左根右，根叶黑，不红红，黑路同。
- 任一结点左右子树高度相差不超过两倍。
- 相比平衡二叉树**增删更高效**。
- 应用更广泛，如C++的STL的map和set。


## 二叉树
### 《代码随想录》二叉树：二叉树的层序遍历
#### Java知识
##### Java中queue.offer(null)时，size会++吗？
- 如果不做`if(root == null)    return res;`判断，那么`queue.offer(root);`不会报错且`queue.size()`正常增加。
- 但是后续`level.add(node.val);`会报错，所以尽量保持queue中不要有null。
##### Java中的Queue有哪些具体实现
- **`LinkedList`**：基于链表的常规队列实现，适合一般用途。
- **`PriorityQueue`**：优先级队列，按照优先级顺序处理元素。
- **`ArrayDeque`**：基于动态数组的高效队列实现，适用于需要高效队列操作的场景。
- **`ConcurrentLinkedQueue`**：线程安全的队列实现，适用于并发场景。
- **`BlockingQueue`**：用于线程间协调的阻塞队列，适用于多线程编程。
- **`Deque`**：双端队列，支持从两端进行插入和删除操作。

### 《代码随想录》二叉树：将有序数组转换为二叉搜索树
#### 分治
```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return help(nums, 0, nums.length-1);
    }

    public TreeNode help(int[] nums, int left, int right) {
        if (left > right)   return null;
        int mid = left + (right-left)/2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = help(nums, left, mid-1);
        node.right = help(nums, mid+1, right);
        return node;
    }
}
```

