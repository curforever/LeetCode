# 计算机基础
## 计算机网络
### [TCP/IP模型和OSI模型分别是什么？它们之间有什么区别？](https://notes.kamacoder.com/questions/500000)
#### 简要回答

- **TCP/IP模型**：是一种四层的网络通信协议模型，分别是：应用层、传输层、互联网层和网络接口层。
- **OSI模型**：是一个七层的标准化网络通信模型，包含应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。
- **区别**：TCP/IP模型较为简化，OSI模型较为详细。TCP/IP模型更贴近实际应用，而OSI模型更侧重理论。
### [从输入URL到页面展示发生了什么？](https://notes.kamacoder.com/questions/500001)
#### 简要回答

1. **输入URL**：用户在浏览器中输入URL，浏览器解析并开始发起请求。
2. **DNS解析**：浏览器解析URL中的域名，通过DNS查询获取目标服务器的IP地址。
3. **建立TCP连接**：通过IP地址与目标服务器建立TCP连接（三次握手）。
4. **发送HTTP请求**：浏览器通过TCP连接向服务器发送HTTP请求。
5. **服务器响应**：服务器处理请求并返回HTTP响应（包含HTML、CSS、JavaScript等资源）。
6. **渲染页面**：浏览器解析并渲染页面，展示给用户。

----

#### 详细回答

##### 1. 输入URL

- 用户在浏览器中输入URL（如`https://www.example.com`），浏览器开始解析该URL。

##### 2. DNS解析

- 浏览器会先查找本地DNS缓存，如果没有缓存则向配置的DNS服务器发起请求，解析出目标服务器的IP地址。

##### 3. 建立TCP连接

- 浏览器通过DNS解析得到IP后，发起TCP连接（三次握手）：- **客户端发起SYN请求**；
	- **服务器返回SYN+ACK响应**；
	- **客户端发送ACK确认**，建立连接。

##### 4. 发送HTTP请求

- 建立TCP连接后，浏览器会发送HTTP请求（如GET、POST），请求内容包含请求头、Cookies、请求参数等。

##### 5. 服务器响应

- 服务器接收到HTTP请求后，进行相应的处理，并返回HTTP响应。响应通常包含HTML文件、CSS样式表、JavaScript文件以及图片等资源。

##### 6. 渲染页面

- 浏览器收到服务器响应后开始渲染页面：- **HTML解析**：解析HTML标签，构建DOM树。
	- **CSS解析**：解析CSS样式，构建CSS规则树。
	- **JavaScript执行**：执行JavaScript脚本，可能会操作DOM、发起异步请求等。
	- **绘制页面**：浏览器将DOM和CSS结合，绘制页面，最终展示给用户。


- - 用户。


----

#### 延伸问答

##### 1. **DNS解析缓存**

- 浏览器会缓存DNS解析结果，避免频繁查询DNS服务器，从而提高请求速度。

##### 2. **HTTP/2和TCP连接**

- 在HTTP/1.x中，每个请求都需要建立新的TCP连接，而HTTP/2可以复用连接，减少了延迟。

##### 3. **页面渲染优化**

- 为了提高页面加载速度，开发者可以使用如懒加载、异步加载JavaScript、压缩文件等技术。

##### 4. **前端框架渲染**

- 现代单页应用（SPA）通常依赖前端框架（如React、Vue、Angular等）进行页面渲染，减少了页面的重新加载。
### [HTTP请求报文和响应报文是怎样的？](https://notes.kamacoder.com/questions/500002)
#### 简要回答
1. **HTTP请求报文**：
	- 请求行：包含请求方法（GET、POST等）、URL、HTTP版本。
	- 请求头：包含客户端信息、请求内容类型、语言、Cookie等。
	- 请求体：仅在某些请求方法（如POST）中包含，包含实际的数据内容。
2. **HTTP响应报文**：
	- 状态行：包含HTTP版本、状态码（如200、404等）、状态描述。
	- 响应头：包含服务器信息、缓存策略、内容类型等。
	- 响应体：包含返回的实际数据（如HTML页面、JSON等）。
### [HTTP请求方式有哪些？](https://notes.kamacoder.com/questions/500003)
#### 知识索引

- HTTP请求方法
- HTTP常见请求方式
- HTTP安全性


----
#### 简要回答

常见的HTTP请求方法有：
1. **GET**：请求指定资源，获取数据，不包含请求体。
2. **POST**：向指定资源提交数据，通常用来提交表单数据。
3. **PUT**：更新指定资源的全部内容。
4. **DELETE**：删除指定资源。
5. **PATCH**：部分更新指定资源。
6. **HEAD**：与GET类似，但不返回消息体，仅返回头部信息。
7. **OPTIONS**：询问服务器支持哪些HTTP方法。
8. **TRACE**：回显服务器接收到的请求，常用于调试。

---

#### 延伸问答

1. **哪些请求方法是幂等的？**
	- **GET**、**PUT**、**DELETE**是幂等的，意味着多次执行这些操作将返回相同的结果。
2. **POST和PUT的区别是什么？**
	- **POST**用于**创建**资源，通常不幂等，执行多次可能会创建多个相同资源；
	- **PUT**用于**更新**资源，通常幂等，执行多次会得到相同的资源。
3. **为什么使用PATCH？**
	- 如果只需要更新部分字段而不是整个资源，可以使用PATCH。这样更加高效，减少了不必要的数据传输。
### [GET请求和POST请求的区别是什么？](https://notes.kamacoder.com/questions/500004)
#### 简要回答

1. **数据传输位置**：
	- **GET**：数据通过**URL**传递（查询字符串）。
	- **POST**：数据通过**请求体**传递。
2. **用途**：
	- **GET**：用于获取资源，不应改变服务器状态。
	- **POST**：用于提交数据，创建或修改资源。
3. **安全性与幂等性**：
	- **GET**：安全且幂等，意味着多次请求不会改变服务器状态。
	- **POST**：**非幂等**，请求可能会改变服务器状态。
4. **请求长度**：
	- **GET**：限制数据长度，**受URL长度限制**。
	- **POST**：没有数据长度限制，可以传输大量数据。
### [HTTP请求中常见的状态码有哪些？它们分别代表什么含义？](https://notes.kamacoder.com/questions/500005)
#### 简要回答

1. **2xx - 成功系列**：
	- **200 OK**：请求成功，服务器返回所请求的数据。
	- **201 Created**：请求成功并创建了新的资源。
	- **204 No Content**：请求成功，但没有返回内容。
2. **3xx - 重定向系列**：
	- **301 Moved Permanently**：资源已永久移动，客户端应使用新URL。
	- **302 Found**：资源临时移动，客户端应继续使用原URL。
	- **304 Not Modified**：资源未修改，客户端可以使用缓存。
3. **4xx - 客户端错误系列**：
	- **400 Bad Request**：请求格式错误，服务器无法理解。
	- **401 Unauthorized**：需要身份验证，或认证失败。
	- **403 Forbidden**：服务器拒绝请求，权限不足。
	- **404 Not Found**：请求的资源不存在。
4. **5xx - 服务器错误系列**：
	- **500 Internal Server Error**：服务器发生内部错误，无法完成请求。
	- **502 Bad Gateway**：网关或代理服务器接收到无效响应。
	- **503 Service Unavailable**：服务器暂时无法处理请求，可能是过载或维护。
### [什么是强缓存和协商缓存？它们的工作原理是什么？](https://notes.kamacoder.com/questions/500006)
#### 简要回答

1. **强缓存**：
	- **作用**：直接使用缓存中的内容，无需向服务器发送请求。
	- **工作原理**：通过`Cache-Control`或`Expires`头部来指定缓存有效期。如果缓存未过期，浏览器直接使用缓存。
2. **协商缓存**：
	- **作用**：缓存失效时，向服务器确认资源是否更新，更新则返回最新资源。
	- **工作原理**：通过`Last-Modified`和`If-Modified-Since`、`ETag`和`If-None-Match`进行协商。如果资源未修改，返回`304 Not Modified`，否则返回最新资源。

----

#### 延申问答

1. **如何选择使用强缓存或协商缓存？**
	- 强缓存适合**静态资源（如图片、JS、CSS等）**，当**资源较少变化时，可以设置较长的有效期**。
	- 协商缓存适合需要**频繁更新**的资源或动态内容，能够保证**缓存的有效性**。
2. **什么情况下会同时使用强缓存和协商缓存？**
	- 可以结合`Cache-Control`（设置强缓存）和`Last-Modified`/`ETag`（设置协商缓存）来实现更智能的缓存控制。
### [HTTP1.0和HTTP1.1的区别是什么？](https://notes.kamacoder.com/questions/500007)
#### 简要回答

1. **持久连接**：
	- HTTP1.0：每个请求/响应都会打开一个新的连接。
	- HTTP1.1：默认支持**持久连接**，复用同一个连接进行多个请求/响应。
2. **管道化**：
	- HTTP1.0：不支持管道化。
	- HTTP1.1：**支持管道化**，可以在同一个连接上并行发送多个请求。
3. **缓存控制**：
	- HTTP1.0：没有强制要求使用缓存控制。
	- HTTP1.1：新增了`Cache-Control`头，提供**更精细的缓存管理**。
4. **Host头部**：
	- HTTP1.0：没有`Host`头部，无法区分虚拟主机。
	- HTTP1.1：引入`Host`头部，支持**虚拟主机（多个域名共享同一IP）**。
5. **错误代码**：
	- HTTP1.0：错误码较少，错误处理不够完善。
	- HTTP1.1：引入了**更多的错误码**，如`409 Conflict`、`410 Gone`等，增强了错误处理能力。
### [HTTP2.0与HTTP1.1相比有哪些主要改进？](https://notes.kamacoder.com/questions/500008)
#### 简要回答

1. **多路复用**：
	- HTTP2.0：**支持多路复用**，多个请求和响应可以在一个连接上并行传输。
	- HTTP1.1：每个请求需要建立独立连接，或使用管道化，但仍然受限于串行传输。
2. **头部压缩**：
	- HTTP2.0：通过HPACK算法**对请求和响应头部进行压缩**，**减少带宽占用**。
	- HTTP1.1：头部信息没有压缩，传输效率较低。
3. **流量控制**：
	- HTTP2.0：提供了**流量控制**机制，可以对数据流进行细粒度控制。
	- HTTP1.1：没有内建的流量控制机制，主要依赖TCP层的拥塞控制。
4. **服务器推送**：
	- HTTP2.0：**支持服务器推送，服务器可以主动推送资源到客户端**，提高页面加载速度。
	- HTTP1.1：仅支持客户端请求，服务器无法主动推送数据。
5. **二进制协议**：
	- HTTP2.0：协议采用**二进制格式，解析效率更高**。
	- HTTP1.1：协议采用**文本**格式，解析效率较低。
### [HTTP3.0有了解过吗？它与之前的版本有哪些主要不同？](https://notes.kamacoder.com/questions/500009)
#### 简要回答

1. **传输协议**：
	- **HTTP3.0**：基于**QUIC协议**，使用UDP而不是TCP作为传输层协议。
	- **HTTP1.x和HTTP2**：基于**TCP**，传输过程中的连接管理和拥塞控制通过TCP实现。
2. **连接建立**：
	- **HTTP3.0**：QUIC**支持零RTT连接建立，减少了握手的延迟**。
	- **HTTP1.x和HTTP2**：建立连接需要3次握手（TCP）才能开始通信。
3. **多路复用**：
	- **HTTP3.0**：通过QUIC的流控制机制，**实现真正的多路复用**，可以更有效地避免头部阻塞。
	- **HTTP2**：虽然支持多路复用，但依赖于TCP，仍然受到TCP队头阻塞的影响。
4. **加密**：
	- **HTTP3.0**：QUIC内建**TLS加密**，所有数据都在传输前进行加密。
	- **HTTP2**：通过TLS加密，但并非内建，协议本身未要求加密。
5. **头部压缩**：
	- **HTTP3.0**：**继续使用HPACK（和HTTP2相同）来压缩头部数据**，减少带宽消耗。
	- **HTTP1.1**：无头部压缩，增加了数据的传输量。
### [HTTPS和HTTP有哪些区别？](https://notes.kamacoder.com/questions/500010)
#### 简要回答

1. **协议类型**：
	- **HTTP**：超文本传输协议，不加密，传输的数据是明文。
	- **HTTPS**：**安全**的HTTP协议，通过**SSL/TLS协议**加密传输数据，保证通信的安全性。
2. **端口号**：
	- **HTTP**：默认端口是**80**。
	- **HTTPS**：默认端口是**443**。
3. **加密方式**：
	- **HTTP**：数据传输过程是**明文**的，容易被中间人攻击或窃听。
	- **HTTPS**：使用**SSL/TLS协议**对传输的数据进行加密，确保数据在传输过程中不被篡改和窃取。
4. **性能**：
	- **HTTP**：传输过程简单，不涉及加密解密，因此速度较快。
	- **HTTPS**：由于加密和解密过程，性能略逊色，但现代硬件和协议优化已显著减少影响。
5. **安全性**：
	- **HTTP**：不提供任何安全性保障，容易受到中间人攻击（MITM）。
	- **HTTPS**：提供了**数据加密、身份认证和完整性保护**，防止数据在传输过程中被篡改或窃取。
### [HTTPS工作原理是什么？它是如何实现数据加密的？](https://notes.kamacoder.com/questions/500011)
#### 简要回答

1. **SSL/TLS协议**：HTTPS依赖于SSL（Secure Socket Layer）或TLS（Transport Layer Security）协议来实现数据加密和身份认证。
2. **加密过程**：
	- **对称加密**：用于加密传输数据，效率较高，但需要共享密钥。
	- **非对称加密**：用于密钥交换，保证数据传输过程中的安全性。
	- **数字证书**：保证通信双方身份的真实性。
3. **握手过程**：
	- 客户端与服务器进行SSL/TLS握手，协商加密算法和密钥。
	- 客户端验证服务器证书，确保服务器身份。
	- 使用公钥加密传输密钥，双方使用对称加密进行通信。
4. **数据传输**：加密后的数据通过安全的通信信道传输，确保数据在传输过程中不被窃取或篡改。
### [TCP和UDP的区别是什么？](https://notes.kamacoder.com/questions/500012)
##### TCP和UDP的主要区别：

- **连接方式**：
	- **TCP**：面向连接，通信前需要建立连接（三次握手）。
	- **UDP**：无连接，不需要建立连接，直接发送数据。
- **可靠性**：
	- **TCP**：可靠传输，确保数据包按顺序无误送达，支持重传和校验。
	- **UDP**：不保证可靠性，可能丢包，数据顺序不固定。
- **流量控制与拥塞控制**：
	- **TCP**：有**流量控制、拥塞控制**，保证数据的有序流入。
	- **UDP**：无流量控制和拥塞控制，数据流速较快，但可能丢包。
- **速度与开销**：
	- **TCP**：较慢，由于要建立连接、确保可靠性及顺序。
	- **UDP**：较快，因为没有建立连接和可靠性机制。
- **应用场景**：
	- **TCP**：需要可靠传输的场景，如文件传输、网页浏览、电子邮件等。
	- **UDP**：实时性要求高，容忍丢包的场景，如视频流、VoIP、在线游戏等。
### [TCP连接如何确保可靠性？](https://notes.kamacoder.com/questions/500013)
- **数据确认**：接收方通过ACK确认每个数据包的接收。
- **重传机制**：如果发送方没有收到确认，则会重新发送数据。
- **序列号**：每个数据包都有唯一的序列号，确保接收方可以按正确顺序重组数据。
- **校验和**：确保数据在传输过程中没有发生错误。
- **流量控制**：防止发送方发送数据过快，接收方无法处理。
- **拥塞控制**：避免网络拥塞，调整发送数据的速度。
### [UDP怎么实现可靠传输？](https://notes.kamacoder.com/questions/500014)
##### UDP本身不提供可靠传输，但可以通过应用层实现：

- **重传机制**：发送方未收到确认时重传数据。
- **数据确认**：接收方返回确认消息（ACK）。
- **序列号**：确保数据的顺序。
- **校验和**：确保数据的完整性。
- **流量控制和拥塞控制**：根据应用层协议进行实现。
### [TCP流量控制是怎么实现的？](https://notes.kamacoder.com/questions/500015)
#### 简要回答

##### TCP流量控制通过**滑动窗口机制**实现，确保发送方不会超出接收方的处理能力。其基本原理包括：

- **接收窗口**：接收方通知发送方它当前可以接收的字节数。
- **滑动窗口**：随着数据的接收和处理，接收方的窗口会滑动，允许发送更多的数据。

---

#### 详细回答

##### 1. **接收窗口（Receiver Window）**：

- TCP使用**接收窗口**来告诉发送方接收方当前能接收多少字节的数据。接收方根据自己的缓冲区大小，定期更新接收窗口的大小，并通过窗口大小来告知发送方。
- 窗口大小的值通过TCP头部的**窗口字段**进行传输。

##### 2. **滑动窗口机制**：

- **滑动窗口**是TCP流量控制的核心。窗口的大小是动态变化的，发送方可以根据接收方提供的窗口大小发送数据，发送的数据量不能超过接收方的接收能力。
- 随着数据的接收和处理，接收方会逐步释放缓冲区空间，接收窗口也会相应增大，允许发送方继续发送数据。

##### 3. **避免数据过载**：

- TCP流量控制防止了发送方发送过多数据，以至于接收方的缓冲区溢出。通过适当控制窗口大小，保证接收方可以处理所有数据而不会丢失。

##### 4. **与拥塞控制的结合**：

- TCP流量控制和拥塞控制虽然不同，但常常一起工作。流量控制主要是确保接收方不会被压垮，而拥塞控制则是确保网络不会因过多的数据传输而发生拥堵。
### [能说说拥塞控制是怎么实现的嘛？](https://notes.kamacoder.com/questions/500016)
#### 简要回答

##### TCP拥塞控制是通过四种主要机制实现的：
- **慢启动（Slow Start）**
- **拥塞避免（Congestion Avoidance）**
- **快速重传（Fast Retransmit）**
- **快速恢复（Fast Recovery）**

---

#### 详细回答

##### 1. **慢启动（Slow Start）**：
- 初始阶段，TCP连接的拥塞窗口大小设置为1个最大报文段（MSS，Maximum Segment Size）。
- 每当收到一个确认报文（ACK），窗口大小就加倍，窗口增长速度是指数级的。
- 当窗口大小达到一个阈值（**ssthresh**），进入拥塞避免阶段。

##### 2. **拥塞避免（Congestion Avoidance）**：
- 在慢启动阶段增长速度过快，可能导致网络拥塞，因此慢启动达到阈值后会切换到拥塞避免阶段。
- 拥塞避免阶段采用加法增长的方式，每收到一个确认报文，窗口大小增加1个MSS，而不是加倍。
- 增长速度较慢，目的是避免网络拥塞。

##### 3. **快速重传（Fast Retransmit）**：
- 当发送方连续收到3个重复的ACK时，说明某个数据包丢失。
- 在不等待超时的情况下，TCP会立即重传丢失的包。
- 这个机制减少了因丢包引起的等待时间，提高了传输效率。

##### 4. **快速恢复（Fast Recovery）**：
- 快速恢复与快速重传配合工作。重传数据包后，TCP将拥塞窗口缩小为ssthresh的一半，并恢复为拥塞避免阶段，而不是重新进入慢启动阶段。
- 这样可以避免在发生丢包时过度减少窗口，进而导致网络利用率下降。

##### 5. **TCP拥塞控制的四个阶段的过程**：
- **初始化**：初始阶段，拥塞窗口为1。
- **慢启动阶段**：拥塞窗口指数增长。
- **拥塞避免阶段**：当窗口达到ssthresh后，采用加法增长。
- **丢包处理**：发生丢包时，使用快速重传和快速恢复来尽快恢复传输。

##### 6. **与流量控制的关系**：
- **流量控制**关注接收方的能力，而**拥塞控制**则关注网络中间节点的能力。
- 两者共同作用，确保TCP连接在不丢包、不过载的情况下高效运行。
### [三次握手的过程是怎样的？为什么是三次而不是两次或四次？](https://notes.kamacoder.com/questions/500017)
#### 简要回答

##### 1. **第一次握手**：
- **客户端 → 服务器**：客户端向服务器发送SYN（同步序列编号）请求包，客户端进入SYN_SEND状态。
- 该包的作用是：客户端告知服务器，客户端希望建立连接，并且客户端的初始序列号（ISN）为X。

##### 2. **第二次握手**：
- **服务器 → 客户端**：服务器收到SYN包后，确认客户端的请求，并向客户端发送SYN+ACK包，服务器进入SYN_RECV状态。
- 该包的作用是：服务器确认接收到客户端的SYN包，并告知客户端，服务器的初始序列号为Y，且也准备好接收连接。

##### 3. **第三次握手**：
- **客户端 → 服务器**：客户端收到服务器的SYN+ACK包后，发送ACK包给服务器，进入ESTABLISHED状态，连接成功。
- 该包的作用是：客户端确认服务器已接收客户端的SYN包，且确认服务器的序列号Y。

##### 为什么是三次握手而不是两次或四次？

1. **为什么不能只用两次握手？**
	- 如果只有两次握手，客户端发送SYN之后，服务器就直接响应ACK，客户端无法确认自己是否接收到服务器的SYN+ACK包，也无法确认服务器是否准备好接收数据。因此，三次握手是必须的，确保双方都能确认连接的建立。
2. **为什么不能用四次握手？**
	- 三次握手已经能有效地建立可靠的连接。多余的握手会增加延迟和资源消耗，影响连接的效率。所以，三次握手足够完成连接的建立。
### [四次挥手的过程是怎样的？为什么是四次而不是三次或五次？](https://notes.kamacoder.com/questions/500018)
#### 简要回答

##### 1. **第一次挥手**：
- **客户端 → 服务器**：客户端发送FIN（结束）报文段，告诉服务器它已经没有数据要发送了，进入`FIN_WAIT_1`状态。
- 客户端等待服务器确认，这个过程中客户端的数据发送完毕，但接收仍然是开放的。

##### 2. **第二次挥手**：
- **服务器 → 客户端**：服务器收到客户端的FIN包，发送一个ACK包确认，进入`CLOSE_WAIT`状态。
- 该ACK确认客户端的结束请求，但服务器仍然保持连接，可以继续接收数据。

##### 3. **第三次挥手**：
- **服务器 → 客户端**：当服务器也准备好关闭连接时，发送一个FIN包给客户端，表示服务器数据也已发送完毕，进入`LAST_ACK`状态。
- 服务器通知客户端关闭连接。

##### 4. **第四次挥手**：
- **客户端 → 服务器**：客户端收到服务器的FIN包后，发送一个ACK包给服务器，进入`TIME_WAIT`状态，等待足够的时间确保服务器收到了确认的ACK包后，连接彻底关闭。

##### 为什么是四次挥手而不是三次或五次？

1. **为什么不能是三次挥手？**
	- 在TCP连接关闭时，**客户端和服务器**是双向的。客户端和服务器都需要确认各自的数据已经发送完毕。因此，第一次挥手是客户端告诉服务器它没有数据要发送了；第二次是服务器确认；第三次是服务器告诉客户端它的数据也发送完了；第四次是客户端确认。
	- 如果是三次挥手，可能会有数据丢失或漏掉确认，导致连接未能完全关闭。
2. **为什么不能是五次挥手？**
	- 额外的挥手会增加连接关闭的延迟，通常情况下没有必要。四次挥手已经能够确保双方确认所有的数据都已经发送完毕，连接正常关闭。
### [HTTP的Keep-Alive是什么？它在网络通信中有什么作用？](https://notes.kamacoder.com/questions/500019)
**Keep-Alive** 是 HTTP 协议中的一个机制，允许在**同一个 TCP 连接上进行多个 HTTP 请求和响应的交换**，而无需为每个请求都重新建立连接。主要用于减少网络通信中的延迟和资源消耗，提高性能。

##### 作用
1. **减少延迟**：避免了频繁的建立和关闭 TCP 连接，减少了通信延迟。
2. **降低负载**：减少了建立新连接的资源消耗，尤其是对于高并发的应用场景，能有效降低服务器负载。
3. **提高响应速度**：因为连接是持久的，可以直接重用，提高请求的处理效率。

##### 工作原理
在 HTTP/1.1 中，默认启用了 Keep-Alive 连接（可以通过 `Connection: keep-alive` 头部字段明确声明）。如果服务器支持并且响应头中没有指示连接关闭，客户端和服务器会保持 TCP 连接处于打开状态，以便处理后续请求。可以通过设置 `Connection: close` 来显式关闭连接。
### [TCP的Keepalive和HTTP的Keep-Alive是一个东西吗？它们之间有什么区别？](https://notes.kamacoder.com/questions/500020)
1. **工作层次不同**：
	- **TCP Keepalive** 是**TCP协议层**的机制。
	- **HTTP Keep-Alive** 是 **应用层（HTTP协议）** 的一种优化机制，工作在**更高层次的协议**上。
2. **目的不同**：
	- **TCP Keepalive** 目的是为了**维持连接的活跃状态**，确保长时间不传输数据的连接不被关闭或丢失。
	- **HTTP Keep-Alive** 目的是减少TCP连接的建立与断开，提高HTTP请求的效率。
3. **使用场景不同**：
	- **TCP Keepalive** 主要用于**长时间空闲的TCP连接**，防止防火墙或路由器关闭连接。
	- **HTTP Keep-Alive** 用于**多个HTTP请求复用同一个TCP连接**，从而减少延迟和连接开销。
4. **控制方式不同**：
	- **TCP Keepalive** 是由操作系统或TCP协议栈自动管理，通常不需要应用层干预。
	- **HTTP Keep-Alive** 需要在HTTP请求头部显示声明，通常由客户端和服务器协商来决定是否启用。
### [DNS查询过程是怎样的？它是如何实现域名解析的？](https://notes.kamacoder.com/questions/500021)
浏览器 → 缓存 →本地DNS服务器、根DNS服务器、TLD DNS服务器、权威DNS服务器 → 返回IP地址

---

1. **用户输入域名**：例如用户在浏览器中输入`www.example.com`。
2. **浏览器缓存查找**：浏览器首先会查看本地缓存是否有该域名的IP地址，如果有则直接使用。
3. **操作系统缓存查找**：如果浏览器缓存没有，操作系统会查询本地的DNS缓存，寻找该域名的IP地址。
4. **向本地DNS服务器查询**：向本地DNS服务器发送查询请求（通常是ISP的DNS服务器）。
	- **递归查询**：如果本地DNS服务器也没有缓存，它会进行递归查询，向根DNS服务器发起请求。
	- **根DNS服务器**：根DNS服务器会返回负责**顶级域（TLD）** 的DNS服务器的地址，例如`com`域的DNS服务器。
	- **TLD DNS服务器**：TLD DNS服务器返回负责**具体域名的DNS服务器地址**（例如`example.com`的权威DNS服务器）。
	- **权威DNS服务器**：最后，权威DNS服务器**返回该域名的IP地址**。
3. **返回IP地址：** 一旦DNS服务器获取到目标IP地址，它将返回给本地DNS服务器，再由本地DNS服务器返回给操作系统，操作系统再将结果返回给浏览器，浏览器使用该IP地址向服务器发起HTTP请求。


- **客户端** → 本地DNS服务器 → 根DNS服务器 → TLD DNS服务器 → 权威DNS服务器 → 返回IP地址
### [CDN是什么？它在网络传输中有什么作用？](https://notes.kamacoder.com/questions/500022)
1. **CDN的基本概念**
	- **内容分发网络（CDN）** 是一种通过**分布式的服务器群体**将内容分发到用户的网络架构。它通过将内容**缓存到各地的边缘节点服务器（CDN节点）**，使得用户能够从离自己**最近**的服务器获取资源，极大地减少了访问延迟。

2. **CDN的工作原理**
	- **缓存内容**：CDN服务器会缓存网站的静态内容（如HTML文件、CSS、JavaScript、图片、视频等）。
	- **负载均衡**：CDN会根据用户的地理位置、服务器负载、网络条件等因素，将用户请求分配到最合适的节点。

3. **CDN在网络传输中的作用**
	- **加速内容加载**：CDN将内容分发到多个地理位置，用户请求时可以从最近的节点获取内容，减少延迟，提升访问速度。
	- **降低源站压力**：通过缓存静态内容，CDN有效减轻源站服务器的访问压力，防止大规模访问时源站宕机。
	- **提高网站可用性**：CDN通过分布式架构，提供冗余和容错能力，即使某个节点或数据中心发生故障，其他节点仍然能继续提供服务。
	- **防御DDoS攻击**：CDN提供分布式的流量分发能力，可以帮助网站抵御大规模的DDoS攻击。
- **CDN的应用场景**
	- **网站加速**：CDN广泛应用于网站内容加速，尤其是对于全球用户的访问。
	- **视频流媒体**：视频网站（如YouTube、Netflix等）使用CDN来加速视频加载并减少卡顿现象。
	- **下载加速**：大型软件、游戏更新等通过CDN加速下载，提升用户体验。
- **常见的CDN提供商**
	- **阿里云CDN**、**腾讯云CDN**、**Cloudflare**、**Akamai**、**AWS CloudFront**等。
### [Cookie和Session是什么？它们在网络通信中扮演什么角色？有什么区别？](https://notes.kamacoder.com/questions/500023)
#### 知识索引

- **计算机网络** - HTTP协议
- **Web开发** - 用户状态管理


----
#### 简要回答

1. **Cookie**：存储在客户端，由服务器发送并由浏览器保存，主要用于状态保持、用户识别等。
2. **Session**：存储在服务器，用于跟踪用户会话，依赖Session ID进行关联。
3. **区别**：- **存储位置**：Cookie在客户端，Session在服务器端。
	- **安全性**：Session更安全，Cookie易被篡改或劫持。
	- **性能**：Cookie依赖网络带宽，Session依赖服务器资源。
	- **生命周期**：Cookie可以设置长期有效，Session一般在会话结束或超时后失效。


----
#### 详细回答

1. **Cookie**：
	- **定义**：HTTP协议是无状态的，Cookie通过在客户端存储键值对，帮助服务器识别用户。
	- **使用场景**：如购物车、登录保持。
	- **实现原理**：服务器通过`Set-Cookie`响应头下发，浏览器自动在后续请求中附带。
2. **Session**：
	- **定义**：Session用于在服务器端保存用户数据，如登录信息。通过生成唯一Session ID并存储在客户端Cookie中与用户关联。
	- **使用场景**：如敏感操作的用户认证。
	- **实现原理**：Session ID作为键，存储在服务器端的Session Store中，客户端通过Cookie传递Session ID进行交互。
3. **Cookie与Session的区别**：
	- **存储方式**：Cookie存储在浏览器，容量有限（一般4KB），Session存储在服务器，理论容量由服务器资源决定。
	- **传输方式**：Cookie随每次HTTP请求发送，增加带宽消耗；Session只存储Session ID。
	- **生命周期**：Cookie可设置持久化，Session通常随会话结束而失效。
	- **安全性**：Cookie数据可能被截获、篡改，Session保存在服务器，更安全。


----
#### 延申问答

1. **问题1**：如何增强Cookie的安全性？
	- **回答**：- 设置`HttpOnly`属性，防止JavaScript访问。
		- 设置`Secure`属性，仅允许HTTPS传输。
		- 使用加密存储敏感信息。
2. **问题2**：Session如何实现分布式部署？
	- **回答**：- 使用Redis、Memcached等集中存储Session数据。
		- 利用Token如JWT代替Session。
3. **问题3**：Cookie和LocalStorage的区别是什么？
	- **回答**：- **存储位置**：都在客户端。
		- **用途**：Cookie用于与服务器交互，LocalStorage用于本地存储。
		- **容量**：Cookie一般为4KB，LocalStorage为5MB。
		- **安全性**：LocalStorage不随HTTP请求发送，更安全。
### [什么是ARP协议？它在网络通信中有什么作用？](https://notes.kamacoder.com/questions/500024)
#### 知识索引

- **计算机网络** - 数据链路层与网络层交互
- **协议** - 地址解析协议（ARP，Address Resolution Protocol）


----
#### 简要回答

1. **ARP协议**：一种用于将网络层IP地址解析为数据链路层MAC地址的协议。
2. **作用**：在局域网中，帮助设备通过已知的IP地址找到对应的MAC地址，从而实现网络通信。
3. **工作流程**：- 设备发送ARP请求广播，询问目标IP地址的MAC地址。
	- 目标设备通过ARP响应单播返回其MAC地址。
4. **常见问题**：ARP缓存中可能存在被攻击者伪造的记录，导致ARP欺骗。


----
#### 详细回答

1. **ARP协议定义与背景**：
	- 在网络通信中，数据链路层使用MAC地址传递数据帧，而网络层使用IP地址定位设备。ARP协议充当桥梁，完成IP到MAC的地址解析。
	- 只适用于同一个局域网，因为广播包无法跨网段。
2. **工作流程**：
	1. **发送ARP请求**：源设备构造一个ARP请求包，其中包含目标IP地址，并通过广播发送到局域网内所有设备。
	2. **接收ARP响应**：目标设备接收请求后，检查是否与自己的IP地址匹配，若匹配则构造响应包（包含目标MAC地址）单播发送给源设备。
	3. **缓存记录**：源设备在接收到响应后，将目标设备的IP-MAC映射存储在ARP缓存中，以备后续使用，避免重复查询。
3. **作用**：
	- **设备间通信**：确保以太网设备能够通过IP地址定位并通信。
	- **提高效率**：通过ARP缓存减少频繁的地址解析操作。
4. **常见安全问题**：
	- **ARP欺骗攻击**：攻击者伪造ARP响应，将自身MAC地址冒充为网关MAC地址，劫持网络流量。
	- **缓解措施**：启用静态ARP表、使用安全ARP协议（如GARP）、部署ARP防护设备。


----
#### 延申问答

1. **问题1**：ARP协议的局限性有哪些？
	- **回答**：- 无法跨子网工作，需要网关设备中转。
		- 易受ARP欺骗攻击。
		- ARP广播增加局域网内的通信负担。
2. **问题2**：什么是ARP缓存中毒？
	- **回答**：攻击者通过伪造的ARP响应向目标设备注入错误的IP-MAC映射，从而劫持通信或进行中间人攻击。
3. **问题3**：如何防止ARP欺骗？
	- **回答**：- 配置静态ARP表，手动绑定IP-MAC对。
		- 使用交换机的动态ARP检测功能（DAI）。
		- 在网络中启用IP/MAC绑定的安全策略。
### [IP地址和MAC地址有什么区别？它们在网络通信中各自扮演什么角色？](https://notes.kamacoder.com/questions/500025)
#### 知识索引

- **计算机网络** - 网络层与数据链路层
- **协议** - IP地址与MAC地址的作用与区别


----
#### 简要回答

1. **MAC地址**：硬件地址，唯一标识网络设备，由制造商分配，属于数据链路层，用于局域网内的通信。
2. **IP地址**：逻辑地址，表示网络设备的位置，由网络管理员或自动分配（DHCP），属于网络层，用于跨网络通信。
3. **区别**：- **作用层级**：MAC地址用于链路层，IP地址用于网络层。
	- **固定性**：MAC地址与硬件绑定，IP地址可动态分配。
	- **作用范围**：MAC地址用于同一局域网内的通信，IP地址用于跨网络通信。
### [什么是NAT（网络地址转换）？它在网络通信中有什么作用？](https://notes.kamacoder.com/questions/500026)
#### 知识索引

- **计算机网络** - 网络层
- **协议** - 网络地址转换（NAT，Network Address Translation）


----
#### 简要回答

1. **NAT定义**：网络地址转换是一种将私有IP地址转换为公共IP地址的技术，用于解决IPv4地址不足的问题，同时增强网络安全性。
2. **作用**：- **地址复用**：允许多个设备通过一个公共IP地址访问互联网。
	- **隐私保护**：隐藏内网设备的真实IP地址，增强安全性。
	- **灵活路由**：支持内外网地址的动态映射，方便网络管理。
3. **工作原理**：NAT设备（如路由器）通过维护映射表，将内网设备的私有IP地址和端口号映射到公共IP地址和端口号，实现数据包的地址转换。


----
#### 详细回答

1. **NAT分类**：
	- **静态NAT**：为每个内网设备分配一个固定的公共IP地址，适合需要外网访问的设备。
	- **动态NAT**：从一个公共IP地址池中动态分配公共IP，适合临时访问外网的设备。
	- **端口地址转换（PAT，Port Address Translation）**：将多个私有IP地址通过端口号映射到一个公共IP地址，是最常见的NAT形式。
2. **NAT的主要作用**：
	- **节省IPv4地址**：通过地址复用解决公网IPv4地址不足问题。
	- **隔离内外网**：隐藏内网拓扑，防止外部直接访问内网设备。
	- **网络灵活性**：支持不同规模的内网部署，无需对外网路由器进行调整。
3. **NAT工作流程**：
	1. 内网设备发出请求时，NAT设备记录请求的私有IP地址和端口号，将其转换为公共IP地址和新的端口号，修改数据包头后发送到外网。
	2. 外网设备响应时，NAT设备根据映射表将数据包中的公共IP地址和端口号转换回对应的私有IP地址和端口号，并转发给内网设备。
4. **NAT的局限性**：
	- **破坏端到端通信**：NAT引入地址转换，破坏了原本的IP端到端模型，对某些协议（如P2P、VoIP）支持不友好。
	- **性能开销**：NAT设备需要维护映射表并实时进行转换，增加了设备的计算负担。


----
#### 延申问答

1. **问题1**：NAT如何与IPv6兼容？
	- **回答**：由于IPv6地址充足，NAT在IPv6中通常被替代为NPT（Network Prefix Translation），用于改变网络前缀，但保留设备地址的端到端特性。
2. **问题2**：NAT对网络安全有哪些影响？
	- **回答**：- **正面**：隐藏内网设备的真实IP地址，减少攻击面。
		- **负面**：对外发起的攻击仍能通过NAT转发，需要结合防火墙等技术。
3. **问题3**：NAT与VPN如何协同工作？
	- **回答**：NAT设备可以将VPN流量映射到公共IP地址，但需要支持NAT穿越技术（如NAT-T），以解决VPN协议对NAT的不兼容问题。
### [TCP/IP模型中，传输层和应用层各有哪些主要协议？它们的作用是什么？](https://notes.kamacoder.com/questions/500027)
#### 知识索引

- **计算机网络** - TCP/IP协议模型
- **协议分类** - 传输层与应用层协议


----
#### 简要回答

1. **传输层主要协议及作用**：
	- **TCP（Transmission Control Protocol）**：面向连接，提供可靠的数据传输（如文件传输、邮件）。
	- **UDP（User Datagram Protocol）**：无连接，提供快速但不可靠的数据传输（如视频流、DNS）。
2. **应用层主要协议及作用**：
	- **HTTP/HTTPS**：用于浏览器和服务器之间的超文本传输，HTTPS是加密版的HTTP。
	- **FTP（File Transfer Protocol）**：文件上传和下载。
	- **SMTP（Simple Mail Transfer Protocol）**：邮件发送协议。
	- **DNS（Domain Name System）**：域名到IP地址解析。
	- **Telnet/SSH**：远程登录，SSH加密通信，Telnet为明文传输。
### [OSI模型中，哪一层负责数据的加密和解密？哪一层负责数据的传输？](https://notes.kamacoder.com/questions/500028)
#### 简要回答

1. **负责数据加密和解密的层**：
	- **表示层**：负责数据的加密、解密、压缩、格式转换等功能，确保应用层数据的正确表示。
2. **负责数据传输的层**：
	- **传输层**：负责端到端的数据传输与控制，包括分段、重组、流量控制、错误校验等功能。


----
#### 详细回答

1. **表示层（第6层）**：
	- **主要功能**：- 数据加密：对数据进行加密处理，保证传输中的数据保密性。
		- 数据解密：对接收端数据进行解密，恢复到原始状态。
		- 数据格式转换：支持不同平台之间的数据格式互通。
		- 数据压缩：减少数据体积，提高传输效率。
	- **应用场景**：SSL/TLS协议的加密解密属于表示层的功能。
2. **传输层（第4层）**：
	- **主要功能**：- 端到端连接：建立源主机与目标主机之间的通信通道。
		- 数据分段与重组：将数据分为小段传输，在接收端重组。
		- 流量控制：确保发送方的速度不会超出接收方的处理能力。
		- 错误检测与校正：确保数据的完整性与可靠性。
	- **应用场景**：TCP和UDP协议属于传输层。
### [什么是网络分层模型？它在网络通信中有什么作用？](https://notes.kamacoder.com/questions/500029)
#### 简要回答

1. **网络分层模型的定义**：
	- 将网络通信过程划分为多个独立的层，每层负责不同的功能，形成一种模块化的设计结构。
	- 常见的网络分层模型包括OSI模型（7层）和TCP/IP模型（4层）。
2. **作用**：
	- **功能分离**：每层专注于特定功能，简化设计和实现。
	- **模块化设计**：各层独立实现，便于开发、优化和维护。
	- **互操作性**：提供标准化接口，确保不同设备和协议之间能够协同工作。
	- **灵活性**：允许在某一层实现替换或升级，而无需影响其他层。
### [HTTP请求中的头部字段有哪些常见的类型？它们各自的作用是什么？](https://notes.kamacoder.com/questions/500030)
1. **通用字段（General Header Fields）**：提供关于消息的协议级别的信息，适用于请求和响应。
	- `Cache-Control`：控制缓存行为（如`no-cache`、`max-age`等）。
	- `Connection`：管理连接控制（如`keep-alive`、`close`等）。
	- `Date`：标识消息的创建时间。

---

2. **请求字段（Request Header Fields）**：告知服务器请求的具体需求和客户端能力。
	- `Host`：指定请求的目标主机和端口。
	- `User-Agent`：标识客户端的信息（如浏览器类型、版本等）。
	- `Authorization`：传递认证凭证，用于服务器身份验证。
	- `Accept`：指定客户端支持的媒体类型（如`text/html`、`application/json`等）。
	- `Accept-Encoding`：指定客户端支持的编码类型（如`gzip`、`deflate`等）。

---

3. **响应字段（Response Header Fields）**：向客户端提供关于响应和服务器的信息。
	- `Server`：提供服务器的相关信息（如服务器名称、版本）。
	- `Set-Cookie`：在客户端存储Cookie，用于状态管理。
	- `WWW-Authenticate`：要求客户端提供身份验证信息。
	- `Location`：重定向响应中提供新的URL。

---

4. **实体字段（Entity Header Fields）**：描述请求或响应主体的内容信息。
	- `Content-Type`：指定响应实体的媒体类型（如`application/json`、`image/png`等）。
	- `Content-Length`：标识实体主体的大小（以字节为单位）。
	- `Content-Encoding`：标识实体主体的编码方式（如`gzip`、`compress`等）。
	- `Last-Modified`：标识资源的最后修改时间。

### [什么是HTTP管道化？它在网络通信中有什么作用？](https://notes.kamacoder.com/questions/500031)
- **HTTP管道化（Pipelining）定义**：
	- HTTP管道化是一种允许客户端在接收到前一个请求的响应之前，直接发送多个请求的技术，用于提高网络通信效率。
	- 适用于HTTP/1.1，但需要客户端和服务器的支持。
- **作用**：
	- **减少延迟**：通过消除请求和响应之间的等待时间，提高传输效率。
	- **提高吞吐量**：允许多个请求同时发送，减少连接开销。
	- **节省资源**：通过复用单个TCP连接，减少资源占用。
### [HTTP/2相比HTTP/1.1有哪些主要改进？这些改进带来了哪些好处？](https://notes.kamacoder.com/questions/500032)
1. **HTTP/2的主要改进**：
	- **二进制分帧**：HTTP/2采用二进制格式，而非HTTP/1.1的纯文本格式，提高解析效率。
	- **多路复用**：在一个TCP连接上支持多个请求和响应同时传输，解决HTTP/1.1的队头阻塞问题。
	- **头部压缩**：通过HPACK算法压缩HTTP头部，减少网络带宽占用。
	- **服务器推送**：允许服务器主动将资源推送到客户端，无需客户端请求。
	- **流优先级**：支持流的优先级和依赖关系管理，优化资源分配。
2. **改进带来的好处**：
	- **性能提升**：减少延迟，提高网页加载速度。
	- **带宽节省**：头部压缩与服务器推送降低了网络流量消耗。
	- **优化用户体验**：更快的响应时间与更高的吞吐量提升了用户体验。
### [什么是HTTP持久连接？它在网络通信中有什么作用？](https://notes.kamacoder.com/questions/500033)
1. **HTTP持久连接（Persistent Connection）定义**：
	- HTTP持久连接是一种允许多个请求和响应在同一个TCP连接中传输的机制。
	- 在HTTP/1.1中默认启用，通过`Connection: keep-alive`头部显式表示。
2. **作用**：
	- **减少连接开销**：避免为每个HTTP请求重复建立和关闭TCP连接。
	- **提升性能**：减少延迟和网络资源的消耗，特别是在需要加载多个资源的网页中。
	- **优化并发请求**：通过复用连接，提高服务器的吞吐量和客户端的响应速度。
### [TCP滑动窗口机制是如何工作的？它在流量控制中有什么作用？](https://notes.kamacoder.com/questions/500034)
1. **滑动窗口机制的工作原理**：
	- **发送窗口**：发送方维护一个窗口，用于记录可以发送但尚未确认的数据范围。
	- **接收窗口**：接收方维护一个窗口，表示其接收缓冲区的可用大小。
	- **窗口大小**：发送方窗口大小受接收方`Advertised Window`和网络拥塞控制的共同影响。
	**滑动过程**：
	- 发送方将窗口范围内的数据发送出去，同时等待接收方的确认（ACK）。
	- 接收方收到数据后，发送ACK，通知发送方已成功接收的字节数。
	- 发送方根据ACK滑动窗口，释放已确认的数据字节空间，并允许发送更多数据。
2. **关键字段**：
	- **窗口大小（Window Size）**：TCP头部的字段，表示接收方当前缓冲区的剩余空间，通知发送方可以发送的数据量。
	- **序列号（Sequence Number）**：标识每个字节的序号，用于确认数据的接收顺序。
	- **确认号（Acknowledgment Number）**：接收方通知发送方已接收的字节序号。
3. **滑动窗口与流量控制**：
	- **防止拥塞**：接收方通过动态调整窗口大小，通知发送方根据自身接收能力调整发送速率，避免发送过多数据。
	- **避免丢包**：如果接收方缓冲区即将满时，会通过缩小窗口大小减缓发送方速度，避免因丢包导致重传。
	- **适应性强**：滑动窗口机制根据网络状况实时调整窗口大小，适应不同的网络带宽和延迟。
## 操作系统
### [进程和线程的区别是什么？](https://notes.kamacoder.com/questions/500050)
##### 进程与线程的区别：

1. **定义**：
	- **进程**：是**操作系统分配资源**的基本单位，具有**独立的内存空间和系统资源**。
	- **线程**：是**进程中的执行单位**，**共享**进程的资源（如内存、文件描述符等）。
2. **资源分配**：
	- **进程**：每个进程有**独立的地址空间、数据段、堆栈和文件描述符**等资源。
	- **线程**：同一进程的线程共享进程的地址空间，但**有各自的寄存器、堆栈**等。
3. **开销**：
	- **进程**：创建和切换进程的开销较大。
	- **线程**：线程间的切换开销较小，创建和销毁也比进程更轻量。
4. **通信方式**：
	- **进程**：进程之间通信（IPC）比较复杂，通常通过**管道、消息队列、共享内存**等方式。
	- **线程**：线程间通信相对简单，因为它们共享同一进程的内存。
5. **稳定性**：
	- **进程**：一个进程崩溃**不会直接影响**到其他进程。
	- **线程**：一个线程崩溃可能会**导致整个进程崩溃**。
### [并行和并发有什么区别？](https://notes.kamacoder.com/questions/500051)
##### 并行与并发的区别：

1. **定义**：
	- **并发**：多个任务在同一时间段内交替执行，但并不是同时执行。一个处理器或多核处理器通过快速切换任务实现并发。
	- **并行**：多个任务在同一时间点同时执行，通常需要多个处理器或核心。
2. **资源**：
	- **并发**：单个处理器通过时间片轮转在不同任务间切换，任务不会在同一时刻执行。
	- **并行**：多个处理器或多个核心在同一时刻处理不同的任务。
3. **实现方式**：
	- **并发**：通过多任务调度、线程管理实现。
	- **并行**：通过多核、多处理器同时工作，硬件资源支持。
4. **适用场景**：
	- **并发**：适用于任务不依赖于实时执行的场景，如I/O密集型任务。
	- **并行**：适用于需要大量计算的场景，如大数据处理、科学计算。
### [解释一下用户态和核心态？](https://notes.kamacoder.com/questions/500052)
#### 简要回答

##### 用户态与核心态的区别：

1. **定义**：
	- **用户态（User Mode）**：程序在用户空间运行的模式，应用程序和进程运行的状态。
	- **核心态（Kernel Mode）**：操作系统内核在核心空间运行的模式，具有访问硬件和系统资源的权限。
2. **访问权限**：
	- **用户态**：限制访问硬件、内存、I/O设备等系统资源，只有操作系统提供的接口可用。
	- **核心态**：可以直接访问硬件和内存等系统资源，有完全的权限。
3. **性能**：
	- **用户态**：操作受限，执行效率较低，但可以更好地保障安全性。
	- **核心态**：权限更大，但操作系统必须严格控制，通常会增加上下文切换的开销。
4. **应用场景**：
	- **用户态**：应用程序运行时一般处于用户态，执行大多数计算任务。
	- **核心态**：操作系统内核执行，如进程调度、硬件管理、文件操作等。

#### 详细回答

1. **用户态**：
	- **概念**：是指程序执行时不具有访问硬件的直接权限，只能通过系统调用等方式请求操作系统内核来完成底层的操作。用户态的代码通常运行在应用程序的上下文中，操作系统对其进行控制和保护。
	- **权限**：在用户态中，应用程序无法直接访问硬件资源，比如CPU寄存器、内存中的关键部分或I/O设备等。
	- **任务**：大部分的应用程序、进程、线程等都在用户态中运行。操作系统会将它们的访问权限限制在一个用户级的空间内，以确保程序不会误操作系统内核或硬件资源，保障系统稳定性和安全性。
2. **核心态**：
	- **概念**：核心态，也叫内核态，是指操作系统内核运行的模式。它具有完全的权限，可以直接访问硬件资源、内存以及管理硬件设备。核心态下的代码通常执行操作系统管理任务，如进程调度、内存管理、硬件访问、系统调用等。
	- **权限**：在核心态中，操作系统拥有对硬件和内存的完全控制，能够进行直接的系统级操作。
	- **任务**：内核操作、系统资源管理、硬件控制等都在核心态中完成。每当一个系统调用被触发时，CPU会从用户态切换到核心态。
3. **状态切换**：
	- 进程在运行时，根据需要频繁在用户态和核心态之间切换。例如，当应用程序需要进行文件读写、网络通讯或进行其他需要操作系统服务的操作时，程序会执行**系统调用**，从用户态切换到核心态。完成操作后，CPU会从核心态切换回用户态继续执行程序。
	- 这种切换通常通过**上下文切换**（context switch）来实现，会有一定的性能开销，特别是在高频次的切换中。
4. **性能对比**：
	- **用户态**：由于不允许直接访问硬件，进程的执行速度相对较慢，但这种隔离可以提升系统安全性和稳定性。
	- **核心态**：虽然具有直接访问硬件的能力，但由于切换到核心态需要进行更多的操作（如切换上下文、保存状态等），因此会比用户态的执行速度慢。
### [进程调度算法你了解多少？](https://notes.kamacoder.com/questions/500053)
#### 简要回答

##### 常见的进程调度算法：

1. **先来先服务（FCFS）**：
	- 按照进程到达的顺序执行。
	- 优点：实现简单，适用于大部分情况。
	- 缺点：可能导致“饥饿现象”和“长任务阻塞短任务”。
2. **最短作业优先（SJF）**：
	- 优先执行运行时间最短的进程。
	- 优点：减少平均等待时间。
	- 缺点：难以预测作业的执行时间，可能导致长作业饥饿。
3. **优先级调度**：
	- 根据每个进程的优先级决定执行顺序，高优先级的进程先执行。
	- 优点：可以灵活控制进程调度。
	- 缺点：低优先级进程可能长期得不到执行（饥饿问题）。
4. **轮询（Round Robin，RR）**：
	- 将CPU时间划分为固定长度的时间片，按顺序循环分配给每个进程。
	- 优点：公平，适用于大多数情况，避免长时间阻塞。
	- 缺点：时间片长度设置不当可能导致效率低下。
5. **多级反馈队列（MFQ）**：
	- 将进程根据优先级划分为不同的队列，进程如果运行时间过长会被降级到较低优先级的队列。
	- 优点：综合了SJF和RR的优点，处理各种进程更为高效。
	- 缺点：算法较复杂，难以调试和优化。

#### 详细回答

1. **先来先服务（FCFS，First-Come, First-Served）**：
	- **特点**：这是最简单的调度算法，进程根据它们到达的顺序执行。一个进程执行完后，下一个进程才开始执行。
	- **优点**：- 实现简单，易于理解。
		- 无需复杂的计算。
	- **缺点**：- 若某个较长的进程先到达，则可能导致后来的短进程等待时间过长，导致**“饥饿现象”**。
		- **平均等待时间较长**。
2. **最短作业优先（SJF，Shortest Job First）**：
	- **特点**：优先执行运行时间最短的进程。这种方法可以最小化平均等待时间。
	- **优点**：- **最小化平均等待时间**。
		- 高效，适用于短任务较多的场景。
	- **缺点**：- 无法准确预测进程的执行时间。
		- **长任务可能被一直阻塞**，导致“饥饿现象”。
3. **优先级调度**：
	- **特点**：为每个进程分配一个优先级，调度器优先选择具有较高优先级的进程。可以是**抢占式**或**非抢占式**。
	- **优点**：- 可以灵活地根据需求调整调度策略。
		- 适用于需要处理不同优先级任务的场景。
	- **缺点**：- **低优先级进程可能长期得不到执行**，导致“饥饿问题”。
		- **优先级反转**：低优先级进程可能被高优先级进程占用，影响调度效率。
4. **轮询调度（Round Robin，RR）**：
	- **特点**：为每个进程分配一个固定长度的时间片，进程在时间片内执行完就被抢占，进入就绪队列的尾部。适合时间要求相对均衡的任务。
	- **优点**：- **公平性**：每个进程都有均等的机会执行。
		- 适合负载均衡的场景。
	- **缺点**：- 时间片设置不当可能导致**上下文切换过多**，增加开销，效率降低。
		- **低效率**：如果进程的执行时间远小于时间片长度，浪费了大量的CPU资源。
5. **多级反馈队列调度（MFQ，Multilevel Feedback Queue）**：
	- **特点**：结合了**先来先服务**和**最短作业优先**的优点，使用多个队列处理不同优先级的进程，并在进程执行过程中动态调整优先级。
	- **优点**：- 综合了SJF和RR的优点，更适合多种任务的调度。
		- **动态调整**优先级，避免了饥饿问题。
	- **缺点**：- 算法复杂，**调度决策开销大**。
		- 实现困难，需要合理设置队列的数量和优先级提升/降低的规则。

#### 延申问答

1. **进程调度算法如何选择？**
	- 选择合适的调度算法取决于实际场景。例如：- 对于**批处理作业**，SJF或FCFS可以更适合。
		- 对于**多任务**、**实时响应要求高的应用**，RR和MFQ更为合适。
		- 在系统对**实时性要求较高**的场景，优先级调度和多级反馈队列可能是更好的选择。
2. **多级反馈队列如何防止“饥饿现象”？**
	- 多级反馈队列通过**动态调整进程优先级**来防止长时间未执行的进程被饿死。例如，低优先级进程在执行时间过长后，会被提升到更高的优先级队列中，从而得到更早执行的机会。
### [进程间有哪些通信方式？](https://notes.kamacoder.com/questions/500054)
#### 简要回答

##### 1. **管道（Pipe）**

- 用于父子进程之间通信。
- 数据以字节流的方式在进程间传递。
- 分为匿名管道和命名管道。
- 适用于数据流向明确的情况。

##### 2. **消息队列（Message Queue）**

- 在操作系统内核中维护一个消息队列，进程通过读写消息进行通信。
- 支持异步通信，进程间的消息是以消息的形式传递。
- 支持多对多通信，适合于不同进程间的数据传输。

##### 3. **共享内存（Shared Memory）**

- 允许多个进程共享一块内存区域，所有进程都可以直接读写这块内存。
- 速度较快，因为不需要内核的参与，直接操作内存。
- 需要进程间协调，防止竞争条件。

##### 4. **信号量（Semaphore）**

- 用于控制多个进程对共享资源的访问，防止资源冲突。
- 可以实现进程的同步和互斥。
- 基本通过信号量的计数来控制进程访问共享资源的数量。

##### 5. **套接字（Socket）**

- 主要用于跨网络或跨主机的进程通信。
- 支持TCP、UDP协议进行数据传输，广泛应用于分布式系统中。
- 支持点对点、客户端-服务器模型的通信。
### [解释一下进程同步和互斥，以及如何实现进程同步和互斥？](https://notes.kamacoder.com/questions/500055)
#### 简要回答

##### 1. **进程同步**

- **定义**：多个进程需要在某些情况下按照一定顺序执行，以保证数据的一致性和正确性。进程同步解决了进程执行顺序的问题。
- **实现方式**：通过信号量、条件变量、事件等同步机制。
- **场景**：例如，进程A需要等待进程B处理完某项任务才能继续执行。

##### 2. **进程互斥**

- **定义**：互斥是指在同一时刻只能有一个进程访问共享资源，以避免数据冲突或不一致。
- **实现方式**：通过互斥锁、信号量等同步原语来实现对共享资源的独占访问。
- **场景**：例如，多个进程需要访问同一文件或数据库时，需要互斥来保证数据的一致性。
### [什么是死锁，如何预防死锁？](https://notes.kamacoder.com/questions/500056)
#### 简要回答

##### 1. **死锁定义**

- **死锁**是指在多个进程或线程执行过程中，因争夺资源而造成一种相互等待的现象，导致所有进程或线程都无法继续执行。

##### 2. **死锁的四个必要条件**

- **互斥条件**：每个资源只能被一个进程占用。
- **占有且等待**：一个进程已经持有至少一个资源，并且在等待获取其他资源。
- **非抢占条件**：进程已获得的资源不能被其他进程强行抢占，只能在进程释放资源时才被其他进程使用。
- **循环等待**：一组进程中的每个进程都在等待下一个进程持有的资源，形成一个闭环。

#### 详细回答

##### 1. **死锁的发生条件**

- 死锁的四个条件必须同时满足，才能导致死锁。只有当这四个条件同时成立时，进程才会陷入死锁状态。

##### 2. **死锁的预防方法**

- **破坏互斥条件**- 尽量避免使用互斥资源，或者使用共享资源来替代资源的独占访问。例如，通过引入锁机制，使用读写锁而非互斥锁（mutex），允许多个进程读资源，但写操作仍然需要独占。
- **破坏占有且等待条件**- **请求资源时一次性获取所有资源**：进程在启动时请求它所需要的所有资源，一旦获得它们，就开始执行；如果无法同时获取所有资源，则进程不会获得任何资源。
	- **提前获取资源**：将所有的资源请求提前处理完，避免部分资源占用时发生阻塞。
- **破坏非抢占条件**- 如果进程已持有某些资源并等待其他资源，在获取不到所需资源时，释放它已经持有的资源，并在稍后重新请求，这样其他进程就可以使用这些资源。
- **破坏循环等待条件**- **资源排序**：为所有资源分配一个唯一的顺序，进程请求资源时，必须按照顺序请求。这样能够避免循环等待的情况。例如，进程总是先请求编号较小的资源，避免形成闭环。
	- **避免死锁检测与恢复**：定期检查系统是否发生死锁，通过回滚进程或强制释放资源来解决死锁。

##### 3. **死锁的解决方法**

- **死锁检测**：定期扫描系统资源图，检测是否存在死锁。一旦发现死锁，采取措施如终止进程、回滚进程等。
- **死锁恢复**：通过中止某个进程或回收资源来恢复系统，恢复的方式包括终止进程、撤销进程的操作、重新分配资源等。

#### 延申问答

- **死锁预防与避免的区别**：- **死锁预防**是通过从系统设计上避免死锁的发生，通常通过破坏死锁发生的四个必要条件之一来预防死锁。
	- **死锁避免**则是通过分析系统的资源分配情况，动态地决定是否可以进行资源分配，从而避免死锁的产生。
### [介绍一下几种典型的锁？](https://notes.kamacoder.com/questions/500057)
#### 简要回答

##### 1. **乐观锁**

- 基于数据版本控制，适用于不常发生冲突的场景。
- 在执行前不加锁，执行时进行检查，若数据没有被其他线程修改，则提交；如果被修改，则重试或放弃。

##### 2. **悲观锁**

- 线程获取锁后，其他线程不能访问资源，直到释放锁。适用于冲突频繁的场景。

##### 3. **读写锁**

- 允许多个线程同时读取资源，但在写操作时，其他线程无法读取或写入资源。
### [讲一讲你理解的虚拟内存？](https://notes.kamacoder.com/questions/500058)
##### 1. **虚拟内存的定义**

- 虚拟内存是操作系统的一项重要功能，它允许应用程序使用比物理内存更大的内存空间。操作系统通过将程序使用的内存映射到物理内存和硬盘存储之间来实现虚拟内存。这样，程序可以认为自己拥有一个连续且庞大的内存空间，而实际上物理内存远小于虚拟内存的大小。

##### 2. **虚拟内存的工作原理**

- **地址转换**：虚拟内存将程序使用的虚拟地址通过内存管理单元（MMU）映射到物理内存的地址空间。每个程序有自己的虚拟地址空间，操作系统负责管理这些映射关系。
- **分页机制**：虚拟内存通常使用分页（Paging）或分段（Segmentation）技术将虚拟内存分成固定大小的页面（Page）。当程序需要访问某个页面时，如果该页面不在物理内存中，操作系统会将其从硬盘加载到内存，这个过程称为**页面交换（Page Swap）**。

##### 3. **虚拟内存的优点**

- **内存隔离**：虚拟内存为每个进程提供独立的地址空间，防止了进程之间互相影响，提高了系统的稳定性和安全性。
- **进程扩展**：虚拟内存允许程序使用比物理内存更大的空间，即使物理内存不足，也能正常运行。
- **简化编程**：程序员不需要关心内存的具体分配和管理，只需要按照虚拟地址访问内存。

##### 4. **虚拟内存的缺点**

- **性能问题**：虚拟内存依赖于硬盘交换，当物理内存不足时，频繁的页面交换会导致性能下降，即**交换抖动（Thrashing）**现象。
- **硬盘性能**：硬盘的读写速度远低于内存，过多的内存分页会导致系统性能显著下降。

##### 5. **虚拟内存与物理内存的关系**

- 虚拟内存并不等同于物理内存，它是程序和硬件之间的一个抽象层。操作系统通过内存管理和交换机制，利用硬盘空间扩展了物理内存的容量，但当系统需要交换大量数据时，性能会大幅降低。

##### 6. **虚拟内存的应用场景**

- 在多任务操作系统中，虚拟内存允许多个程序并行运行而不互相干扰，且每个程序都拥有独立的内存空间。
- 在内存资源紧张时，操作系统通过虚拟内存机制将不常用的页面交换到硬盘，以便腾出空间供当前活动的进程使用。
### [你知道的线程同步的方式有哪些？](https://notes.kamacoder.com/questions/500059)
##### 1. **互斥锁（Mutex）**

- **原理**：互斥锁是一种最常见的同步机制，通过加锁和解锁的方式保证同一时间只能有一个线程访问共享资源。加锁的线程持有锁，其他线程只能等待。
- **应用场景**：适用于保护临界区，防止数据竞争。
- **实现**：Java中的`ReentrantLock`，`synchronized`关键字。

##### 2. **自旋锁（SpinLock）**

- **原理**：自旋锁与互斥锁类似，但它不会将线程挂起，而是让线程在尝试获取锁时反复检查锁是否释放，直到获得锁为止。这种方式适用于锁的持有时间非常短的场景。
- **应用场景**：当锁的粒度小、持有时间短时，使用自旋锁能够减少线程切换带来的性能开销。
- **实现**：Java中的`AtomicBoolean`和`CAS`（Compare-And-Swap）操作。

##### 3. **读写锁（ReadWriteLock）**

- **原理**：读写锁允许多个线程并发读共享数据，但在写操作时，只能有一个线程持有锁，并且其他线程无法读写。这样能够提高读操作频繁时的并发性。
- **应用场景**：适用于读取多于写入的场景，如缓存系统中的读写操作。
- **实现**：Java中的`ReentrantReadWriteLock`。

##### 4. **信号量（Semaphore）**

- **原理**：信号量是一种计数信号量，通过一个计数器控制对共享资源的访问。当计数器大于0时，线程可以获取资源，计数器减1；当计数器为0时，线程必须等待。信号量通常用于限制资源的并发访问数量。
- **应用场景**：例如控制并发访问数据库连接池的大小。
- **实现**：Java中的`Semaphore`。

##### 5. **线程局部存储（ThreadLocal）**

- **原理**：线程局部存储为每个线程提供独立的变量副本，使得每个线程都能访问到自己私有的数据，避免线程间的数据共享问题，从而达到同步的目的。
- **应用场景**：适用于每个线程需要独立的数据副本的场景，如数据库连接和用户会话。
- **实现**：Java中的`ThreadLocal`类。
## 数据库
### [一条SQL查询语句是如何执行的？](https://notes.kamacoder.com/questions/500090)
1. 先通过连接器校验权限
2. 利用分析器进行 SQL 语句的词法分析和语法分析，构建解析树
3. 使用优化器选择合适的索引和表连接顺序，最终选择一个最佳的执行计划
4. 利用执行器，调用引擎层查询数据，返回结果集给客户端

### [数据库的事务隔离级别有哪些？](https://notes.kamacoder.com/questions/500091)
1）读未提交（READ UNCOMMITTED）：这是最低的隔离级别，在该级别下，一个事务可以看到另一个事务尚未提交的数据修改。这可能会导致脏读问题，即读取到其他事务未提交的数据。
2）读已提交（READ COMMITTED）：在这个级别下，一个事务只能看到已经提交的其他事务所做的修改。这可以避免脏读问题，但是可能会引发不可重复读问题，即在同一个事务中，相同的查询可能返回不同的结果。
3）可重复读（REPEATABLE READ）：在这个级别下，确保在一个事务中的多个查询返回的结果是一致的。这可以避免不可重复读问题，但是可能会引发幻读问题，即在同一个事务中，多次查询可能返回不同数量的行（MySQL 默认的隔离级别）。
4）串行化（SERIALIZABLE）：这是最高的隔离级别，在这个级别下，事务串行执行，即每个事务都会等待前一个事务执行完毕才会开始执行。这可以避免所有的并发问题，但是会大大降低并发性能。

### [事务的四大特性有哪些？](https://notes.kamacoder.com/questions/500092)
#### 简要回答

事务的四大特性（ACID）是：
1. **原子性（Atomicity）**：事务中的所有操作要么全部成功，要么全部失败。
2. **一致性（Consistency）**：事务执行前后，数据库的状态保持一致。
3. **隔离性（Isolation）**：多个事务并发执行时，各事务互不干扰。
4. **持久性（Durability）**：一旦事务提交，其结果永久保存。
### [MySQL的执行引擎有哪些？](https://notes.kamacoder.com/questions/500093)
1. InnoDB：
- 支持事务和外键，使用行级锁。
- 提供高并发性能，适用于高负载的 OLTP 应用。
- 数据以聚集索引的方式存储，提高查询效率。

2. MyISAM：
- 不支持事务和外键，使用表级锁。
- 适合读取多、更新少的场景，如数据仓库。

3. MEMORY：
- 数据存储在内存中，速度快，但数据在服务器重启后丢失。
- 适用于临时数据存储或快速缓存。

4. NDBCluster：
- 支持高可用性和数据分布，适合大规模分布式应用
- 提供行级锁和自动分区。

5. ARCHIVE：
•	用于存储大量历史数据，支持高效的插入和压缩。
•	不支持索引，适合日志数据存储。

### [MySQL为什么使用B+树来作索引？](https://notes.kamacoder.com/questions/500094)
##### B+ 树在数据库系统中具有以下几个显著优势：
**1）高效的查找性能：**
B+ 树是一种自平衡树，每个叶子节点到根节点的路径长度相同，B+ 树在插入和删除节点时会进行分裂和合并操作，以保持树的平衡，但它又会有一定的冗余节点，使得删除的时候树结构的变化小，更高效。
查找、插入、删除等操作的时间复杂度为 O(log n)，能够保证在大数据量情况下也能有较快的响应时间。
**2）树的高度增长不会过快，使得查询磁盘的 I/O 次数减少：**
B+ 树不像红黑树，数据越多树的高度增长就越快。它是多叉树，非叶子节点仅保存主键或索引值和页面指针，使得每一页能容纳更多的记录，因此内存中就能存放更多索引，容易命中缓存，使得查询磁盘的 I/O 次数减少。
**3）范围查询能力强：**
B+ 树特别适合范围查询。因为叶子节点通过链表链接，从根节点定位到叶子节点查找到范围的起点之后，只需要顺序扫描链表即可遍历后续的数据，非常高效。

##### B+ 树和 B 树区别
1）B 树每个节点都存储了完整的数据，而 B+ 树非叶子节点仅存储 key 和指针，完整数据存储在叶子节点。这使得 B+ 树可以在内存中存放更多索引页，减少磁盘查询次数。
2）B+ 树叶子组成了链表，便于区间查找，而 B 树只能每一层遍历查找。
3）B+ 树查询时间更平均、稳定，都需要从根节点扫描到叶子节点。而 B 树则在非叶子节点就可能找到对应的数据返回。

### [说一下索引失效的场景？](https://notes.kamacoder.com/questions/500095)
##### 索引失效的场景：
例如查询条件中不包含索引列、低基数列索引效果不佳，或查询条件复杂且不匹配索引的顺序。
对于一些小表，MySQL可能选择全表扫描而非使用索引，因为全表扫描的开销可能更小。
最终是否用上索引是根据 MySQL 成本计算决定的，评估 CPU 和 I/O 成本最终选择用辅助索引还是全表扫描。有时候确实是全表扫描成本低所以没用上索引。但有时候由于一些统计数据的不准确，导致成本计算误判，而没用上索引。

##### 排查索引效果的方法：
使用 EXPLAIN 命令，通过在查询前加上EXPLAIN，可以查看 MySQL 选择的执行计划，了解是否使用了索引、使用了哪个索引、估算的行数等信息。
主要观察 EXPLAIN 结果以下几点：
- type（访问类型）：这个属性显示了查询使用的访问方法，例如 ALL、index、range 等。当查询使用索引时，这个属性通常会显示为 index 或 range ，表示查询使用了索引访问。如果这个值是 ALL ，则表示查询执行了全表扫描，没有使用索引。
- key（使用的索引）：这个属性显示了查询使用的索引，如果查询使用了索引，则会显示索引的名称。如果这个值是 NULL，则表示查询没有使用索引。
- rows（扫描的行数）：这个属性显示了查询扫描的行数，即查询返回的行数，需要评估下扫描量。

### [undo log、redo log、binlog 有什么用？](https://notes.kamacoder.com/questions/500096)
##### redo log：
- 重做日志（redo log）是 InnoDB 引擎内部的事务日志，用于记录数据页的物理修改。
- redo log 是固定大小的环形日志，主要用于崩溃恢复。它可以帮助 InnoDB 在崩溃后通过日志重做未写入数据页的数据修改，从而确保数据的持久性。
##### binlog：
- 二进制日志（binlog）是 MySQL Server 层的日志，用于记录所有数据库的修改操作，包括增删改操作（DML）以及表结构的修改（DDL）。
- binlog 是追加写入的日志文件，主要用于数据恢复、主从复制、数据备份等场景。它记录的是 SQL 语句的逻辑修改操作，而非数据页的物理修改。

### [什么是慢查询？原因是什么？可以怎么优化？](https://notes.kamacoder.com/questions/500097)
可以利用 MySQL 自带的 slow_query_log 来监控慢 SQL，它是 MySQL 提供的一个日志功能，用于记录执行时间超过特定阈值的 SQL 语句。
对于慢查询，再使用 EXPLAIN 分析执行计划，查看查询的执行顺序、使用的索引、扫描的行数等，以识别潜在的性能瓶颈。
基于 EXPLAIN 再进行针对性的优化，常见的优化方向有：
- 根据 EXPLAIN 的结果，检查是否有合适的索引。若缺失索引，则添加（特别是在 WHERE、JOIN 和 ORDER BY 子句中使用的列上）
- 将复杂的 JOIN 查询拆分成多个简单查询，尽量小表驱动大表
- 避免 SELECT * ，仅选择需要的字段

### [MySQL和Redis的区别？](https://notes.kamacoder.com/questions/500098)
#### 简要回答

1. **数据存储方式**：
	- MySQL是关系型数据库，支持持久化存储。
	- Redis是内存数据存储系统，主要用于缓存，支持持久化选项。
2. **数据结构**：
	- MySQL使用表结构存储数据，支持复杂的查询和关系。
	- Redis支持丰富的数据结构，如字符串、列表、集合、哈希等。
3. **性能**：
	- MySQL性能较低，主要依赖磁盘I/O，适合持久化存储和复杂查询。
	- Redis性能非常高，数据保存在内存中，适合高频次的数据访问和缓存。
4. **适用场景**：
	- MySQL适合数据持久化、事务处理、复杂查询。
	- Redis适合缓存、排行榜、消息队列、实时数据处理等。
### [Redis有什么优缺点？为什么用Redis查询会比较快？](https://notes.kamacoder.com/questions/500099)
#### 简要回答

1. **优点**：
	- **高速**：数据存储在内存中，访问速度快。
	- **支持丰富的数据结构**：如字符串、列表、哈希、集合等。
	- **支持持久化**：可以将内存数据持久化到磁盘。
	- **分布式支持**：支持集群部署，具有高可用性。
2. **缺点**：
	- **内存消耗大**：数据量过大会占用大量内存，导致成本上升。
	- **数据持久化有限**：虽然支持持久化，但不能保证完全持久性，存在丢失数据的风险。
	- **不适合复杂查询**：仅能存储和查询简单数据，复杂查询性能不佳。
3. **查询速度快原因**：
	- Redis基于内存存储，读写速度远高于基于磁盘的数据库。
	- 操作简单、直接且优化良好，查询无需复杂的联接或计算。
### [Redis的数据类型有那些？](https://notes.kamacoder.com/questions/500100)
#### 简要回答

1. **字符串（String）**：最简单的数据类型，可以存储文本、数字、二进制数据等。
2. **列表（List）**：链表结构，可以存储多个有序元素，支持插入、删除操作。
3. **集合（Set）**：无序集合，支持快速查找和去重。
4. **有序集合（Sorted Set）**：类似集合，但每个元素都有一个分数值，按分数排序。
5. **哈希（Hash）**：键值对集合，适用于存储对象。
6. **位图（Bitmap）**：操作二进制位，常用于统计、标记等。
7. **HyperLogLog**：用于进行基数估算，节省内存。
8. **地理空间（Geospatial）**：用于存储地理位置信息并进行范围查询。
### [Redis是单线程的还是多线程的，为什么？](https://notes.kamacoder.com/questions/500101)
#### 简要回答

Redis是**单线程**的。它通过事件循环模型和非阻塞I/O操作来处理高并发请求，避免了多线程切换的开销。


----
#### 详细回答

1. **单线程设计**：
	- Redis的核心是单线程的，即所有的命令请求通过一个线程处理。它并发处理多个请求的能力来源于**I/O多路复用**（事件驱动模型）和**非阻塞I/O**机制。
	- Redis通过`select()`或`epoll()`等机制，使用一个线程处理多个连接，避免了多线程环境下的上下文切换和锁竞争，提高了性能。
2. **为什么选择单线程**：
	- **避免上下文切换开销**：多线程处理时需要频繁地切换上下文，这会带来额外的性能消耗，而Redis通过单线程避免了这个问题。
	- **并发控制简单**：由于Redis是单线程的，所以不需要在不同线程间加锁、同步，避免了多线程编程的复杂性。
	- **高效的I/O多路复用**：Redis利用高效的I/O复用技术来实现高并发处理，单线程足以应对大部分应用场景。
3. **如何实现高并发**：
	- **事件驱动模型**：Redis通过事件驱动模型在一个线程中处理多个客户端请求，并通过非阻塞I/O实现并发处理。每个请求都会在事件循环中以非阻塞方式轮询执行，从而避免了多线程的同步问题。
	- **管道化（Pipelining）**：Redis允许将多个命令批量发送到服务器，不需要等待每个命令的返回结果，从而提高吞吐量。
4. **瓶颈和扩展**：
	- 尽管单线程设计使得Redis在大部分情况下性能优越，但当请求的复杂度过高，或遇到需要CPU密集型的任务时，Redis的性能可能会受到影响。为了应对这一问题，Redis支持通过**多节点集群**和**分片**来水平扩展。


----
#### 延伸问答

1. **多线程Redis实现**：
	- Redis 6.x引入了**多线程IO模型**，但是仍然是**单线程**处理核心业务逻辑。多线程主要用于**处理网络IO**，如客户端连接的读取和写入，进一步提升了Redis的性能，但核心命令仍然是单线程执行。
2. **与多线程框架对比**：
	- 单线程模式适用于**I/O密集型**操作，而多线程框架适用于**CPU密集型**操作。在Redis中，I/O密集型操作（如查询、写入）远远多于CPU密集型操作，因此单线程在这种场景下更加高效。
### [Redis持久化机制有哪些？](https://notes.kamacoder.com/questions/500102)
1. RDB：快照文件，把redis内存存储的数据写到磁盘上，当redis宕机需要恢复数据时，从RDB快照文件中恢复数据
2. AOF：追加文件，当redis执行写操作时，将每次操作存入这个文件中，当redis宕机恢复数据时，从这个文件中再次执行一遍。
### [缓存雪崩、击穿、穿透和解决办法？](https://notes.kamacoder.com/questions/500103)
##### 缓存雪崩
- **定义**：**大量缓存数据**同时失效，大量请求直击数据库，致数据库压力过大甚至崩溃。
- **解决办法**：
	- 缓存过期时间随机化，避免大量数据同时过期。
	- 热点数据永不过期或设置较长过期时间。
	- 缓存预热，提前加载热点数据。
	- 降级限流，保护数据库。
	- 构建高可用缓存集群。

##### 缓存击穿
- **定义**：**热点 key 缓存**突然失效，大量并发请求直击数据库。
- **解决办法**：
	- 热点数据永不过期。
	- 使用**互斥锁或分布式锁**，控制并发访问数据库。

### 缓存穿透
- **定义**：请求数据在缓存和数据库中**均不存在**，大量此类请求致数据库压力增大。
- **解决办法**：- 缓存空对象，对查询不到的数据在缓存中存空值并设置短过期时间。
	- 使用**布隆过滤器**，提前判断数据是否存在，不存在则直接拦截请求。
### [如何保证数据库和缓存的一致性？](https://notes.kamacoder.com/questions/500104)
##### 先更新数据库，再更新缓存
- **优点**：操作相对简单直接，**适用于对缓存实时性要求极高**的场景。
- **缺点**：若缓存更新失败，会导致数据库和缓存数据不一致。而且在高并发场景下，可能会出现多次更新缓存的情况，增加系统开销。

##### 先更新数据库，再删除缓存
- **优点**：相比更新缓存，删除缓存操作更简单，不易出现更新不一致的问题。在高并发场景下，只有在数据真正发生变化时才需要删除缓存，减少了缓存更新的频率和开销。
- **缺点**：可能存在缓存删除失败的情况，导致数据库和缓存不一致。

##### 先删除缓存，再更新数据库
- **优点**：可以避免在更新数据库过程中，其他请求读取到旧的缓存数据。
- **缺点**：如果在删除缓存后，更新数据库之前，有其他请求访问缓存并发现缓存不存在，从而去数据库中读取旧数据并写入缓存，就会导致数据不一致。

##### 借助消息队列
- **优点**：通过消息队列异步更新缓存，降低数据库和缓存更新操作的耦合度，提高系统的吞吐量和响应速度。同时，消息队列可以保证消息的可靠传递和顺序性，有助于保证数据的一致性。
- **缺点**：引入消息队列增加了系统的复杂性和维护成本，需要考虑消息队列的可靠性、性能和消息的积压等问题。

##### 采用分布式事务
- **优点**：可以保证数据库和缓存操作的原子性，即要么同时成功，要么同时失败，从根本上解决数据一致性问题。
- **缺点**：实现分布式事务的技术较为复杂，性能开销较大，可能会影响系统的整体性能和吞吐量。

##### 使用数据库的事务日志
- **优点**：通过监听数据库的事务日志，可以实时获取数据库的变更情况，并根据变更情况及时更新缓存，保证缓存与数据库的一致性。
- **缺点**：需要对数据库的事务日志进行解析和处理，实现较为复杂，并且对数据库的性能有一定的影响。


实际应用中通常会根据具体业务场景和系统架构选择合适的方案，有时会结合多种方法来确保数据库和缓存的一致性。
### [解释一下数据库的三大范式？](https://notes.kamacoder.com/questions/500105)
##### 第一范式（1NF）
- **定义**：数据库表的每一列都是不可分割的原子数据项，不能有多个值在同一列中。即要求表中的每一个属性都是不可再分的基本数据项。
- **示例**：如一个 “学生信息” 表，其中 “联系方式” 列不能同时包含手机号码和家庭电话号码等多个值，而应将它们拆分成 “手机号码” 和 “家庭电话号码” 两个列，以满足第一范式。

### 第二范式（2NF）
- **定义**：在满足第一范式的基础上，非主属性完全依赖于主键，不能部分依赖于主键的一部分。即要求表中的每一个非主属性都完全函数依赖于主键。
- **示例**：假设存在一个 “订单信息” 表，主键为 “订单编号”，表中有 “商品编号”“商品名称”“商品价格”“订单日期” 等列。其中 “商品名称” 和 “商品价格” 只与 “商品编号” 有关，而与 “订单编号” 并无直接关系，这就**出现了部分依赖，不满足第二范式**。应将 “商品编号”“商品名称”“商品价格” 这些列单独提取出来组成一个 “商品信息” 表，而在 “订单信息” 表中只保留 “订单编号”“商品编号” 和 “订单日期” 等列。

### 第三范式（3NF）
- **定义**：在满足第二范式的基础上，任何非主属性不传递依赖于主键。即要求表中的每一个非主属性都不传递函数依赖于主键。
- **示例**：假设有一个 “学生课程成绩” 表，主键为 “学号 + 课程编号”，表中有 “学生姓名”“课程名称”“成绩” 等列。其中 “学生姓名” 依赖于 “学号”，而 “学号” 又通过 “学号 + 课程编号” 这个主键与其他列相关联，**这就出现了传递依赖，不满足第三范式**。应将 “学生姓名” 等学生基本信息提取出来组成一个 “学生信息” 表，将 “课程名称” 等课程基本信息提取出来组成一个 “课程信息” 表，而在 “学生课程成绩” 表中只保留 “学号”“课程编号” 和 “成绩” 等列。
### [什么是数据库的锁？有哪些类型？](https://notes.kamacoder.com/questions/500106)
##### 按锁的粒度划分
- **行级锁**
	- **定义**：对数据库中的一行数据进行锁定，粒度最细，并发度最高。
	- **示例**：在 MySQL 的 InnoDB 存储引擎中，使用`SELECT... FOR UPDATE`语句可以对查询结果集中的行进行行级锁定，以防止其他事务对这些行进行修改。
- **表级锁**
	- **定义**：对整个数据表进行锁定，粒度最粗，并发度最低，但实现简单，开销较小。
	- **示例**：在 MySQL 的 MyISAM 存储引擎中，执行`LOCK TABLES table_name READ/WRITE`语句可以对指定的表进行读锁或写锁锁定，在锁定期间，其他事务无法对该表进行读写操作。
- **页级锁**
	- **定义**：对数据库中的一页数据进行锁定，页是数据库中存储数据的基本单位，通常为 8KB 或 16KB 等，其粒度介于行级锁和表级锁之间。
	- **示例**：在 SQL Server 中，当执行某些查询或更新操作时，可能会自动使用页级锁来锁定包含目标数据的页。

##### 按锁的模式划分
- **共享锁（S 锁）**
	- **定义**：又称为读锁，多个事务可以同时获取同一个数据对象的共享锁，用于对数据进行只读操作，不会阻塞其他事务的读操作，但会阻塞其他事务的写操作。
	- **示例**：在 MySQL 中，使用`SELECT... LOCK IN SHARE MODE`语句可以对查询结果集添加共享锁，允许其他事务同时对同一数据进行读操作。
- **排他锁（X 锁）**
	- **定义**：又称为写锁，一个事务获取了某数据对象的排他锁后，其他事务既不能对该数据对象进行读操作，也不能进行写操作，直到该事务释放排他锁。
	- **示例**：在 MySQL 中，执行`INSERT`、`UPDATE`、`DELETE`等写操作时，会自动对操作涉及的数据对象添加排他锁。
- **更新锁（U 锁）**
	- **定义**：一种特殊的锁，用于解决在更新操作过程中的并发问题，允许并发事务对同一数据对象进行读操作，但在更新时会将更新锁升级为排他锁，以确保数据的一致性。
	- **示例**：在 SQL Server 中，当执行`UPDATE`语句时，事务首先会获取更新锁，在读取数据时允许其他事务获取共享锁进行读操作，但在实际进行更新时会将更新锁升级为排他锁。

### 按锁的使用方式划分
- **乐观锁**
	- **定义**：假设在事务处理过程中不会发生冲突，在提交事务时才检查数据是否被其他事务修改过，如果没有修改则提交成功，如果被修改则需要根据具体情况进行处理，通常采用版本号或时间戳等机制来实现。
	- **示例**：在 MySQL 中，可以在表中添加一个`version`字段，每次更新数据时将`version`字段的值加 1，在更新数据时检查当前版本号与查询时的版本号是否一致，如果一致则更新成功，否则说明数据已经被其他事务修改过，需要重新处理。
- **悲观锁**
	- **定义**：假设在事务处理过程中一定会发生冲突，因此在事务开始时就对需要操作的数据进行锁定，直到事务结束才释放锁，以确保数据的一致性和完整性。
	- **示例**：在 MySQL 中，使用`SELECT... FOR UPDATE`语句就是一种悲观锁的实现方式，它会对查询结果集中的行进行锁定，直到事务结束才释放锁。
### [MySQL中的InnoDB引擎是如何实现事务的？](https://notes.kamacoder.com/questions/500107)
MySQL 主要是通过：锁、Redo Log 、Undo Log、MVCC 来实现事务。
- 锁（行锁、间隙锁等等）机制，使用数据并发修改的控制，满足事务的隔离性。
- Redo Log（重做日志），它会记录事务对数据库的所有修改，在崩溃时恢复未提交的更改，用来满足事务的持久性。
- Undo Log（回滚日志），它会记录事务的反向操作，简单地说就是保存数据的历史版本，用于事务的回滚，使得事务执行失败之后可以恢复之前的样子。实现原子性和隔离性
- MVCC（多版本并发控制），满足了非锁定读的需求，提高了并发度，实现了读已提交和可重复读两种隔离级别，实现了事务的隔离性。

### [解释一下SQL中的JOIN操作？](https://notes.kamacoder.com/questions/500108)
SQL 中的 JOIN 操作用于将两个或多个表中的行按照一定的条件进行组合，以便从多个相关表中获取更全面的数据，主要有以下几种类型：

##### INNER JOIN（内连接）
- **定义**：返回两个表中满足连接条件的行的组合，即只返回在两个表中都存在匹配记录的行。
- **语法**：`SELECT * FROM table1 INNER JOIN table2 ON table1.column = table2.column;`
- **示例**：假设有 “orders” 表和 “customers” 表，“orders” 表中有 “customer_id” 列，“customers” 表中有 “id” 列和 “customer_name” 列，要获取每个订单对应的客户名称，可以使用内连接：`SELECT orders.order_id, customers.customer_name FROM orders INNER JOIN customers ON orders.customer_id = customers.id;`

##### LEFT JOIN（左连接）
- **定义**：返回左表中的所有行以及右表中满足连接条件的行。如果右表中没有匹配的行，则对应的列值为 NULL。
- **语法**：`SELECT * FROM table1 LEFT JOIN table2 ON table1.column = table2.column;`
- **示例**：要获取所有客户及其对应的订单信息，如果某个客户没有订单，也要显示该客户的信息，可以使用左连接：`SELECT customers.customer_name, orders.order_id FROM customers LEFT JOIN orders ON customers.id = orders.customer_id;`

##### RIGHT JOIN（右连接）
- **定义**：与左连接相反，返回右表中的所有行以及左表中满足连接条件的行。如果左表中没有匹配的行，则对应的列值为 NULL。
- **语法**：`SELECT * FROM table1 RIGHT JOIN table2 ON table1.column = table2.column;`
- **示例**：假设 “products” 表中有 “category_id” 列，“categories” 表中有 “id” 列和 “category_name” 列，要获取所有产品类别及其对应的产品信息，如果某个类别没有产品，也要显示该类别的信息，可以使用右连接：`SELECT categories.category_name, products.product_name FROM products RIGHT JOIN categories ON products.category_id = categories.id;`

##### FULL OUTER JOIN（全外连接）
- **定义**：返回两个表中的所有行，当某一行在另一个表中没有匹配行时，对应的列值为 NULL。
- **语法**：`SELECT * FROM table1 FULL OUTER JOIN table2 ON table1.column = table2.column;`
- **示例**：在某些数据库中不直接支持全外连接，但可以通过左连接和右连接的[并集](coco://sendMessage?ext=%7B%22s%24wiki_link%22%3A%22https%3A%2F%2Fm.baike.com%2Fwikiid%2F2600184162314167874%22%7D)来实现。例如，在 MySQL 中可以使用`SELECT * FROM table1 LEFT JOIN table2 ON table1.column = table2.column UNION SELECT * FROM table1 RIGHT JOIN table2 ON table1.column = table2.column WHERE table1.column IS NULL;`

##### CROSS JOIN（交叉连接）
- **定义**：返回两个表中所有行的笛卡尔积，即第一个表中的每一行与第二个表中的每一行进行组合，不使用任何连接条件。
- **语法**：`SELECT * FROM table1 CROSS JOIN table2;`
- **示例**：如果 “employees” 表中有 3 行数据，“departments” 表中有 4 行数据，那么`SELECT * FROM employees CROSS JOIN departments;`将返回 12 行数据，是两个表行数的乘积。
### [什么是数据库的索引？为什么要使用索引？](https://notes.kamacoder.com/questions/500109)
数据库索引是一种特殊的数据结构，由表中的一列或多列组合而成，类似书籍目录，可帮助数据库系统快速定位和访问表中的数据。使用索引的原因主要有：

- **提升查询效率**：避免全表扫描，快速定位所需数据行，尤其在大型表和复杂查询中效果显著。
- **确保数据唯一**：创建唯一索引可保证列中数据值的唯一性，维护数据完整性。
- **助力排序分组**：利用索引的顺序性，快速完成排序和分组操作，无需额外排序处理。
- **优化连接操作**：在多表连接查询时，帮助快速定位连接条件中涉及列的值，加快连接速度。
### [MySQL中的查询优化器是如何工作的？](https://notes.kamacoder.com/questions/500110)
##### 语法分析和语义检查
- **词法分析**：将输入的 SQL 查询语句分解成一个个的单词，如关键字、标识符、常量、运算符等，识别出每个单词的类型和值。
- **语法分析**：根据 MySQL 的语法规则，对词法分析得到的单词序列进行语法结构分析，构建出一棵语法树，以表示查询语句的语法结构。
- **语义检查**：对语法树进行语义分析，检查查询语句中的表名、列名、数据类型、函数调用等是否正确和合法，确保查询语句在语义上是正确的。

#####  查询重写
- **子查询优化**：将一些复杂的子查询转换为更高效的连接查询或其他形式，以提高查询效率。例如，将嵌套的子查询展开为连接操作，或者将相关子查询转换为非相关子查询等。
- **表达式简化**：对查询语句中的表达式进行简化和优化，如常量表达式的计算、函数的化简、逻辑表达式的优化等，减少不必要的计算和操作。
- **视图展开**：如果查询涉及到视图，会将视图的定义展开到查询语句中，以便进行更全面的优化和执行计划的选择。

#####  路径选择和成本估算
- **生成可能的执行计划**：根据查询语句和数据库的统计信息，生成多种可能的执行计划。这些执行计划包括不同的表连接顺序、索引的使用方式、数据访问方法等。
- **成本估算**：对每个生成的执行计划进行成本估算，成本估算模型会考虑多种因素，如磁盘 I/O 操作次数、CPU 使用时间、内存使用量等，以评估每个执行计划的执行成本。
- **选择最优执行计划**：根据成本估算的结果，选择成本最低的执行计划作为最终的执行方案。在选择最优执行计划时，还会考虑一些其他因素，如查询的优先级、系统资源的使用情况等。

##### 执行计划生成和执行
- **执行计划生成**：根据选择的最优执行计划，生成具体的执行指令序列，这些执行指令序列将指导数据库引擎如何执行查询操作。
- **执行计划执行**：将生成的执行计划提交给数据库引擎进行执行，数据库引擎按照执行计划中的指令序列依次执行各个操作，如读取表数据、应用索引、进行连接操作、计算表达式等，最终返回查询结果。
### [解释一下数据库的视图和存储过程？](https://notes.kamacoder.com/questions/500111)
##### 视图
- **定义**：视图是从一个或多个表（或其他视图）中导出的虚拟表，它本身不包含实际的数据，而是基于查询语句的结果集动态生成的数据呈现。视图就像是一个窗口，通过它可以看到数据库中特定的数据[子集](coco://sendMessage?ext=%7B%22s%24wiki_link%22%3A%22https%3A%2F%2Fm.baike.com%2Fwikiid%2F3858292080688195142%22%7D)，而不需要直接访问底层的表。
- **作用**
	- **简化复杂查询**：对于复杂的多表连接查询或嵌套查询，如果经常需要执行相同的查询操作，可以将其定义为视图。这样，用户在使用时只需查询视图，而无需编写复杂的查询语句，大大简化了查询操作。例如，在一个包含学生、课程和成绩的数据库中，创建一个视图来显示每个学生的平均成绩，用户可以直接查询该视图获取所需信息，而不必每次都编写连接查询语句。
	- **数据安全性和保密性**：可以通过视图来限制用户对敏感数据的访问。只允许用户访问视图，而不直接授予对底层表的访问权限，从而隐藏了底层表的结构和敏感数据，提高了数据的安全性。例如，在员工数据库中，创建一个视图只显示员工的基本信息，而隐藏工资等敏感信息，不同权限的用户只能访问相应的视图。
	- **提供逻辑独立性**：当数据库的表结构发生变化时，如果涉及到的查询操作是通过视图进行的，那么只需要修改视图的定义，而不需要修改使用该视图的应用程序代码，从而降低了数据库维护的难度和成本。

##### 存储过程
- **定义**：存储过程是一组预编译的 SQL 语句和逻辑控制语句的集合，它们被存储在数据库中，可作为一个独立的单元被调用和执行，通常用于完成特定的数据库操作任务，如数据的插入、更新、删除、查询等，以及复杂的业务逻辑处理。
- **作用**
	- **提高性能**：存储过程在第一次执行时会被编译并存储在数据库的缓存中，后续再次调用时可以直接从缓存中执行，而不需要再次编译，从而减少了编译时间，提高了执行效率。对于频繁执行的复杂业务逻辑，使用存储过程可以显著提高系统的性能。
	- **封装业务逻辑**：可以将复杂的业务逻辑封装在存储过程中，使得数据库操作与业务逻辑分离。这样，应用程序只需要调用存储过程，而不需要了解具体的数据库操作细节，提高了代码的可维护性和可读性。例如，在一个订单处理系统中，创建一个存储过程来处理订单的创建、库存的更新、客户信息的验证等一系列操作，应用程序只需调用该存储过程即可完成订单处理业务。
	- **增强数据安全性**：通过存储过程，可以对数据库的访问进行更严格的控制。只允许用户通过存储过程来访问和操作数据库，而不直接授予对表的访问权限，从而减少了因用户误操作或恶意操作导致的数据安全风险。
	- **便于代码复用**：存储过程可以在不同的应用程序或不同的模块中被重复调用，避免了重复编写相同的 SQL 语句和业务逻辑，提高了代码的复用性和开发效率。
### [什么是数据库的分片和分区？有什么区别？](https://notes.kamacoder.com/questions/500112)
##### 数据库分片
- **定义**：是一种将大型数据库水平分割成多个较小的、逻辑上相互独立的部分的技术，每个部分称为一个分片，这些分片可以分布在不同的服务器或存储设备上。
- **作用**
	- **解决数据量过大问题**：当数据库中的数据量增长到单个服务器难以处理的程度时，通过分片可以将数据分散到多个服务器上，从而实现数据的水平扩展，提高系统的存储和处理能力。
	- **提升性能和可扩展性**：每个分片可以独立地进行数据读写操作，减少了单个服务器的负载，提高了系统的并发处理能力和整体性能。同时，随着业务的发展和数据量的增加，可以方便地添加新的分片服务器来进一步扩展系统。
	- **优化数据分布**：可以根据业务规则或数据的特点将数据合理地分配到不同的分片上，例如按照地域、用户类型、业务模块等进行分片，使得数据的访问更加高效。

##### 数据库分区
- **定义**：是将一个大型数据库表在物理上分割成多个较小的、独立的部分，每个部分称为一个分区，这些分区仍然存储在同一个数据库服务器上，但在逻辑上和物理上都相对独立。
- **作用**
	- **提高查询性能**：通过将表按照特定的规则进行分区，如按照时间范围、数值范围等，查询时可以只扫描与查询条件相关的分区，而不需要扫描整个表，从而大大减少了查询的数据量，提高了查询效率。
	- **便于数据管理和维护**：对于大型表，分区可以使得数据的管理更加方便。例如，可以分别对不同的分区进行备份、恢复、优化等操作，而不会影响其他分区的数据。同时，当需要删除或清理旧数据时，也可以直接删除相应的分区，操作更加简单快捷。
	- **优化存储结构**：根据数据的访问频率和存储特点，可以将不同的分区存储在不同的存储介质上，如将经常访问的数据分区存储在高速磁盘上，将不经常访问的数据分区存储在低速磁盘上，从而优化存储结构，提高存储效率。

##### 数据库分片和分区的区别
|区别点|分片|分区|
|:-:|:-:|:-:|
|数据分布方式|数据分散在多个不同的服务器或存储设备上|数据在同一个服务器上的不同物理区域内划分|
|扩展方式|通过添加更多的服务器或存储设备来实现水平扩展|主要是在单台服务器内部进行优化，通过增加分区来更好地组织数据，但服务器资源有限|
|应用场景|主要用于应对超大规模的数据存储和高并发访问，如大型互联网公司的用户数据、订单数据等|适用于单表数据量较大，但还未达到需要多服务器存储的情况，如按时间分区存储日志数据|
|管理复杂度|管理相对复杂，需要考虑数据在多个节点之间的一致性、分布式事务等问题|管理相对简单，主要是在单台服务器上对不同分区进行管理|
|性能优化侧重点|侧重于通过分布式处理提高并发性能和整体处理能力|侧重于通过减少单个查询的数据|
### [MySQL中的触发器是什么？如何使用？](https://notes.kamacoder.com/questions/500113)
MySQL 中的触发器是一种特殊的存储过程，它与表紧密相关，**当特定的数据库操作（如 INSERT、UPDATE、DELETE）在指定的表上执行时，触发器会自动被触发并执行相应的操作**。
##### 触发器的作用
- **数据一致性维护**：在对表进行数据修改操作时，通过触发器可以自动对其他相关表进行相应的修改，以确保数据的一致性。例如，在一个订单管理系统中，当插入一条新的订单记录时，触发器可以自动在库存表中减少相应商品的库存数量，确保订单数据和库存数据的一致性。
- **数据完整性约束补充**：除了表定义中的约束条件外，触发器可以进一步对数据的完整性进行约束。例如，限制在某个时间段内只能插入特定类型的数据，或者在更新数据时检查数据的合法性等。
- **审计和日志记录**：可以利用触发器记录对表的操作历史，便于审计和跟踪数据的变化。例如，在员工表上创建一个触发器，每当有员工数据被更新时，将更新前后的数据记录到一个审计表中，方便后续查看和分析员工数据的变更情况。

---

##### 触发器的创建语法
```
CREATE TRIGGER trigger_name
    -- 触发时机：可以是BEFORE或AFTER
    BEFORE|AFTER INSERT|UPDATE|DELETE
    ON table_name FOR EACH ROW
    -- 触发器执行的语句块
    BEGIN
        -- 具体的SQL语句
       ...
    END;
```

- `trigger_name`：自定义的触发器名称，在数据库中必须是唯一的。
- `BEFORE|AFTER`：指定触发器的触发时机，`BEFORE`表示在触发事件之前执行触发器中的代码，`AFTER`表示在触发事件之后执行。
- `INSERT|UPDATE|DELETE`：指定触发事件，即哪种数据库操作会触发该触发器。
- `table_name`：指定与触发器关联的表名。
- `FOR EACH ROW`：表示对于每一行受触发事件影响的记录，触发器都会执行一次。

---

##### 使用注意事项
- **语法错误检查**：在创建触发器时，要仔细检查语法错误，因为触发器中的 SQL 语句一旦出现错误，可能会导致整个触发操作失败，甚至影响到相关的数据库操作。
- **性能影响**：过多或过于复杂的触发器可能会对数据库的性能产生一定的影响，特别是在高并发的情况下。因此，在使用触发器时，要确保其逻辑简洁高效，避免不必要的复杂操作。
- **数据一致性维护**：虽然触发器可以帮助维护数据一致性，但在设计和使用时要特别小心，避免出现死循环或数据不一致的情况。例如，在两个相互关联的表上设置的触发器，如果逻辑不当，可能会导致数据在更新时陷入无限循环。
### [解释一下数据库的主从复制和读写分离？](https://notes.kamacoder.com/questions/500114)
**主从复制**指的是将数据库中的数据从主库（Master）复制到一个或多个从库（Slave）。主库负责处理所有的写操作（如插入、更新、删除），而从库则负责处理读操作（如查询）。这种架构的优势在于：
1. **提高数据可用性**：如果主库发生故障，从库可以迅速接管，减少系统的停机时间。
2. **负载均衡**：通过将读操作分散到多个从库，减轻主库的压力，提高整体系统的处理能力。
3. **数据备份**：从库可以作为数据备份的一部分，增强数据的安全性。

**读写分离**是基于主从复制的一种进一步优化策略，将数据库的读操作和写操作分离到不同的服务器上。具体来说：
- **写操作**（如新增、修改、删除数据）统一由主库处理，确保数据的一致性和完整性。
- **读操作**（如数据查询）则由一个或多个从库处理，提升读取性能并减少主库的负担。

这种分离策略带来的好处包括：
1. **性能提升**：通过分散读写请求，系统整体响应速度更快，尤其在读操作频繁的场景下效果显著。
2. **扩展性强**：可以通过增加从库的数量来水平扩展系统，适应更大的访问量。
3. **提高系统稳定性**：读写分离减少了主库的压力，降低了主库因高负载而导致的宕机风险。
### [什么是数据库的事务日志？有什么作用？](https://notes.kamacoder.com/questions/500115)
数据库的事务日志是数据库管理系统中用于记录数据库事务操作的一种文件或数据结构，它详细记录了数据库中所有事务的开始、结束以及对数据的修改等信息，是数据库恢复和数据完整性保证的重要机制，以下是其主要作用：
##### 数据恢复
- **事务回滚**：当事务执行过程中出现错误或需要撤销时，事务日志可以用于回滚该事务，将数据库恢复到事务开始之前的状态。通过日志中记录的事务操作的逆操作，可以撤销对数据的修改，保证数据的一致性。
- **系统故障恢复**：在数据库系统发生故障，如断电、软件崩溃等情况后，数据库可能处于不一致的状态。事务日志可以帮助数据库管理系统在重新启动时，根据日志中的记录，将已提交的事务重新执行一遍，将未提交的事务进行回滚，从而使数据库恢复到故障前的一致状态。

##### 数据完整性保证
- **原子性保证**：事务日志确保了事务的原子性，即一个事务中的所有操作要么全部成功提交，要么全部回滚。在事务执行过程中，每一个操作都会被记录到日志中，只有当事务中的所有操作都成功记录到日志并且日志被成功写入磁盘后，事务才会被提交。如果在事务执行过程中出现故障，未完成的事务可以通过日志回滚，保证了事务的原子性。
- **一致性维护**：通过记录事务对数据的修改操作，事务日志可以帮助数据库在任何时候都保持数据的一致性。在事务提交之前，数据库管理系统会检查事务日志，确保事务的执行不会导致数据违反任何完整性约束。如果发现可能导致数据不一致的情况，事务会被回滚，从而维护了数据的一致性。

##### 数据库复制与同步
- **主从复制**：在数据库的主从复制架构中，事务日志是实现数据同步的重要依据。主数据库将事务日志发送给从数据库，从数据库根据接收到的日志内容，在本地重新执行相同的事务操作，从而实现数据的复制和同步，保证主从数据库的数据一致性。
- **分布式数据库同步**：在分布式数据库系统中，不同节点之间的数据同步也依赖于事务日志。各个节点通过共享事务日志，了解其他节点的事务操作情况，并在本地进行相应的同步操作，确保整个分布式数据库系统的数据一致性。

##### 性能优化
- **检查点机制**：数据库管理系统会定期设置检查点，在检查点时刻，将当前内存中的数据页和事务日志中的已提交事务记录到磁盘上。这样在系统故障恢复时，只需要从最近的检查点开始恢复，而不需要扫描整个事务日志，大大提高了恢复效率，减少了系统停机时间。
- **日志缓冲优化**：为了减少事务日志写入磁盘的 I/O 操作次数，提高系统性能，数据库管理系统通常会设置日志缓冲。事务日志先写入日志缓冲，当缓冲满或达到一定条件时，再一次性将缓冲中的日志写入磁盘。通过合理设置日志缓冲的大小和写入策略，可以优化数据库的性能。
### [MySQL中的锁等待和死锁是什么？如何处理？](https://notes.kamacoder.com/questions/500116)
##### 锁等待
- **定义**：当一个事务请求的锁被其他事务持有，并且该锁不能立即被获取时，该事务就会进入锁等待状态，等待其他事务释放锁。例如，事务 A 对某一行数据执行了更新操作并持有了排他锁，此时事务 B 也试图对同一行数据进行更新操作，那么事务 B 就会进入锁等待状态，直到事务 A 释放排他锁。
- **产生原因**：主要是由于并发事务对相同资源的竞争导致的。当多个事务同时访问和修改相同的数据行、表或其他数据库资源时，如果这些事务请求的锁类型不兼容，就会导致锁等待。
- **处理方法**
	- **优化事务逻辑**：尽量减少事务的执行时间和范围，避免长时间持有锁。可以将大事务拆分成多个小事务，减少对资源的长时间占用，降低锁等待的概率。
	- **调整隔离级别**：根据应用的并发需求和数据一致性要求，合理选择事务隔离级别。例如，在一些对并发要求较高、数据一致性要求相对较低的场景下，可以适当降低隔离级别，减少锁的使用和锁等待的情况。
	- **使用合适的索引**：通过创建合适的索引，可以减少查询和更新操作需要扫描的数据量，从而减少锁的竞争和锁等待时间。

##### 死锁
- **定义**：指两个或多个事务在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续执行下去。例如，事务 A 持有资源 X 的锁，同时请求资源 Y 的锁；而事务 B 持有资源 Y 的锁，同时请求资源 X 的锁，这样事务 A 和事务 B 就陷入了死锁状态。
- **产生原因**：通常是由于多个事务的并发执行顺序不当，以及对资源的请求和锁定顺序不一致导致的。当多个事务之间形成了一个环形的锁等待关系时，就会发生死锁。
- **处理方法**
	- **设置超时时间**：可以通过设置`innodb_lock_wait_timeout`参数来指定一个事务等待锁的超时时间。当一个事务在等待锁的过程中超过了这个超时时间，就会自动回滚该事务，从而避免死锁的长时间持续。
	- **检测和解除死锁**：MySQL 会自动检测死锁的发生，并选择一个较小的事务进行回滚，以解除死锁。可以通过查看 MySQL 的错误日志来获取死锁的详细信息，包括涉及的事务、锁等待的资源等，以便进一步分析和优化应用程序的并发逻辑。
	- **优化数据库设计和应用程序逻辑**：在数据库设计阶段，要合理规划表结构和索引，避免复杂的关联查询和更新操作导致死锁。在应用程序开发过程中，要确保事务对资源的请求和锁定顺序保持一致，避免出现环形的锁等待关系。
### [解释一下数据库的隔离级别与锁的关系？](https://notes.kamacoder.com/questions/500117)
##### 读未提交（Read Uncommitted）
- **隔离级别特点**：在该隔离级别下，一个事务可以读取到另一个事务未提交的数据，这是隔离级别最低的一种，会导致脏读、不可重复读和幻读等问题。
- **锁的使用情况**：一般只使用了最基本的行级锁或表级锁来防止数据在写入时被其他事务破坏，但对于读取操作基本不进行加锁控制，所以事务可以直接读取到其他事务未提交的数据，因此可能会出现脏读现象。

##### 读已提交（Read Committed）
- **隔离级别特点**：一个事务只能读取到另一个事务已经提交的数据，避免了脏读问题，但可能会出现不可重复读和幻读问题。
- **锁的使用情况**：在事务读取数据时，会对读取的数据行加共享锁，以防止其他事务在读取期间对数据进行修改。当事务结束时，共享锁会立即释放。而对于写入操作，会使用排他锁，在写入期间阻止其他事务对同一数据行进行读写操作。这种锁机制保证了一个事务在读取数据时，不会读取到其他事务未提交的数据，但由于共享锁在读取后立即释放，所以在同一事务中再次读取同一数据行时，可能会读取到其他事务在这期间提交的新数据，从而导致不可重复读。

##### 可重复读（Repeatable Read）
- **隔离级别特点**：在同一个事务中，多次读取同一数据行的结果是一致的，解决了不可重复读问题，但仍可能出现幻读问题。
- **锁的使用情况**：在事务开始时，会对需要读取的数据行加共享锁，并且在整个事务期间，这些共享锁不会释放，直到事务结束。这就保证了在同一事务中，多次读取同一数据行时，不会受到其他事务对该数据行修改的影响，从而实现了可重复读。对于写入操作，同样使用排他锁，在写入期间阻止其他事务对同一数据行进行读写操作。在该隔离级别下，虽然可以保证同一数据行的可重复读，但由于其他事务可能会插入新的数据行，所以仍然可能出现幻读现象。

##### 可串行化（Serializable）
- **隔离级别特点**：这是最高的隔离级别，事务之间完全串行执行，不存在并发问题，能够有效避免脏读、不可重复读和幻读问题，但会严重影响系统的并发性能。
- **锁的使用情况**：在该隔离级别下，会对整个表或数据集加锁，无论是读取操作还是写入操作，都会对所涉及的表或数据集加排他锁，使得其他事务无法对该表或数据集进行任何操作，直到当前事务结束。这种加锁方式完全限制了并发访问，确保了事务之间的完全隔离，从而避免了所有并发问题，但由于其对并发的严格限制，在实际应用中通常只有在对数据一致性要求极高且并发量较小的情况下才会使用。
### [什么是数据库的连接池？为什么要使用连接池？](https://notes.kamacoder.com/questions/500118)
数据库连接池是一种用于**管理数据库连接**的技术，它在应用程序和数据库之间充当中间层，负责**创建、管理和分配数据库连接**，以下是关于数据库连接池的详细介绍以及使用它的原因：

##### 数据库连接池的定义
数据库连接池预先创建一定数量的数据库连接，并将这些连接保存在一个池中。当应用程序需要访问数据库时，它可以从连接池中获取一个可用的连接，而不是直接创建一个新的连接。当应用程序使用完连接后，它将连接返回给连接池，而不是关闭连接，连接池会对连接进行管理和维护，以便下次使用。

##### 使用数据库连接池的原因
1. **提高性能**
	- **减少连接创建和销毁的开销**：创建和销毁数据库连接是非常耗时的操作，尤其是在高并发的应用场景中。使用连接池可以预先创建一定数量的连接，当需要连接时直接从池中获取，避免了频繁创建和销毁连接所带来的性能开销，从而显著提高系统的响应速度和吞吐量。
	- **优化连接资源利用**：连接池可以根据应用程序的实际需求动态地分配和管理连接资源，使连接资源得到更合理的利用。在并发量较低时，连接池中的部分连接可以处于空闲状态，等待后续请求使用；在并发量较高时，连接池可以合理分配有限的连接资源，避免因连接不足而导致的请求等待或失败。
2. **增强系统稳定性**
	- **限制连接数量**：连接池可以设置最大连接数，限制应用程序对数据库连接的并发访问数量，防止因过多的连接请求导致数据库系统崩溃或性能下降。当连接池中的连接达到最大连接数时，后续的连接请求可以在连接池中等待，直到有空闲连接可用，从而避免了因连接数过多而对数据库造成的压力过大问题。
	- **自动管理连接**：连接池能够自动检测和回收异常或空闲时间过长的连接，确保连接的有效性和可用性。如果某个连接在使用过程中出现异常，连接池可以自动将其标记为不可用并进行回收，重新创建一个新的连接供应用程序使用。同时，连接池还可以定期清理空闲时间过长的连接，释放系统资源，避免资源浪费。
3. **简化编程和资源管理**
	- **统一管理连接**：连接池为应用程序提供了一种统一的方式来获取和释放数据库连接，使得应用程序不需要在每个数据库操作中都进行连接的创建和关闭操作，大大简化了编程的复杂性。开发人员只需要从连接池中获取连接，使用完毕后将连接返回给连接池即可，无需关心连接的具体创建和销毁过程，提高了代码的可读性和可维护性。
	- **便于资源监控和调优**：连接池通常提供了丰富的监控和管理功能，开发人员可以方便地查看连接池的使用情况，如当前连接数、空闲连接数、连接的使用时间等。通过这些监控信息，开发人员可以及时了解系统的运行状态，发现潜在的性能问题，并进行相应的调整和优化，如调整连接池的大小、优化连接的使用策略等。
### [MySQL中的全文索引是什么？如何使用？](https://notes.kamacoder.com/questions/500119)
MySQL 中的全文索引是一种特殊的索引类型，主要用于**在文本数据中进行快速的全文搜索**，以提高对大量文本内容进行关键词搜索的效率。

##### 创建全文索引
- **创建表时创建全文索引**：在使用`CREATE TABLE`语句创建表时，可以直接为指定的文本列添加全文索引。例如，创建一个名为`blog_posts`的表，其中`content`列用于存储文章内容，并为该列创建全文索引，示例代码如下：
```
CREATE TABLE blog_posts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    FULLTEXT(content)
);
```

- **在已存在的表上创建全文索引**：若表已经存在，可使用`ALTER TABLE`语句来添加全文索引。例如，为已有的`blog_posts`表的`content`列创建全文索引，示例代码如下：
```
ALTER TABLE blog_posts ADD FULLTEXT(content);
```

##### 使用全文索引进行搜索
- **基本语法**：使用`MATCH...AGAINST`语句进行全文搜索，基本语法格式如下：
```
SELECT * FROM table_name WHERE MATCH(column_name) AGAINST('search_term' [search_mode]);
```
其中，`table_name`是要进行搜索的表名，`column_name`是包含全文索引的列名，`search_term`是要搜索的关键词或短语，`search_mode`是搜索模式，可选值有`IN NATURAL LANGUAGE MODE`（默认模式，以自然语言的方式进行搜索和排序）、`IN BOOLEAN MODE`（布尔模式，提供更灵活的搜索控制）等。
- **自然语言模式搜索示例**：在`blog_posts`表中搜索包含关键词 “MySQL 优化” 的文章，示例代码如下：
```
SELECT * FROM blog_posts WHERE MATCH(content) AGAINST('MySQL优化');
```
- **布尔模式搜索示例**：在`blog_posts`表中搜索包含 “MySQL” 但不包含 “优化” 的文章，示例代码如下：
```
SELECT * FROM blog_posts WHERE MATCH(content) AGAINST('MySQL -优化' IN BOOLEAN MODE);
```

##### 全文索引的限制和注意事项
- **存储引擎支持**：在 MySQL 5.6 及以上版本中，InnoDB 和 MyISAM 存储引擎支持全文索引，但两者在功能和性能上可能存在一些差异。MyISAM 引擎对全文索引的支持更为成熟，但不支持事务和行级锁；InnoDB 引擎在支持事务和行级锁的同时，全文索引的功能也在不断完善。
- **字符集限制**：全文索引对字符集有一定的要求，一般要求使用支持全文索引的字符集，如 utf8mb4 等。如果使用不支持的字符集，可能会导致全文索引无法正常工作。
- **最小字长和停用词**：MySQL 全文索引有默认的最小字长限制，通常为 3 或 4 个字符，小于该长度的单词不会被索引。同时，MySQL 还定义了一组停用词，如 “a”“an”“the” 等常见的英语单词，这些停用词在索引和搜索时会被忽略。
- **索引更新**：当对包含全文索引的列进行数据更新、插入或删除操作时，全文索引需要相应地进行更新，这可能会带来一定的性能开销。在高并发的写入场景下，需要考虑全文索引更新对性能的影响。
### [解释一下数据库的悲观锁和乐观锁？](https://notes.kamacoder.com/questions/500120)
##### 悲观锁（Pessimistic Locking）：
- 假设会发生冲突，因此在操作数据之前就对数据加锁，确保其他事务无法访问该数据。常见于对数据一致性要求较高的场景。
- 实现方式：使用行级锁或表级锁，例如可以使用 SELECT ... FOR UPDATE 或 LOCK IN SHARE MODE 语句来加锁。
##### 乐观锁（Optimistic Locking）：
- 假设不会发生冲突，因此在操作数据时不加锁，而是在更新数据时进行版本控制或校验。如果发现数据被其他事务修改，则会拒绝当前事务的修改，需重新尝试。
- 实现方式：通常通过版本号或时间戳来实现，每次更新时检查版本号或时间戳是否一致。

### [什么是数据库的外键？有什么作用？](https://notes.kamacoder.com/questions/500121)
#### 简要回答

外键（Foreign Key）是指在一个表中，字段引用另一个表的主键。它用于确保数据的完整性和一致性，防止无效数据的插入。


----
#### 详细回答

1. **定义**：
	- 外键是一个表中的字段，它用于关联另一个表的主键。外键字段的值必须是关联表中已存在主键的值，或者为空。
	- 外键约束使得一个表的某一列（或多个列）指向另一个表的主键。
2. **作用**：
	- **维护数据一致性**：外键确保两个表之间的数据引用一致。比如，订单表中的用户ID字段应当引用用户表中的有效用户ID，避免插入无效的数据。
	- **参照完整性**：外键约束可以保证子表中的数据与父表中的数据保持一致。若父表的记录被删除或更新，子表的相关记录可以通过级联操作（如级联删除、更新）得到同步处理。
	- **防止无效数据**：通过外键，数据库可以防止插入不存在的引用数据。例如，订单表中的某个用户ID如果没有在用户表中找到对应的记录，就不能插入到订单表中。
3. **常见操作**：
	- **级联操作**：
		- **级联删除（ON DELETE CASCADE）**：当父表记录被删除时，子表中所有引用该记录的外键值都会被删除。
		- **级联更新（ON UPDATE CASCADE）**：当父表主键值更新时，子表中所有引用该主键的外键值也会更新。
	- **设置为NULL（ON DELETE SET NULL）**：当父表记录被删除时，子表中的外键值会被设置为NULL。
	- **不操作（ON DELETE RESTRICT）**：如果父表中某条记录还被子表引用，禁止删除父表中的该记录。


----
#### 延伸问答

1. **外键与主键的区别**：主键用于唯一标识表中的一行数据，而外键则是用来确保表之间数据的参照完整性，连接不同表的数据。
2. **外键的性能影响**：外键约束会增加数据库的管理和检查开销，尤其是在进行插入、更新或删除操作时，会增加额外的检查操作。因此，在高性能要求的系统中，外键有时会被禁用。
### [MySQL中的临时表是什么？如何使用？](https://notes.kamacoder.com/questions/500122)
#### 简要回答

临时表是用于临时存储数据的表，在会话结束或连接断开时自动删除。它可以加速复杂查询操作和数据处理，且仅对当前会话可见。


----
#### 详细回答

1. **定义**：
	- 临时表是一个仅在当前数据库**会话期间**存在的表。**当会话结束或连接断开时，临时表会自动删除**。
	- 临时表用于存储中间结果、临时数据或复杂查询的中间表。
2. **用途**：
	- 临时表可以**优化多次计算的查询**，例如分步查询或存储中间结果，避免重复计算。
	- 用于在复杂查询中处理临时数据，减小主数据库表的负担。
	- 临时表**对每个会话都是隔离的**，不同会话使用相同的表名不会产生冲突。

----
#### 延伸问答

1. **临时表与普通表的区别**：
	- **生命周期**：临时表在会话结束时自动删除，而普通表在数据库中永久存在。
	- **作用域**：临时表只在当前会话内可见，普通表对所有会话都可见。
2. **使用场景**：
	- 在需要进行多步查询和处理时，可以用临时表存储中间结果，提升查询效率。例如，数据分析、批量处理、复杂联接等场景。
3. **临时表存储引擎**：
	- 临时表默认使用 `MEMORY` 引擎，但如果内存不足，它也可以回退到 `InnoDB` 引擎。
### [解释一下数据库的索引覆盖和回表？](https://notes.kamacoder.com/questions/500123)
#### 简要回答

- **索引覆盖**指的是查询所需的所有列都能**通过索引直接获取**，无需访问数据表中的数据行。
- **回表**是指**查询需要的列不在索引中**，必须通过索引获取的数据行的ID，再去查询实际的数据表获取完整数据。
### [什么是数据库的行级锁和表级锁？有什么区别？](https://notes.kamacoder.com/questions/500124)
#### 简要回答
- **行级锁**：锁定数据库表中的某一行数据，允许其他事务访问表中未被锁定的行。
- **表级锁**：锁定整个数据表，阻止其他事务对表中的任何行进行修改或读取操作。

##### 区别
- **锁粒度**：
	- **行级锁**：锁定单行数据，**粒度小**。
	- 表级锁：锁定整个数据表，粒度大。
- **并发性**：
	- **行级锁**：多个事务可以并发处理不同的数据行，**提高并发性能。**
	- 表级锁：只能有一个事务对整个表进行操作，降低并发性能。
- **锁管理开销**：
	- **行级锁**：需要较多的资源来管理锁，因此**开销较大**。
	- 表级锁：锁管理较为简单，开销较小。
- **死锁风险**：
	- **行级锁**：由于锁粒度小，**容易引发死锁**。
	- 表级锁：死锁风险较低，因为锁住的是整个表。
### [MySQL中的慢查询日志是什么？如何使用？](https://notes.kamacoder.com/questions/500125)
#### 简要回答

- **慢查询日志**：记录**执行时间>设定阈值的SQL查询**，用于**分析数据库性能瓶颈**。
- **如何使用**：通过配置MySQL的`slow_query_log`、`long_query_time`等参数启用，并使用`mysqldumpslow`或`pt-query-digest`等工具分析。
### [解释一下数据库的并发控制和事务管理？](https://notes.kamacoder.com/questions/500126)
#### 简要回答

- **并发控制**：确保多个事务并发执行时，能保持数据库的正确性和一致性。常用技术有锁机制和隔离级别。
- **事务管理**：确保一组数据库操作作为一个整体执行，要么全部成功，要么全部失败。事务的ACID特性（原子性、一致性、隔离性、持久性）保证了这一点。
### [什么是数据库的数据字典？有什么作用？](https://notes.kamacoder.com/questions/500127)
##### 数据字典的定义
数据字典是数据库管理系统（DBMS）中存储所有元数据的仓库。元数据是描述数据库对象的数据，如表结构、列信息、数据类型、约束、索引、存储过程、触发器等。

##### 数据字典的作用
1. **存储数据库结构信息**：包括表、列、数据类型、索引、外键、视图、存储过程等信息。
2. **数据一致性保障**：确保数据库中各个对象之间的依赖关系、约束条件的一致性。
3. **权限管理**：用于存储用户权限，确保只有被授权的用户可以访问或修改特定的数据。
4. **优化查询**：帮助数据库优化器做出更好的查询决策，比如通过查看索引和表的统计信息来选择最优查询计划。
5. **数据库管理**：便于数据库管理员（DBA）维护和管理数据库，包括数据备份、恢复和迁移等。

##### 数据字典示例
在MySQL中，可以使用如下语句访问数据字典中的一些信息：
- 查询表结构：`DESCRIBE table_name;`
- 查询数据库中的所有表：`SHOW TABLES;`
- 查询表中的列信息：`SHOW COLUMNS FROM table_name;`

数据库字典通常存储在系统数据库中（如MySQL的`information_schema`数据库）。
### [MySQL中的表空间是什么？如何管理？](https://notes.kamacoder.com/questions/500128)
#### 简要回答

- **表空间**：表空间是MySQL用来存储数据库对象（如表、索引等）的物理存储区域。
- **管理**：通过`InnoDB`存储引擎的表空间管理，可以使用`innodb_file_per_table`选项控制每个表是否有单独的表空间。


----
#### 详细回答

##### 表空间的定义

表空间是指用于存储数据库表及其相关数据的逻辑存储区域。MySQL通过表空间来管理数据文件、表格、索引、以及其他数据库对象的存储。表空间的主要作用是将数据逻辑和物理存储解耦。
##### MySQL表空间的类型

1. **系统表空间**：InnoDB存储引擎中的默认表空间，用于存储所有数据库的共享数据。该表空间一般存储系统级的数据和内部数据结构，无法直接控制。
2. **独立表空间（Per-Table Tablespace）**：每个表都有自己的表空间，可以独立存储在不同的文件中。开启`innodb_file_per_table`选项时，每个表都会使用独立的表空间，便于管理和优化。
3. **临时表空间**：用于存储临时表数据，通常存储在内存中，但也可以存储在磁盘中，适用于大型临时操作（例如`JOIN`、`ORDER BY`）。

##### 表空间的管理

1. **启用`innodb_file_per_table`选项**：
	- 默认情况下，所有表数据都存储在系统表空间中。
	- 启用该选项后，每个表会有自己的表空间，便于管理和优化。
	```
	SET GLOBAL innodb_file_per_table = 1;
	```
	- 每个表的数据文件和索引文件将存储在数据库目录下，文件名通常以`.ibd`结尾。
2. **查看表空间状态**：
	- 查看当前表空间的状态：`SHOW TABLE STATUS`。
	- 查看InnoDB的表空间文件：`SHOW VARIABLES LIKE 'innodb_data_home_dir';`
3. **管理表空间的大小**：
	- 当表空间的大小超出一定限制时，可以考虑执行优化操作，如`OPTIMIZE TABLE`。
	- `ALTER TABLE`可以用来调整表的存储配置。
4. **回收空间**：
	- 通过删除不再需要的表或索引文件来回收表空间的空间。
	- 使用`DROP TABLE`删除表时，相关的`.ibd`文件会被移除。
5. **表空间文件操作**：
	- 如果需要，表空间文件可以移动或备份，但在操作之前需要先进行表的导出或备份。
	- 还可以使用`ALTER TABLE`将表从一个表空间移动到另一个表空间。
### [解释一下数据库的备份和恢复策略？](https://notes.kamacoder.com/questions/500129)
#### 简要回答

- **备份**：是指定期复制数据库的结构和数据，以防止数据丢失。
- **恢复**：是在数据库发生故障时，使用备份数据将数据库恢复到正常状态。
- **策略**：备份可以是全量备份、增量备份、差异备份等；恢复策略通常依赖于备份的类型和恢复目标。


----
#### 详细回答

##### 数据库备份类型

1. **全量备份**：- 备份整个数据库，包括所有表、数据、索引等。
	- 优点：备份简单，恢复过程快速。
	- 缺点：备份文件较大，消耗时间较长，可能影响生产环境性能。
2. **增量备份**：- 只备份自上次备份以来发生变化的数据。
	- 优点：节省存储空间和备份时间。
	- 缺点：恢复时需要依赖多个备份（最近的全量备份 + 所有增量备份），恢复过程复杂。
3. **差异备份**：- 备份自上次全量备份以来所有改变的数据。
	- 优点：比增量备份简单，恢复时只需要最近的全量备份和差异备份。
	- 缺点：随着时间推移，差异备份的数据量可能变大，备份时间增加。

##### 数据库恢复策略

1. **基于全量备份恢复**：
	- 恢复过程相对简单，只需恢复最近的全量备份。
	- 适用于数据丢失不严重的场景。
2. **基于增量备份恢复**：
	- 恢复过程中先恢复全量备份，然后按时间顺序应用增量备份。
	- 适用于定期做增量备份的情况，但恢复过程较为繁琐。
3. **基于时间点恢复（PITR）**：
	- 结合全量备份和增量备份，恢复数据库到某一具体时间点。
	- 适用于灾难恢复（例如用户误操作），可以恢复到故障发生前的状态。

##### 备份和恢复的最佳实践

1. **定期备份**：设定固定时间（如每日、每周）进行全量或增量备份。
2. **多重备份策略**：结合全量备份和增量备份，确保备份的灵活性和恢复的可靠性。
3. **自动化备份和监控**：使用备份工具（如`mysqldump`、`Percona XtraBackup`）自动化备份过程，并定期检查备份文件的完整性。
4. **备份文件存储**：将备份存储在不同的物理设备或云环境中，防止硬件故障导致备份文件丢失。
5. **测试恢复过程**：定期进行恢复演练，确保备份文件可以顺利恢复，并验证恢复后的数据完整性。
# Java
## Spring
### [Spring框架的核心组件有哪些？它们各自的作用是什么？](https://notes.kamacoder.com/questions/500528)
#### 简洁回答
Spring 框架的核心组件主要包括：
1. **Spring Core（核心容器）**： 提供了控制反转（IoC） 和依赖注入（DI）功能。
2. **Spring Context（应用上下文）**： 基于 Core 提供了框架式的 Bean 访问方式。
3. **Spring AOP（面向切面编程）**：实现了横切关注点的模块化。
4. **Spring MVC（模型-视图-控制器）**： 用于构建基于 Web 的应用程序，提供了请求处理、视图解析等功能。
5. **Spring DAO（数据访问对象）**： 简化了数据访问层的开发，提供了对 JDBC、ORM 的支持。
6. **Spring Expression Language（SpEL）**： 提供了强大的表达式语言，支持在运行时查询和操作对象。

---

#### 延申问答
- Spring Core（核心容器）相关
	- [x] IoC 和 DI 的核心思想？区别？
	- [x] Spring Bean 的生命周期？作用域？
	- [x] 如何通过注解实现 Bean 的装配？
- Spring Context（应用上下文）相关
	- [x] BeanFactory 和 ApplicationContext 的区别是什么？
	- [x] Spring 事件机制是如何工作的？
	- [x] 如何加载外部资源文件（如配置文件或国际化资源）？
- Spring AOP（面向切面编程）相关
	- [x] AOP 的核心概念？（切面、连接点、切入点、通知等）
	- [x] Spring AOP 的实现原理是什么？基于动态代理还是 CGLIB？
	- [x] AOP 的应用场景有哪些？
- Spring Expression Language（SpEL）相关
	- [x] SpEL 常用的操作有哪些？（属性访问、方法调用、集合操作等）
	- [x] 在项目中如何通过 SpEL 动态注入值？
	- [x] 实际场景中，SpEL 能解决哪些问题？
- Spring MVC（模型-视图-控制器）相关
	- [x] Spring MVC 的工作流程？
	- [x] 如何处理 JSON 格式的请求和响应？如何进行数据绑定？
	- [x] 如何通过注解实现 RESTful API？
- Spring DAO（数据访问对象）相关
	- [x] 什么是 `JdbcTemplate`？如何使用它简化数据库操作？
	- [x] Spring 是如何处理数据访问异常的？
	- [x] ORM 集成（如 Hibernate 或 JPA）的具体实现方式是什么？

### [解释Spring中的IoC（控制反转）原理，并举例说明。](https://notes.kamacoder.com/questions/500529)
#### 简洁回答
- **控制反转（Inversion of Control, IoC）【思想】：** 指将对象的创建、初始化及依赖管理的控制权从应用代码转移到 Spring 容器。
	- 传统方式： 对象由程序创建，依赖通过硬编码传递（代码写死而不是通过配置动态控制），高耦合。
	- IoC 方式： Spring 容器负责对象创建和依赖，模块之间只需要声明依赖，低耦合。
- **依赖注入（Dependency Injection, DI）【实现方式】：** 容器根据配置将所需的依赖注入到对象中。
	1. Setter 注入。
		- 适用于可选依赖的注入、自己开发的模块的注入
		- 如果只有Setter方法，没有注入，会导致null对象出现。
		- 配置`<bean>`用`<property>`标签的`value`或`ref`属性。
	2. 构造器注入（推荐）。
		- 适用于强制依赖的注入、第三方不含setter的模块的注入
		- 构造器注入结合 `@Qualifier` 或策略模式明确依赖关系，可以避免多个依赖注入混乱。
		- 配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性。
	3. 自动装配（不推荐）
		- 不推荐原因：隐式依赖关系导致的可测试性差和不易维护。具体来说，不能通过构造器或 setter 方法修改依赖关系，因为 Spring 会在创建 Bean 时自动完成依赖注入，测试代码无法显式地控制 Mock （模仿）对象的注入，只能使用 `@InjectMocks` 和 `@Mock` 等注解来让 Mockito 和 Spring 协作进行注入，或者采用构造器注入来手动控制 Mock 对象的注入。
		- 如果必须使用字段注入，可以通过一些工具（如 `ReflectionTestUtils`）来在测试中设置字段值
		- 配置`<bean>`用`autowire="xx"`。

---

#### 详细回答
#####  **1. IoC入门案例**
**思路：**
- **如何将被管理的对象告知IoC容器？** 配置。
- **如何获取到IoC容器？** 接口。
- **如何从容其中获取bean？** 接口方法。

**实践：**
1. **导入和配置。** 导入坐标`spring-context`后新建配置文件`applicationContext.xml`并配置bean（包括id，class）
2. **获取IoC容器。** `new ClassPathXmlApplicationContext("applicationContext.xml")`
3. **获取bean。** `ctx.getBean("bookDao")`

#####  **2. DI的三种注入方法**
**思路：**
- **注入什么类型？** 
	- **简单类型（如int、String）**。用`<property>`标签的`value`属性
	- **引用类型**。用`<property>`标签的`ref`属性
	- **集合**。用`<property>`标签的`<array>``<list>``<set>``<map>``<props>`子标签

**实践：**
1. **Setter 注入**：通过 Setter 方法，配置`<bean>`用`<property>`标签的`value`或`ref`属性注入。
	- 如果只有Setter方法，没有注入，会导致null对象出现。
	- 适用于可选依赖的注入、自己开发的模块的注入。
	![image.png](http://cdn.kamacoder.com/67553ebac9455-phpelMxgP.png)
2. **构造器注入（Spring推荐）**：通过构造函数，配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性注入。
	- 形参名的耦合问题解决：用`type`属性替代`name`属性。
	- 多个同类型的解决：用`index`属性替代`type`属性。
	- 适用于强制依赖的注入、第三方不含setter的模块的注入。
3. **自动装配（不推荐）**：配置`<bean>`用`autowire="xx"`，通过Setter方法 或 直接在字段上使用 `@Autowired`注入。
	- `autowire="byType"`按类型装配（推荐）。
		- 发现有多个class相同的bean，那装配谁呢？失败。
		- ![image.png](http://cdn.kamacoder.com/67554631ea319-phpO8de4F.png)
	- `autowire="byName"`按名称装配。（不推荐，因为变量名与配置耦合）

---

#### 延申问题
- [x] [**Spring框架中的@Autowired和@Resource注解有什么区别？**](https://notes.kamacoder.com/question/100541)
- [x] [**Spring 是如何管理 Bean 的生命周期的？有哪些生命周期方法？**](https://notes.kamacoder.com/question/100530)
- [x] [**Bean 的作用域有哪些？如何配置不同作用域？**](https://notes.kamacoder.com/question/100531)
- [x] **如果需要动态注入依赖，比如运行时决定使用哪个实现，如何实现？**
	- 可使用 `@Qualifier` 指定 Bean，或通过 `@Conditional` 注解根据条件动态加载 Bean。
- [ ] **在依赖注入过程中，如何解决循环依赖问题？**
	- Spring 使用三级缓存解决循环依赖，允许提前暴露 Bean 引用，避免死循环。
		1. SingletonFactory
		2. Early Bean Reference
		3. Fully Initialized Bean

- [ ] **如何使用第三方库实现 IoC？Spring IoC 与其他 IoC 框架（如 Guice）相比有何优势？**
	- 第三方库： Guice IoC 框架。
	- Spring IoC 提供更丰富的生态（如 AOP、数据访问支持）和灵活的配置方式（XML、注解、JavaConfig）

### [Spring容器是如何管理Bean的生命周期的？包括哪些阶段？](https://notes.kamacoder.com/questions/500530)
#### 简洁回答
Spring 容器通过**配置或注解**管理 **Bean 的生命周期**（从创建到销毁的整个过程），包括以下阶段：
1. **实例化：** 执行构造方法创建对象，分配内存
2. **属性赋值：** set操作
3. **初始化** `implements InitializingBean` ，调用其 `afterPropertiesSet()` 方法。
	1. `Aware` 接口的依赖注入
	2. `BeanPostProcessor` 在初始化前后的处理
	3. `InitializingBean` 和 `init-method` 的初始化操作
4. 使用bean执行业务操作
5. **销毁** `implements DisposableBean` ，调用其 `destroy()` 方法。

---

#### 前置知识
- bean作用范围
- bean默认单例
	- 适合交给容器管理的bean：Service、Dao层对象
	- 不适合交给容器管理的bean：封装实体的域对象（有指定值）
- bean实例化
	1. 构造方法：无参构造方法、反射获取
	3. 静态工厂：`factory-method`
		```xml
		<bean id="orderDao" class="com.itheima.factory.OrderDaoFactory" factory-method ="getorderDao"/>
		```
	3. 实例工厂：
		- factory-bean="xx"
			```xml
			<bean id="userFactory" class="com.itheima.factory.UserDaoFactory" >
			<bean id="userDao" factory-method="getuserDao" factory-bean="userFactory" />
			```
		- FactoryBean
			![image.png](http://cdn.kamacoder.com/6755657ee33e2-phpVOnGPM.png)

---

#### 详细回答
1. **实例化：** 执行构造方法创建对象，分配内存
2. **属性赋值：** set操作
3. **初始化**
	- 自定义配置： `@PostConstruct` 或`init-method="xx"`
	- 实现接口： `implements InitializingBean` ，调用其 `afterPropertiesSet()` 方法。
		- 注意：在set方法的属性设置之后才执行该方法
4.使用bean执行业务操作
5. **销毁**
	- 自定义配置： `@PreDestroy` 或`destroy-method="xx"`
		- 注意：容器关闭时调用销毁逻辑，要想看到destroy-method执行：
			1. 暴力手动关闭：在JVM结束前通过`ClassPathXmlApplication接口close()方法`关闭容器
			2. 注册关闭钩子：`ClassPathXmlApplication接口registerShutdownHook()方法`
	- 实现接口： `implements DisposableBean` ，调用其 `destroy()` 方法。

![spring-bean-lifestyle.png](http://cdn.kamacoder.com/67558de2a9c6e-phpjekGCZ.png) 

---

#### 延伸问答
- [ ]  **Spring Bean 生命周期的扩展点有哪些？**
	- 使用 `BeanPostProcessor` 在初始化前后执行自定义逻辑。
	- 使用 `BeanFactoryPostProcessor` 修改 Bean 的定义或属性。
- [ ]  **不同作用域的生命周期有何区别？**
	- `singleton`：与容器生命周期一致，容器关闭时销毁。
	- `prototype`：每次获取新实例，无全局生命周期管理，不执行销毁方法。
### [Spring中Bean的作用域有哪些？分别适用于什么场景？](https://notes.kamacoder.com/questions/500531)
#### 简洁回答
**2基础作用域 + 4仅Web 应用可用：**
1. **singleton（默认）：** IoC 容器中只有唯一的 bean 实例，适用于无状态的共享资源。
	- 作用域对生命周期的影响：Spring 管理整个生命周期，容器会自动调用销毁逻辑。
2. **prototype：** 每次获取bean都创建一个新实例，适用于短期使用的有状态且非线程安全的对象。
	- 作用域对生命周期的影响：Spring 只负责创建，由客户端决定何时销毁。
	- 应用：唯一标识符（UUID 、验证码、Token）、用户临时数据（表单数据缓存、文件上传临时存储）
3. **request：** 每个 HTTP 请求创建一个实例，如表单数据处理。
4. **session：** 每个会话创建一个实例，如用户信息缓存。
5. **application/global-session：** 在Web应用启动时创建一个bean，如统计数据。
6. **websocket：** 每个 WebSocket 会话创建一个实例，适用于WebSocket 连接状态管理。

----

#### 延申问答
- [x] **如何指定 Bean 作用域？**
	1. xml 方式
		```
		<bean id="..." class="..." scope="singleton"></bean>
		```
	2. 注解方式
		```
		@Bean
		@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
		public Person personPrototype() {
			return new Person();
		}
		```
- [x] **如何测试作用域行为？**
	- 可通过使用 `bean1.hashCode()` 或`System.identityHashCode(bean1)` 打印 Bean 的哈希值验证是否是同一实例。
- [x] Bean是线程安全的吗？
	Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。
我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。
prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。
有状态 Bean 示例：
```
// 定义了一个购物车类，其中包含一个保存用户的购物车里商品的 List
@Component
public class ShoppingCart {
    private List<String> items = new ArrayList<>();

    public void addItem(String item) {
        items.add(item);
    }

    public List<String> getItems() {
        return items;
    }
}
```


不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。
无状态 Bean 示例：
```
// 定义了一个用户服务，它仅包含业务逻辑而不保存任何状态。
@Component
public class UserService {

    public User findUserById(Long id) {
        //...
    }
    //...
}
```


对于有状态单例 Bean 的线程安全问题，常见的三种解决办法是：
1. **避免可变成员变量**: 尽量设计 Bean 为无状态。
2. **使用`ThreadLocal`**: 将可变成员变量保存在 `ThreadLocal` 中，确保线程独立。
3. **使用同步机制**: 利用 `synchronized` 或 `ReentrantLock` 来进行同步控制，确保线程安全。

这里以 `ThreadLocal`为例，演示一下`ThreadLocal` 保存用户登录信息的场景：
```
public class UserThreadLocal {

    private UserThreadLocal() {}

    private static final ThreadLocal<SysUser> LOCAL = ThreadLocal.withInitial(() -> null);

    public static void put(SysUser sysUser) {
        LOCAL.set(sysUser);
    }

    public static SysUser get() {
        return LOCAL.get();
    }

    public static void remove() {
        LOCAL.remove();
    }
}
```
### [说一说你对Spring AOP的了解，它主要解决什么问题？](https://notes.kamacoder.com/questions/500532)
#### 简洁回答
1. 定义和目标：Spring AOP（Aspect-Oriented Programming，面向切面编程），目标是减少重复代码，降低模块间耦合度，提高可扩展性和可维护性。
2. 工作机制：Spring AOP 基于动态代理和 Cglib 实现，封装通用逻辑（例如日志记录、事务管理、权限控制、性能监控等）：
	- 对于实现了某个接口的对象： Spring AOP 会使用 JDK Proxy创建代理对象
	- 对于没有实现接口的对象：使用 Cglib 生成一个被代理对象的子类来作为代理
3. 专业术语
	- **切面(Aspect) = 切入点(Pointcut) + 通知(Advice)**
		- **切入点（Pointcut）：** 被切面拦截 / 增强的连接点
			- **连接点（Join Point）：** 目标对象的所属类中，定义的所有方法均为连接点
			- 切入点一定是连接点，连接点不一定是切入点
		- **通知（Advice）：** 增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情。
			- **目标(Target)：** 被通知的对象
			- **代理(Proxy)：** 向目标对象应用通知之后创建的代理对象
			- **Weaving(织入)：** 将通知应用到目标对象，进而生成代理对象的过程动作
----

#### 详细回答

----

#### 延伸问答
- [ ] **Spring AOP 和 AspectJ AOP 有什么区别？**
	- Spring AOP：运行时增强，基于代理，集成了 AspectJ且更简单方便
	- AspectJ：编译时增强，基于字节码操作，提供更全面的 AOP 支持（如字段、构造函数切点）。
		- 当切面太多时最好选择 AspectJ ，快很多。
- [x] **AOP 常见的通知类型有哪些？**
	- **Before**（前置通知）：目标对象的方法调用之前触发
	- **After** （后置通知）：目标对象的方法调用之后触发
	- **AfterReturning**（返回通知）：目标对象的方法调用完成，在返回结果值之后触发
	- **AfterThrowing**（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。
		- AfterReturning 和 AfterThrowing 两者互斥。
	- **Around** （环绕通知）：可操作范围最大，可以直接拿到目标对象以及要执行的方法，可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法
	![aspectj-advice-types.jpg](http://cdn.kamacoder.com/67559341b3761-phpqUAJOq.jpg) 
- [x] **多个切面的执行顺序如何控制？**
	1. 通常使用`@Order` 注解直接定义切面顺序，值越小优先级越高。
	2. `implements Ordered` 接口重写 `getOrder` 方法，返回值越小优先级越高。
### [说一说你对 Spring中IOC的理解。](https://notes.kamacoder.com/questions/500533)
#### 简洁回答
- **控制反转（Inversion of Control, IoC）【思想】：** 指将对象的创建、初始化及依赖管理的控制权从应用代码转移到 Spring 容器。
	- 传统方式： 对象由程序创建，依赖通过硬编码传递（代码写死而不是通过配置动态控制），高耦合。
	- IoC 方式： Spring 容器负责对象创建和依赖，模块之间只需要声明依赖，低耦合。
- **依赖注入（Dependency Injection, DI）【实现方式】：** 容器根据配置将所需的依赖注入到对象中。
	1. Setter 注入。
		- 适用于可选依赖的注入、自己开发的模块的注入
		- 如果只有Setter方法，没有注入，会导致null对象出现。
		- 配置`<bean>`用`<property>`标签的`value`或`ref`属性。
	2. 构造器注入（推荐）。
		- 适用于强制依赖的注入、第三方不含setter的模块的注入
		- 构造器注入结合 `@Qualifier` 或策略模式明确依赖关系，可以避免多个依赖注入混乱。
		- 配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性。
	3. 自动装配（不推荐）
		- 不推荐原因：隐式依赖关系导致的可测试性差和不易维护
			1. 可测试性差： 不能通过构造器或 setter 方法修改依赖关系，因为 Spring 会在创建 Bean 时自动完成依赖注入，测试代码无法显式地控制 Mock （模仿）对象的注入，增加了测试难度。
			2. 不易维护：因为它没有明确显示依赖项，导致代码难以理解和维护。
		- 如果必须使用字段注入，可以通过一些工具（如 `ReflectionTestUtils`）来在测试中设置字段值
		- 配置`<bean>`用`autowire="xx"`。

---

#### 详细回答
#####  **1. IoC入门案例**
**思路：**
- **如何将被管理的对象告知IoC容器？** 配置。
- **如何获取到IoC容器？** 接口。
- **如何从容其中获取bean？** 接口方法。

**实践：**
1. **导入和配置。** 导入坐标`spring-context`后新建配置文件`applicationContext.xml`并配置bean（包括id，class）
2. **获取IoC容器。** `new ClassPathXmlApplicationContext("applicationContext.xml")`
3. **获取bean。** `ctx.getBean("bookDao")`

#####  **2. DI的三种注入方法**
**思路：**
- **注入什么类型？** 
	- **简单类型（如int、String）**。用`<property>`标签的`value`属性
	- **引用类型**。用`<property>`标签的`ref`属性
	- **集合**。用`<property>`标签的`<array>``<list>``<set>``<map>``<props>`子标签

**实践：**
1. **Setter 注入**：通过 Setter 方法，配置`<bean>`用`<property>`标签的`value`或`ref`属性注入。
	- 如果只有Setter方法，没有注入，会导致null对象出现。
	- 适用于可选依赖的注入、自己开发的模块的注入。
	![image.png](http://cdn.kamacoder.com/67553ebac9455-phpelMxgP.png)
2. **构造器注入（Spring推荐）**：通过构造函数，配置`<bean>`用`<constructor-arg>`标签的`value`或`ref`属性注入。
	- 形参名的耦合问题解决：用`type`属性替代`name`属性。
	- 多个同类型的解决：用`index`属性替代`type`属性。
	- 适用于强制依赖的注入、第三方不含setter的模块的注入。
3. **自动装配（不推荐）**：配置`<bean>`用`autowire="xx"`，通过Setter方法 或 直接在字段上使用 `@Autowired`注入。
	- `autowire="byType"`按类型装配（推荐）。
		- 发现有多个class相同的bean，那装配谁呢？失败。
		- ![image.png](http://cdn.kamacoder.com/67554631ea319-phpO8de4F.png)
	- `autowire="byName"`按名称装配。（不推荐，因为变量名与配置耦合）

---

#### 延申问题
- [x] [**Spring框架中的@Autowired和@Resource注解有什么区别？**](https://notes.kamacoder.com/question/100541)
- [x] [**Spring 是如何管理 Bean 的生命周期的？有哪些生命周期方法？**](https://notes.kamacoder.com/question/100530)
- [x] [**Bean 的作用域有哪些？如何配置不同作用域？**](https://notes.kamacoder.com/question/100531)
- [x] **如果需要动态注入依赖，比如运行时决定使用哪个实现，如何实现？**
	- 可使用 `@Qualifier` 指定 Bean，或通过 `@Conditional` 注解根据条件动态加载 Bean。
- [ ] **在依赖注入过程中，如何解决循环依赖问题？**
	- Spring 使用三级缓存解决循环依赖，允许提前暴露 Bean 引用，避免死循环。
		1. SingletonFactory
		2. Early Bean Reference
		3. Fully Initialized Bean

- [ ] **如何使用第三方库实现 IoC？Spring IoC 与其他 IoC 框架（如 Guice）相比有何优势？**
	- 第三方库： Guice IoC 框架。
	- Spring IoC 提供更丰富的生态（如 AOP、数据访问支持）和灵活的配置方式（XML、注解、JavaConfig）

### [Spring中用到了那些设计模式。](https://notes.kamacoder.com/questions/500534)
#### 简洁回答
- **工厂设计模式** : Spring 使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。
- **单例设计模式** : Spring 中的 Bean 默认都是单例的。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式** : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。
- ……

### [描述一下 SpringMVC 的执行流程。](https://notes.kamacoder.com/questions/500535)
#### 简洁回答
1. **请求、到达** 客户端发起请求 ->  `DispatcherServlet` 
2. **查找、处理、返回**  （2-5）
	- 查找：用`HandlerMapping` 根据请求的 URL、HTTP 方法查找合适的Controller。
	- 处理：用`HandlerAdapter`调用Controller处理
	- 返回：返回 `ModelAndView` 对象
3. **解析、渲染、返回** （6-8）
	- 解析：用`ViewResolver` 将逻辑视图名称解析为具体的视图对象（如 JSP 文件）。
	- 渲染： 根据 `Model` 中的数据渲染页面，并将响应返回给客户端。

![de6d2b213f112297298f3e223bf08f28.png](http://cdn.kamacoder.com/6756edd2e2399-phpODdSF3.png) 

----

#### 详细回答
MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。
##### Spring MVC 的核心组件
- **`DispatcherServlet`**：**中央处理器**，负责接收请求、分发，并给予客户端响应。
- **`HandlerMapping`**：**处理器映射器**，根据 URL 去匹配查找能处理的 `Handler` ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
- **`HandlerAdapter`**：**处理器适配器**，根据 `HandlerMapping` 找到的 `Handler` ，适配执行对应的 `Handler`；
- **`ModelAndView`**：**模型和视图**，包含模型数据和视图名称，用于在处理器和视图之间传递数据。
- **`ViewResolver`**：**视图解析器**，将视图名称解析为具体的视图对象，支持多种视图技术（如 JSP、Thymeleaf）。

##### Spring MVC 的工作流程
1. **请求、到达** 客户端发起请求 ->  `DispatcherServlet` 
2. **查找、处理、返回**  （2-5）
	- 查找：用`HandlerMapping` 根据请求的 URL、HTTP 方法查找合适的Controller。
	- 处理：用`HandlerAdapter`调用Controller处理
	- 返回：返回 `ModelAndView` 对象
3. **解析、渲染、返回** （6-8）
	- 解析：用`ViewResolver` 将逻辑视图名称解析为具体的视图对象（如 JSP 文件）。
	- 渲染： 根据 `Model` 中的数据渲染页面，并将响应返回给客户端。

![de6d2b213f112297298f3e223bf08f28.png](http://cdn.kamacoder.com/6756edd2e2399-phpODdSF3.png) 

----

#### 延伸问答
- [ ] **如何自定义 SpringMVC 的 `HandlerMapping` 和 `ViewResolver`？**
	通过implements`WebMvcConfigurerAdapter` 或 `WebMvcConfigurer` 接口，在 `configureHandlerMapping()` 和 `configureViewResolvers()` 方法中自定义映射和视图解析器。
- [x] **SpringMVC 的拦截器如何工作？**
	- 通过实现 `HandlerInterceptor` 接口，在请求到达 Controller 之前和响应返回客户端之前执行，通常用于处理日志、权限验证等跨切面逻辑。
- [ ] **为什么需要前端控制器（DispatcherServlet）？**
	将所有的请求集中处理，简化了请求分发和响应管理，实现解耦、集中配置、增强扩展性。
- [ ] **SpringMVC 支持哪些类型的视图？**
	SpringMVC 支持多种视图解析技术，如 JSP、Thymeleaf、Freemarker、Velocity 等，也支持直接返回 JSON、XML 数据（使用 `@ResponseBody`）。
### [SpringMVC 中的DispatcherServlet扮演什么角色？](https://notes.kamacoder.com/questions/500536)
#### 简洁回答
##### 1. 地位（角色）
**核心调度器 / 请求分发中心：** ：所有请求都由`DispatcherServlet`统一管理，根据请求 URL查找对应的处理器（Controller），并协调视图解析器生成最终的响应。
##### 2. 作用	
- **解耦：** `DispatcherServlet` 通过 HandlerMapping 和 ViewResolver 解耦了请求和处理逻辑。
- **灵活性：** 可配置多个 `HandlerMapping` 和 `ViewResolver` 实现，支持复杂的请求分发和视图解析。
- **扩展性：** 提供了拦截器（Interceptor）机制，可在请求处理前后执行额外的逻辑。

----

#### 详细回答

----

#### 延伸回答
- [x] **`DispatcherServlet` 和传统 Front Controller 的区别是什么？**
	- `DispatcherServlet` 提供了完整的扩展机制（如拦截器、异常处理器等），而传统 Front Controller 逻辑通常较固定。
- [x] **`DispatcherServlet` 如何与其他组件协作？**
	- 使用 `HandlerMapping` 查找 Controller，`HandlerAdapter` 调用具体方法。
	- 使用 `ViewResolver` 解析逻辑视图名并返回渲染的结果。
- [ ] **是否可以自定义 `DispatcherServlet`？**
	- 可以通过扩展 `DispatcherServlet` 类自定义其行为，例如重写 `doDispatch()` 方法来调整请求处理逻辑。
	- 也可以通过配置文件调整其参数（如文件上传、初始化参数等）。
### [SpringMVC 中如何配置控制器（Controller）？](https://notes.kamacoder.com/questions/500537)
#### 简洁回答
- **使用注解方式（推荐）：** 
	- 使用 `@Controller `标识类为控制器，并使用 `@RequestMapping` 指定 URL 映射关系。
	- 在 Spring 启动类中启用注解扫描`@ComponentScan`
- **使用 XML 配置方式：** 
	- 在 XML 文件中声明 `Controller` 的 Bean 。
	- 使用 `<mvc:annotation-driven />`配置请求映射。

---

#### 详细回答

---

#### 延伸问答
- [x] **如何配置多级 URL？**
	- 使用类级别和方法级别的 `@RequestMapping`：
	```java
	@Controller
	@RequestMapping("/users")
	public class UserController {
	    @GetMapping("/{userId}/orders")
	    public String getUserOrders(@PathVariable Long userId) {
	        return "orderView";
	    }
	}
	```
### [Spring中如何配置和使用事务管理？有哪些事务传播行为？](https://notes.kamacoder.com/questions/500538)
#### 简洁回答
##### 事务管理
1. 配置事务
	- 引入依赖`spring-boot-starter-data-jpa`
	-  使用`@EnableTransactionManagement` 启用事务支持
	- Spring自动配置了数据源和事务管理器，也可以自定义 `DataSourceTransactionManager`或`JpaTransactionManager`Bean。
2. 使用事务
	- 在类或方法上添加 `@Transactional` 注解，Spring 自动管理事务的开启、提交和回滚。
##### 事务传播行为
Spring 提供了 7 种事务传播行为（Propagation）来定义方法如何加入或创建事务：
|**传播行为**|**描述**|
|:-:|:-:|
|`REQUIRED`|默认值，加入当前事务，如果没有事务则创建新事务。|
|`REQUIRES_NEW`|总是创建一个新事务，挂起当前事务。|
|`SUPPORTS`|如果有事务则加入事务，没有事务则以非事务方式运行。|
|`NOT_SUPPORTED`|总是以非事务方式运行，挂起当前事务。|
|`MANDATORY`|必须在事务中运行，如果没有事务则抛出异常。|
|`NEVER`|必须在非事务环境中运行，如果存在事务则抛出异常。|
|`NESTED`|如果当前有事务，则在嵌套事务中运行，否则创建新事务（需要底层数据库支持 Savepoint）。|

----

#### 详细回答

----

#### 延伸问答
- [ ] **如何配置事务回滚规则？**
	- 默认情况下，`@Transactional` 会对所有 `RuntimeException` 和子类进行回滚。
	- 如果需要指定回滚规则，可以使用 `rollbackFor`
		```java
		@Transactional(rollbackFor = {IOException.class, SQLException.class})
		public void saveData() throws IOException {
		    // 业务逻辑
		}
		```
- [ ] **事务的隔离级别有哪些？**
	- Spring 提供 5 种隔离级别，与数据库事务隔离级别对应：- `DEFAULT`：使用数据库默认隔离级别。
		- `READ_UNCOMMITTED`：允许读取未提交的数据（脏读）。
		- `READ_COMMITTED`：防止脏读，默认隔离级别。
		- `REPEATABLE_READ`：防止脏读和不可重复读。
		- `SERIALIZABLE`：防止所有并发问题，性能最低。
- [ ] **事务嵌套与传播行为的区别？**
	- 嵌套事务（`NESTED`）：在当前事务中创建子事务，回滚只影响子事务。
	- 传播事务（`REQUIRES_NEW`）：创建独立事务，与当前事务无关。
### [解释一下Spring中的@Transactional注解及其属性。](https://notes.kamacoder.com/questions/500539)
#### 简洁回答
`@Transactional` 是 Spring 用于声明式事务管理的注解，支持自动控制事务的开启、提交和回滚。
常用属性包括：
1. **`propagation`：** 定义事务传播行为（如 `REQUIRED`、`REQUIRES_NEW` 等）。
2. **`isolation`：** 指定事务的隔离级别（如 `READ_COMMITTED`、`SERIALIZABLE`）。
3. **`timeout`：** 设置事务的超时时间（单位：秒）。如果事务在超时时间内未完成，则强制回滚。
4. **`rollbackFor` 和 `noRollbackFor`：** 定义哪些异常会触发回滚或不触发回滚。
5. **`readOnly`：** 标记事务为只读，提高查询性能。

----

#### 详细回答
1. **`propagation`（事务传播行为）：** 定义方法的事务如何与现有事务交互。
	- `REQUIRED`（默认）：加入当前事务，没有则新建。
	- `REQUIRES_NEW`：挂起当前事务，创建新事务。
	- `SUPPORTS`：在事务中运行，没有事务则以非事务方式运行。
2. **`isolation`（事务隔离级别）：** 定义事务如何隔离并发操作，避免脏读、不可重复读、幻读等问题。
	- `DEFAULT`（默认值）：使用数据库的默认隔离级别。
	- `READ_COMMITTED`：防止脏读。
	- `REPEATABLE_READ`：防止脏读和不可重复读。
	- `SERIALIZABLE`：防止所有并发问题，但性能最低。
3. **`timeout`（超时时间）：** 设置事务的超时时间（单位：秒）。如果事务在超时时间内未完成，则强制回滚。
4. **`rollbackFor` 和 `noRollbackFor`（回滚规则）：** 指定哪些异常会触发或不触发事务回滚。默认情况下，`RuntimeException` 或 `Error` 会触发回滚。
5. **`readOnly`（只读事务）：** 标记事务为只读，优化性能（主要用于查询操作）。

----

#### 延伸问答

- [ ] **如何自定义事务管理器？**
	- 如果有多个数据源，可以通过 `@Transactional(transactionManager = "customTransactionManager")` 指定特定事务管理器：

- [ ] **`@Transactional` 注解的局限性：**
	- 不支持构造方法。
	- 只能作用于 Spring 管理的 Bean。
	- 事务方法需要通过代理调用才能生效（不能直接在同一个类中调用）。
- [ ] **事务嵌套与传播行为的选择：**
	- 嵌套事务可以通过 `NESTED` 实现，适合保存点场景。
	- `REQUIRES_NEW` 独立事务适合关键操作，不受外层事务影响。
### [Spring框架中如何定义和使用自定义事件和监听器？](https://notes.kamacoder.com/questions/500540)
#### 简洁回答
通过自定义事件和监听器，Spring 提供了一种解耦组件之间通信的机制，适用于跨模块事件驱动的开发场景，例如异步通知和任务触发。
1. **定义事件类：** 继承 `ApplicationEvent` 或使用任意 POJO。
2. **发布事件：** 使用 `ApplicationEventPublisher` 的 `publishEvent()` 方法发布事件。
3. **监听事件：** 使用 `@EventListener` （推荐）或实现 `ApplicationListener` 接口处理事件。

---

#### 详细回答

---

#### 延伸问答
- [ ] **如何处理异步事件？**
	- 在 `@EventListener` 上添加 `@Async` 注解，并确保项目中配置了异步支持
- [ ] **如何监听多个事件？**
	- 一个监听器可以监听多个事件，通过 `@EventListener` 方法参数指定：
	```java
	@EventListener
	public void handleMultipleEvents(Object event) {
		if (event instanceof CustomEvent) {
			System.out.println("CustomEvent: " + ((CustomEvent) event).getMessage());
		} else if (event instanceof AnotherEvent) {
			System.out.println("AnotherEvent received.");
		}
	}
	```
- [ ] **如何使用条件监听？**
	- 在 `@EventListener` 中添加 `condition` 属性：
	```java
	@EventListener(condition = "#event.message == 'specific'")
	public void handleConditionalEvent(CustomEvent event) {
		System.out.println("Condition met: " + event.getMessage());
	}
	```


### [Spring框架中的@Autowired和@Resource注解有什么区别？](https://notes.kamacoder.com/questions/500541)
#### 简洁回答
1. **`@Autowired`：** Spring 特有，默认**按类型（byType）** 自动注入。
	- 注解来源：Spring 特有，支持`@Autowired(required = false)`表示依赖项可选，即没有匹配到 Bean 时，不抛异常，而是注入 `null`。
	- 如果存在多个相同类型的 Bean，可结合 `@Qualifier` 注解指定注入的 Bean 名称。
2. **`@Resource`：** JSR-250 标准，默认**按名称（byName）** 注入。
	- JSR-250 标准，更适合标准化和跨框架使用。
	- 如果未指定名称且没有匹配的 Bean，会按类型注入。

---

#### 详细回答
1. **`@Autowired`：** 
	```java
	@Component
	public class UserService {
		@Autowired
		private UserRepository userRepository; // 默认按类型注入

		@Autowired
		@Qualifier("specialUserRepository") // 指定名称
		private UserRepository specialRepository;
	}
	```

2. **`@Resource`：** 
	```java
	@Component
	public class UserService {
		@Resource(name = "userRepository") // 默认按名称注入
		private UserRepository userRepository;

		@Resource(type = SpecialUserRepository.class) // 按类型注入
		private SpecialUserRepository specialRepository;
	}
	```

### [Spring框架如何支持JDBC模板（JdbcTemplate）来简化数据库操作？](https://notes.kamacoder.com/questions/500542)
#### 知识索引
- **Spring 数据访问 → 数据库操作 → JdbcTemplate**

----

#### 简洁回答
Spring 的 `JdbcTemplate`  **简化 JDBC 操作**，帮助开发者高效地执行数据库查询、更新和调用存储过程。
它通过**封装常见的资源管理和异常处理**，避免了冗余的代码，提高了开发效率。

----

#### 详细回答
1. **优势：**
	- 自动管理资源：如 `Connection`、`PreparedStatement` 和 `ResultSet`。
	- 简化异常处理：将检查型异常（如 `SQLException`）转换为 Spring 的 `DataAccessException`。
	- 提供模板方法：减少重复代码，开发者只需专注于 SQL 和业务逻辑。
2. **核心功能：**
	- **查询操作（查询单行、多行）：**
		```java
		String sql = "SELECT name FROM users WHERE id = ?";
		String name = jdbcTemplate.queryForObject(sql, new Object[]{1}, String.class);
		```
	- **更新操作（插入、修改、删除）：**
		```java
		String sql = "UPDATE users SET name = ? WHERE id = ?";
		int rowsAffected = jdbcTemplate.update(sql, "NewName", 1);
		```
	- **批量更新：**
		```java
		String sql = "INSERT INTO users (name, age) VALUES (?, ?)";
		List<Object[]> batchArgs = Arrays.asList(
		    new Object[]{"Alice", 30},
		    new Object[]{"Bob", 25}
		);
		jdbcTemplate.batchUpdate(sql, batchArgs);
		```
	- **自定义结果映射：**
		使用 `RowMapper` 将结果集转换为 Java 对象：
		```java
		String sql = "SELECT id, name, age FROM users";
		List<User> users = jdbcTemplate.query(sql, new RowMapper<User>() {
		    @Override
		    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
		        return new User(rs.getInt("id"), rs.getString("name"), rs.getInt("age"));
		    }
		});
		```
3. **配置步骤：**
	- **配置数据源：**
		Spring 需要通过 `DataSource` 提供数据库连接。
		```java
		@Bean
		public DataSource dataSource() {
		    return new DriverManagerDataSource("jdbc:mysql://localhost:3306/testdb", "username", "password");
		}
		```
	- **创建 `JdbcTemplate` Bean：**
		```java
		@Bean
		public JdbcTemplate jdbcTemplate(DataSource dataSource) {
		    return new JdbcTemplate(dataSource);
		}
		```
	- **使用 `JdbcTemplate`：**
		在需要的地方注入并使用：
		```java
		@Autowired
		private JdbcTemplate jdbcTemplate;
		```

----

#### 延伸问答
1. **`JdbcTemplate` 如何简化事务管理？**
	- 与 Spring 的声明式事务管理结合，`JdbcTemplate` 支持自动事务管理，确保在事务边界内完成操作，减少手动管理事务的代码。
2. **与 ORM 框架（如 JPA）的区别？**
	- `JdbcTemplate` 直接基于 SQL 和 JDBC，灵活性更高，适合执行复杂查询或调用存储过程。
	- ORM 框架（如 JPA）通过对象模型抽象了数据库交互，简化了实体管理。
3. **如何处理大批量数据查询？**
	- 使用 `jdbcTemplate.query` 的回调接口 `ResultSetExtractor`，逐行处理结果，避免将所有数据加载到内存中：
	```java
	jdbcTemplate.query("SELECT * FROM large_table", rs -> {
		    while (rs.next()) {
		        // Process each row
		    }
		});
		```

Spring 的 `JdbcTemplate` 是一个轻量级、灵活的数据库操作工具，非常适合场景化开发，尤其是需要高度定制的 SQL 操作。
### [Spring框架中的@Repository、@Service、@Controller注解的作用是什么？](https://notes.kamacoder.com/questions/500543)
#### 简洁回答
1. **`@Repository`：** 标记数据访问层（DAO）组件，能将数据库相关异常转换为 Spring 的数据访问异常（如 `DataAccessException`）
2. **`@Service`：** 标记业务逻辑层（Service）组件。
3. **`@Controller`：** 标记控制层（Controller）组件，常与 `@RequestMapping` 等注解结合，用于定义 Web 路由。
### [Spring框架中的@RequestMapping注解有哪些属性？如何配置RESTful风格的URL？](https://notes.kamacoder.com/questions/500544)
#### 简洁回答
##### @RequestMapping注解的属性
`@RequestMapping` 注解用于映射请求到控制器的方法或类。常用属性包括：
1. **`value`/`path`：** 指定 URL 路径。
2. **`method`：** 限定 HTTP 请求方法（如 GET、POST 等）。
3. **`params` 和 `headers`：** 限定请求参数或请求头。
4. **`consumes` 和 `produces`：** 指定请求的媒体类型（MIME 类型）。
通过在类和方法上使用 `@RequestMapping` 或其简化注解（如 `@GetMapping`），可以轻松配置 RESTful 风格的 URL。

##### REST
**REST**（Representational State Transfer）表现形式状态转换,它是一种软件架构风格。根据REST风格对资源进行访问称为**RESTful**。
**REST的优点**:
- 隐藏资源的访问行为：无法通过地址得知对资源是何种操作
- 书写简化

---

#### 详细回答
##### REST风格举例
- 传统风格资源描述形式
	- `http://localhost/user/getById?id=1` 查询id为1的用户信息
	- `http://localhost/user/saveUser` 保存用户信息
- REST风格描述形式
	- `http://localhost/user/1` 
	- `http://localhost/user`

##### REST入门案例
1. 设定Http请求动作：`@RequestMapping(value="", method = RequestMethod.POST|GET|PUT|DELETE)`
2. `@PathVariable`设定请求参数（路径变量）
@RequestMapping(value="/users/{id}",method = RequestMethod.DELETE)
@ReponseBody
public String delete(@PathVariable Integer id){
}

##### **@PathVariable传递路径参数**
**问题：** 删除方法没有携带所要删除数据的id,所以针对RESTful的开发，如何携带数据参数?
**解决：** 前端发送请求的时候使用:`http://localhost/users/1`,路径中的`1`就是我们想要传递的参数。
	- 修改@RequestMapping的value属性，将其中修改为`/users/{id}`，目的是和路径匹配
	- 在方法的形参前添加@PathVariable注解

**1. 如果方法形参的名称和路径`{}`中的值不一致，该怎么办?**
	![1630506231379.png](http://cdn.kamacoder.com/6759029fe0ae7-phpIzd4tP.png)

**2. 如果有多个参数需要传递该如何编写?**
```java
@Controller
public class UserController {
	//设置当前请求方法为DELETE，表示REST风格中的删除操作
	@RequestMapping(value = "/users/{id}/{name}",method = RequestMethod.DELETE)
	@ResponseBody
	public String delete(@PathVariable Integer id,@PathVariable String name) {
		System.out.println("user delete..." + id+","+name);
		return "{'module':'user delete'}";
	}
}
```

---

#### 延伸问答
- [x] **`@RequestBody`、`@RequestParam`、`@PathVariable`的区别？**
	- **@RequestParam用于接收url地址传参或表单传参：** 发送非json格式数据，选用@RequestParam接收请求参数
	- **@RequestBody用于接收json数据：** 发送请求参数超过1个时，以json格式为主，@RequestBody应用较广
	- **@PathVariable用于接收路径参数，使用{参数名称}描述路径参数：** 采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值

### [Spring框架中的@ModelAttribute注解的作用是什么？](https://notes.kamacoder.com/questions/500545)
#### 知识索引
- **Spring MVC → 控制器相关 → @ModelAttribute注解**

----

#### 简洁回答
`@ModelAttribute` 注解用于将请求参数**自动绑定**到方法参数或方法返回值上。它可用于在控制器方法执行前，预先填充模型数据，或者在方法上直接传递对象。

----

#### 详细回答

----

#### 延伸问答

1. **`@ModelAttribute` 与 `@RequestParam` 的区别：**
	- `@RequestParam` 用于将**单个请求参数**绑定到方法参数上
	-  `@ModelAttribute` 通常用于绑定**整个对象**，且可以自动从请求中提取**多个参数**。
2. **`@ModelAttribute` 与 `@RequestBody` 的区别：**
	- `@RequestBody` 用于将**请求体**中的数据绑定到方法参数，通常用于处理 JSON 或 XML 数据；
	- `@ModelAttribute` 处理的是**请求参数**。
3. **如何在控制器中全局使用 `@ModelAttribute` ？**
	- 可以在类级别上使用 `@ModelAttribute`，这样每次调用该控制器方法时，都会先调用该方法来填充数据。
### [SpringMVC 中如何处理文件上传和下载？](https://notes.kamacoder.com/questions/500546)
#### 简洁回答
1. **文件上传：**
	- 配置 `MultipartResolver` 以支持多部分文件请求。
	- 使用 `@RequestParam("file") MultipartFile file` 接收上传文件。
2. **文件下载：**
	- 设置响应头（`Content-Disposition`）指定下载文件名和类型。
	- 将文件内容写入响应的输出流。

----

#### 详细回答
##### **1. 文件上传**
1. **配置 MultipartResolver：** SpringMVC 使用 `MultipartResolver` 处理多部分请求。
2. **实现文件上传控制器：** `FileUploadController`
3. **前端表单：** 使用 `enctype="multipart/form-data"` 指定多部分上传：
##### **2. 文件下载**
1. 实现文件下载控制器：** 使用 `HttpServletResponse` 设置下载响应头，并写入文件流
2. 访问文件下载：用户访问 `/download/{fileName}` 即可触发下载。

----

#### 延伸问答
- [x] **如何限制上传文件大小？**
	- 在 `application.properties` 中设置限制：
		```properties
		spring.servlet.multipart.max-file-size=10MB
		spring.servlet.multipart.max-request-size=20MB
		```
	- 如果使用 `CommonsMultipartResolver`，可以设置 `maxUploadSize` 属性：
		```xml
		<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
			<property name="maxUploadSize" value="10485760" /> <!-- 10MB -->
		</bean>
		```
- [x] **如何处理多文件上传？**
	- 使用 `@RequestParam("files") MultipartFile[] files` 接收多个文件：```
- [x] **如何提升性能？**
	- 使用异步处理文件上传和下载，减少对主线程的阻塞。
	- 结合云存储（如 AWS S3）存储文件，降低本地服务器的负载。
### [Spring框架中如何实现国际化（i18n）和本地化（l10n）？](https://notes.kamacoder.com/questions/500547)
#### 知识索引

- **Spring 基础 → 配置管理 → 国际化与本地化**


----
#### 简洁回答

Spring 框架通过 `MessageSource` 接口实现国际化（i18n）和本地化（l10n），支持基于语言环境动态加载消息资源文件。结合 `LocaleResolver` 和 `@RequestMapping`，可根据用户的语言偏好或请求参数动态切换语言。


----
#### 详细回答

##### **1. 国际化与本地化的核心组件**

1. **`MessageSource`**
	- 用于加载和解析国际化资源文件（如 `messages_en.properties`、`messages_zh.properties`）。
	- Spring 提供 `ResourceBundleMessageSource` 实现，支持从类路径加载资源文件。
2. **`LocaleResolver`**
	- 确定当前请求的语言环境（`Locale`）。
	- 常用实现：`CookieLocaleResolver` 和 `SessionLocaleResolver`。


----
##### **2. 配置国际化支持**

（1）配置 `MessageSource`

在 Spring 配置中注册 `MessageSource`：
```java
@Configuration
public class I18nConfig {

    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasename("messages"); // 基础文件名，不包含语言后缀
        messageSource.setDefaultEncoding("UTF-8");
        return messageSource;
    }
}
```
（2）配置 `LocaleResolver`

选择语言环境解析器并注册：
```java
@Bean
public LocaleResolver localeResolver() {
    CookieLocaleResolver resolver = new CookieLocaleResolver();
    resolver.setDefaultLocale(Locale.ENGLISH); // 设置默认语言
    return resolver;
}
```

（3）启用语言切换功能

使用 `LocaleChangeInterceptor` 实现动态语言切换：
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
        interceptor.setParamName("lang"); // 参数名，用于指定语言
        return interceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(localeChangeInterceptor());
    }
}
```

----

##### **3. 使用国际化消息**

（1）在代码中使用

通过注入 `MessageSource` 获取国际化消息：
```java
@Autowired
private MessageSource messageSource;

public String getMessage(String code, Locale locale) {
    return messageSource.getMessage(code, null, locale);
}
```
（2）在 JSP 或 Thymeleaf 中使用

Spring 提供 `spring:message` 标签，方便在视图中渲染国际化消息：
```html
<spring:message code="welcome.message" />
```
Thymeleaf 示例：
```html
<p th:text="#{welcome.message}"></p>
```
（3）国际化资源文件

创建 `messages` 文件，例如：
- **messages_en.properties**
- ```properties
	welcome.message=Welcome
	```
- **messages_zh.properties**
- ```properties
	welcome.message=欢迎
	```


----

##### **4. 动态切换语言**

通过请求参数切换语言：
- 配置 `LocaleChangeInterceptor` 后，根据 `lang` 参数动态切换语言环境。


----

#### 延伸问答

1. **如何在 Spring Boot 中快速配置国际化？**
	- Spring Boot 自动配置 `MessageSource`，只需在 `application.properties` 中设置：
	- ```properties
		spring.messages.basename=messages
		spring.messages.encoding=UTF-8
		```
	- 注册 `LocaleResolver` 和 `LocaleChangeInterceptor`。
2. **如何实现基于 URL 的语言切换？**
	- 自定义 `LocaleResolver`，根据 URL 中的路径切换语言：
	- ```arduino
		/en/home
		/zh/home
		```
3. **如何优雅处理资源文件的缺失？**
	- 使用 `MessageSource` 的 `useCodeAsDefaultMessage` 属性，避免找不到消息时抛出异常：
		```java
		messageSource.setUseCodeAsDefaultMessage(true);
		```
4. **如何扩展支持数据库存储国际化资源？**
	- 实现自定义的 `MessageSource`，从数据库中加载消息，而不是从 `.properties` 文件中读取。

Spring 的国际化机制提供了灵活的配置选项，通过结合 `MessageSource` 和 `LocaleResolver`，可以轻松实现基于用户语言偏好的动态消息渲染和多语言支持。
### [Spring框架中的异常处理机制是怎样的？](https://notes.kamacoder.com/questions/500548)
#### 知识索引
- **Spring 基础 → 异常处理机制**

----

#### 黑马
- 编译时异常（如文件名不存在）通过trychatch捕获
- 运行时异常（如int i = 1 / 0）不可预期
##### 异常处理流程
SpringMVC 处理异常的思路是，一路向上抛，都抛给前端控制器 DispatcherServlet ，DispatcherServlet 在调用异常处理器ExceptionResolver进行处理。
##### 异常处理方式
1. 简单异常处理器：使用SpringMVC 内置的异常处理器处理 `SimpleMappingExceptionResolver`； 
	- ![image.png](http://cdn.kamacoder.com/675aa9494982e-phpUjYIR2.png)
	- ![image.png](http://cdn.kamacoder.com/675aa958acd93-phpd9jbQ2.png)
2. 自定义异常处理器：实现`HandlerExceptionResolver`接口，自定义异常进行处理； 
	- ![image.png](http://cdn.kamacoder.com/675aaa6cc5558-phpARhEGp.png)
3. **（推荐）注解方式：** 使用`@ControllerAdvice` + `@ExceptionHandler` 来处理。
	- @ControllerAdvice 注解本质是一个 @Component，也会被扫描到，与此同时，具备AOP功能，默认情况下对所有的Controller都进行拦截操作
	- 拦截后干什么呢？就需要在结合@ExceptionHandler、@InitBinder、@ModelAttribute 注解一起使用了，此处我们讲解的是异常，所以是@ControllerAdvice + @ExceptionHandler的组合形式。
	- ![image.png](http://cdn.kamacoder.com/675aac2fa8d53-phpcUd1gh.png)
##### 异常处理机制原理剖析
- 初始化加载的处理器异常解析器，SpringMVC 的前置控制器在进行初始化的时候，会初始化处理器异常解析器 HandlerExceptionResolver
- 加载DispatcherServlet.properties中默认的异常处理器
- 配置了自定义的异常处理器后，默认的异常处理器就不会被加载，当配置<mvc:annotation-driven /> 或配置了注解@EnableWebMvc后，默认异常处理器和自定的处理器异常解析器都会被注册
- 异常处理器加载完毕后，当发生异常时，就会进行处理，跟踪 DispatcherServlet 的 doDispatch() 方法
- 跟踪processDispatchResult方法
##### 常用的异常解析器
![image.png](http://cdn.kamacoder.com/675aaddf1a8c1-php4X2H2F.png)

---

#### 简洁回答
Spring 框架的异常处理机制分为两部分：
1. **数据访问异常**：Spring 提供统一的 `DataAccessException`，屏蔽底层数据库驱动差异。
2. **MVC 异常处理**：通过 `@ExceptionHandler`、`@ControllerAdvice` 或实现 `HandlerExceptionResolver` 来捕获并处理全局或局部异常。

----

#### 详细回答
##### **1. 数据访问异常**
Spring 提供了 `DataAccessException` 作为统一的异常层次结构，用于屏蔽底层数据库驱动（如 JDBC、Hibernate）的异常差异。
1. **`DataAccessException` 的特点：**
	- 是一个运行时异常，无需强制捕获。
	- 统一管理数据库操作的异常，便于开发者处理和记录。
2. **常见子类：**
	- `BadSqlGrammarException`：SQL 语法错误。
	- `DataIntegrityViolationException`：违反数据库约束（如唯一键）。
	- `EmptyResultDataAccessException`：查询结果为空。
3. **示例：**
	```java
	try {
	    String sql = "SELECT name FROM users WHERE id = ?";
	    jdbcTemplate.queryForObject(sql, new Object[]{1}, String.class);
	} catch (DataAccessException e) {
	    System.err.println("Database error: " + e.getMessage());
	}
	```
##### **2. MVC 异常处理**
###### **2.1 局部异常处理**
1. **`@ExceptionHandler` 注解：**
	通过在控制器中添加 `@ExceptionHandler` 方法，处理特定的异常：
	```java
	@Controller
	public class MyController {
	    @RequestMapping("/test")
	    public String test() {
	        throw new IllegalArgumentException("Invalid argument!");
	    }
	    @ExceptionHandler(IllegalArgumentException.class)
	    public String handleIllegalArgumentException(IllegalArgumentException ex, Model model) {
	        model.addAttribute("error", ex.getMessage());
	        return "errorPage";
	    }
	}
	```

###### **2.2 全局异常处理**

1. **`@ControllerAdvice` 注解：**
	`@ControllerAdvice` 用于定义全局异常处理器，可以跨控制器捕获异常：
	```java
	@ControllerAdvice
	public class GlobalExceptionHandler {
	    @ExceptionHandler(Exception.class)
	    public String handleException(Exception ex, Model model) {
	        model.addAttribute("error", ex.getMessage());
	        return "globalErrorPage";
	    }
	}
	```

###### **2.3 自定义异常解析器**

1. **实现 `HandlerExceptionResolver` 接口：**
	Spring 提供 `HandlerExceptionResolver`，允许开发者自定义异常解析逻辑：
	```java
	public class CustomExceptionResolver implements HandlerExceptionResolver {
	    @Override
	    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
	        ModelAndView mav = new ModelAndView("errorPage");
	        mav.addObject("error", ex.getMessage());
	        return mav;
	    }
	}
	```
2. **注册自定义解析器：**
	在 Spring 配置文件中注册：
	```java
	@Configuration
	public class AppConfig implements WebMvcConfigurer {
	    @Override
	    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
	        resolvers.add(new CustomExceptionResolver());
	    }
	}
	```


----
#### 延伸问答
1. **`@ExceptionHandler` 和 `@ControllerAdvice` 的区别？**
	- `@ExceptionHandler` 是局部异常处理，仅适用于当前控制器。
	- `@ControllerAdvice` 是全局异常处理，可以跨控制器捕获异常。
2. **Spring Boot 如何简化异常处理？**
	- 提供默认的全局异常处理机制（如 `ErrorController`）。
	- 可通过 `@RestControllerAdvice` 处理 RESTful API 的异常，返回 JSON 格式的错误信息。
3. **如何在 RESTful 应用中返回标准化的错误信息？**
	- 使用 `@RestControllerAdvice` 和 `@ExceptionHandler`：
		```java
		@RestControllerAdvice
		public class RestExceptionHandler {
		    @ExceptionHandler(IllegalArgumentException.class)
		    public ResponseEntity<Map<String, String>> handleIllegalArgument(IllegalArgumentException ex) {
		        Map<String, String> error = new HashMap<>();
		        error.put("message", ex.getMessage());
		        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
		    }
		}
		```
### [Spring框架中如何配置和使用自定义的PropertyPlaceholderConfigurer？](https://notes.kamacoder.com/questions/500549)
#### 简洁回答
`PropertyPlaceholderConfigurer` 是 Spring 中用于解析占位符 (`${}`) 并注入外部属性值的工具。通过配置它，可以加载自定义的属性文件，将外部配置注入到 Spring Bean 中。
`PropertyPlaceholderConfigurer` 提供了灵活的外部配置加载方式，适用于传统 XML 配置项目，但在现代 Spring 应用中已被注解和环境配置替代。

----

#### 详细回答
#####  **1. 配置自定义的 `PropertyPlaceholderConfigurer`**
1. **添加自定义属性文件：** 创建一个 `custom.properties` 文件：
	```properties
	app.name=MyCustomApp
	app.version=2.0
	```
2. **XML 配置方式：** 在 Spring 配置文件中声明 `PropertyPlaceholderConfigurer`：
	```xml
	<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	    <property name="locations">
	        <list>
	            <value>classpath:custom.properties</value>
	        </list>
	    </property>
	</bean>
	```
3. **Java 配置方式：** 使用 `@Bean` 创建 `PropertyPlaceholderConfigurer`：
	```java
	@Configuration
	public class AppConfig {
	    @Bean
	    public static PropertyPlaceholderConfigurer propertyPlaceholderConfigurer() {
	        PropertyPlaceholderConfigurer configurer = new PropertyPlaceholderConfigurer();
	        configurer.setLocation(new ClassPathResource("custom.properties"));
	        return configurer;
	    }
	}
	```

##### **2. 使用属性值**
1. **注入属性值：** 使用 `@Value` 注解注入属性值：
	```java
	@Component
	public class MyBean {
	    @Value("${app.name}")
	    private String appName;
	    @Value("${app.version}")
	    private String appVersion;
	    public void printProperties() {
	        System.out.println("App Name: " + appName);
	        System.out.println("App Version: " + appVersion);
	    }
	}
	```
2. **注入到 XML Bean：** 使用占位符配置 XML 中的属性：
	```xml
	<bean id="myBean" class="com.example.MyBean">
	    <property name="appName" value="${app.name}" />
	    <property name="appVersion" value="${app.version}" />
	</bean>
	```

----

#### 延申问答
- [ ] **如何支持多个属性文件？**
	在 `locations` 中配置多个文件路径：
	```xml
	<bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	    <property name="locations">
	        <list>
	            <value>classpath:custom.properties</value>
	            <value>classpath:application.properties</value>
	        </list>
	    </property>
	</bean>
	```
- [ ] **如何设置占位符解析失败时的默认行为？**
	配置 `ignoreUnresolvablePlaceholders` 属性，防止未解析占位符抛出异常：
	`configurer.setIgnoreUnresolvablePlaceholders(true);`
- [ ] **`PropertyPlaceholderConfigurer` 与 `@PropertySource` 的区别？**
	- `PropertyPlaceholderConfigurer` 是 XML 配置方式，适合早期 Spring 版本。
	- `@PropertySource` 是基于注解的方式，与现代 Java 配置（`@Configuration`）结合使用。
4. **`PropertyPlaceholderConfigurer` 已过时的替代方案：**
	从 Spring 3.1 开始，推荐使用 `Environment` 和 `@PropertySource` 代替：
	```java
	@Configuration
	@PropertySource("classpath:custom.properties")
	public class AppConfig {
	    @Autowired
	    private Environment env;
	    @Bean
	    public MyBean myBean() {
	        return new MyBean(env.getProperty("app.name"), env.getProperty("app.version"));
	    }
	}
	```
### [Spring框架中的@Value注解是如何工作的？它如何注入属性值？](https://notes.kamacoder.com/questions/500550)
#### 简洁回答

##### 使用示例：
1. **从 `application.properties` 注入值：**
	```properties
	app.name=MyApp
	app.version=1.0
	```
	```java
	@Component
	public class AppConfig {
	    @Value("${app.name}")
	    private String appName;
	    @Value("${app.version}")
	    private String appVersion;
	    public void printConfig() {
	        System.out.println("App Name: " + appName);
	        System.out.println("App Version: " + appVersion);
	    }
	}
	```
2. **注入默认值：** 如果配置属性不存在，可以通过 `:` 指定默认值：
	```java
	@Value("${app.description:Default Description}")
	private String appDescription;
	```
3. **使用 SpEL 表达式：** 支持 Spring 表达式语言（SpEL）进行动态计算：
	```java
	@Value("#{systemProperties['user.home']}")
	private String userHome;
	```

##### 工作原理
1. **属性解析器：** Spring 使用 `PropertySourcesPlaceholderConfigurer` 或 `Environment` 接口解析 `@Value` 注解中的占位符。
2. **解析顺序：**
	- 优先从 `application.properties` 或 `application.yml` 中读取。
	- 支持系统环境变量和 JVM 系统属性。
3. **注入时机：** 属性值在 Bean 实例化阶段（通过 IoC 容器）注入。
### [Spring框架中的BeanPostProcessor接口的作用是什么？](https://notes.kamacoder.com/questions/500551)
#### 知识索引
- **Spring IoC → Bean生命周期 → BeanPostProcessor接口**

----

#### 简洁回答
`BeanPostProcessor` 接口用于在 Bean 初始化前后执行自定义逻辑。通过实现 `postProcessBeforeInitialization` 和 `postProcessAfterInitialization` 方法，可以在 Bean 初始化过程插入额外操作，如属性修改、代理增强等。

----

#### 详细回答
`BeanPostProcessor` 初始化 Bean 时添加自定义逻辑。
1. **接口定义：**
	`BeanPostProcessor` 提供两个回调方法：
	- `postProcessBeforeInitialization`: 在 Bean 初始化方法（如 `@PostConstruct` 或 `afterPropertiesSet`）之前执行。
	- `postProcessAfterInitialization`: 在 Bean 初始化方法之后执行。
	接口定义：
	```java
	public interface BeanPostProcessor {
	    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
	    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
	}
	```
2. **用法示例：**
	自定义一个 `BeanPostProcessor`，在 Bean 初始化前后打印日志：
	```java
	@Component
	public class CustomBeanPostProcessor implements BeanPostProcessor {
	    @Override
	    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
	        System.out.println("Before Initialization: " + beanName);
	        return bean;
	    }
	    @Override
	    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
	        System.out.println("After Initialization: " + beanName);
	        return bean;
	    }
	}
	```
3. **特点：**
	- 可用于修改或替换 Bean 的实例（如动态代理）。
	- 在 Spring 容器中，所有 Bean 都会经过 `BeanPostProcessor` 的处理。
4. **典型应用：**
	- **自动代理机制：** Spring 的 AOP 使用 `BeanPostProcessor` 创建代理对象。
	- **自定义注解解析：** 解析 Bean 中的特定注解并执行相关逻辑。
	- **属性增强：** 在初始化前动态添加或修改属性值。


----

#### 延伸问答
1. **`BeanPostProcessor` 的执行时机是什么？**
	- 在 Bean 的依赖注入完成后、初始化方法执行前后。
	- 不会处理 `@Configuration` 标注的类和部分内部管理的特殊 Bean。
2. **`postProcessBeforeInitialization` 和 `postProcessAfterInitialization` 的区别？**
	- `postProcessBeforeInitialization`: 在初始化方法调用之前执行，适合用于属性值的校验或修改。
	- `postProcessAfterInitialization`: 在初始化方法调用之后执行，适合用于代理增强或其他操作。
3. **如何在项目中禁用特定的 `BeanPostProcessor`？**
	- 可以通过条件注解（如 `@Conditional`）或在配置文件中控制是否注册该 `BeanPostProcessor`。
4. **与 `InitializingBean` 和 `@PostConstruct` 的关系？**
	- `BeanPostProcessor` 是对所有 Bean 的全局增强。
	- 而 `InitializingBean` 和 `@PostConstruct` 是针对某个具体 Bean 的生命周期回调。
### [Spring框架中的FactoryBean接口的作用是什么？](https://notes.kamacoder.com/questions/500552)
#### 简洁回答
- `FactoryBean` 是一种工厂模式的实现，它允许开发者通过实现 `FactoryBean` 接口，自定义 Bean 的创建逻辑。实现该接口的类本身不会作为 Bean，而是由它生成的对象被注入到容器中。
- 适用场景：
	- 创建复杂对象，例如单例模式类的代理对象。
	- 动态配置对象实例，比如根据运行时参数返回不同的 Bean。

----

#### 详细回答
##### `FactoryBean` 接口的主要方法
|方法|作用|
|:-:|:-:|
|`Object getObject()`|定义工厂逻辑，返回创建的对象实例。|
|`Class<?> getObjectType()`|返回工厂生成对象的类型。|
|`boolean isSingleton()`|指定生成的对象是否是单例，返回 `true` 或 `false`。|

----

#### 延申问答
- [ ] **`FactoryBean` 和普通 Bean 的区别？**
	- 普通 Bean：Spring 管理的标准对象，由容器直接实例化。
	- `FactoryBean`：一个创建对象的工厂，它的职责是返回目标对象。
- [ ] **`FactoryBean` 和 `BeanFactory` 的区别？**
	- **`FactoryBean`：** 是用户自定义的工厂类，专注于创建某种特定类型的 Bean。
	- **`BeanFactory`：** 是 Spring 提供的 IOC 容器接口，用于管理和创建 Bean。
- [ ] **常见的内置 `FactoryBean`：**
	- `ProxyFactoryBean`：创建代理对象。
	- `SqlSessionFactoryBean`：用于配置 MyBatis 的 SQL 会话工厂。
	- `JndiObjectFactoryBean`：用于从 JNDI 获取对象。
### [Spring框架中如何配置和使用自定义的Scope？](https://notes.kamacoder.com/questions/500553)
#### 知识索引
- **Spring IoC → Bean作用域 → 自定义Scope**

----

#### 简洁回答
实现步骤如下：
1. **实现 `Scope` 接口：** 定义自定义作用域的逻辑。
2. **注册自定义 Scope：** 使用 `CustomScopeConfigurer` 或 `ConfigurableBeanFactory` 注册。
3. **使用自定义 Scope：** 在 Bean 配置中通过 `@Scope` 指定作用域名称。

----

#### 详细回答
##### **1. 实现自定义 Scope**
自定义 Scope 需要实现 `org.springframework.beans.factory.config.Scope` 接口，主要方法包括：
- `Object get(String name, ObjectFactory<?> objectFactory)`：返回作用域内的对象，如果没有则创建。
- `Object remove(String name)`：移除作用域内的对象。
- `String getConversationId()`：返回作用域的标识。

----

##### **2. 注册自定义 Scope**
###### 配置方式一：通过 `CustomScopeConfigurer`

使用 `CustomScopeConfigurer` 注册：
```java
@Configuration
public class ScopeConfig {

    @Bean
    public static CustomScopeConfigurer customScopeConfigurer() {
        CustomScopeConfigurer configurer = new CustomScopeConfigurer();
        configurer.addScope("thread-local", new ThreadLocalScope());
        return configurer;
    }
}
```

###### 配置方式二：直接使用 `ConfigurableBeanFactory`
```java
@Configuration
public class ScopeConfig {

    @Bean
    public BeanFactoryPostProcessor scopePostProcessor() {
        return (beanFactory) -> {
            if (beanFactory instanceof ConfigurableBeanFactory) {
                ((ConfigurableBeanFactory) beanFactory).registerScope("thread-local", new ThreadLocalScope());
            }
        };
    }
}
```

##### **3. 使用自定义 Scope**
```java
@Component
@Scope("thread-local")
public class MyThreadLocalBean {
    public void doSomething() {
        System.out.println("Instance: " + this);
    }
}
```
XML 配置方式：
`<bean id="myThreadLocalBean" class="com.example.MyThreadLocalBean" scope="thread-local" />`

----

#### 延申问答
1. **自定义 Scope 的典型应用场景是什么？**
	- **线程作用域：** 每个线程独立的实例（类似 `ThreadLocal`）。
	- **请求作用域：** 模拟 Web 应用中的 HTTP 请求作用域。
	- **会话作用域：** 在非 Web 环境中实现会话级实例管理。
2. **如何支持销毁回调？**
	- 通过 `registerDestructionCallback` 注册销毁逻辑，并在作用域结束时手动调用回调。
3. **与 Spring 内置作用域的区别？**
	- 自定义 Scope 则用于更灵活的场景，如多线程或动态范围。

通过自定义 Scope，Spring 提供了灵活的扩展点来管理 Bean 的生命周期，满足复杂应用的需求。
### [Spring框架中的@Qualifier注解的作用是什么？](https://notes.kamacoder.com/questions/500554)
#### 简洁回答
`@Qualifier` 注解用于在自动装配（`@Autowired`）时指定具体的 Bean：当有多个同类型的 Bean 可供注入时，用于消除歧义，明确指定注入哪个 Bean。
作用：
- 在多 Bean 环境中解决冲突。
- 与 `@Primary` 搭配使用，进一步控制注入逻辑。
### [Spring框架中的@Profile注解是如何实现环境隔离的？](https://notes.kamacoder.com/questions/500555)
#### 知识索引
- **Spring 基础 → 配置管理 → @Profile注解**

----

#### 简洁回答
`@Profile` 注解用于实现环境隔离，通过激活不同的配置文件（如 `dev`、`test`、`prod`），控制哪些 Bean 被加载到 Spring 容器中。它结合 `application.properties` 或编程方式指定当前活跃的环境，实现按需加载。

----

#### 详细回答

##### **1. @Profile 的作用**
`@Profile` 用于指定某些组件或配置类在特定环境下加载。通过设置 `spring.profiles.active` 属性，Spring 会根据激活的环境加载对应的 Bean。

##### **2. 使用方式**
1. 在 Bean 定义中使用
通过 `@Profile` 指定该 Bean 仅在特定环境下加载：
```java
@Configuration
public class AppConfig {

    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new DriverManagerDataSource("jdbc:mysql://localhost:3306/devdb", "dev", "password");
    }

    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        return new DriverManagerDataSource("jdbc:mysql://localhost:3306/proddb", "prod", "password");
    }
}
```
2. 在配置类上使用
标记整个配置类仅在特定环境下生效：
```java
@Profile("test")
@Configuration
public class TestConfig {
    @Bean
    public DataSource testDataSource() {
        return new DriverManagerDataSource("jdbc:h2:mem:testdb", "sa", "");
    }
}
```


##### **3. 激活环境**
1. `application.properties` 或 `application.yml`**
```properties
spring.profiles.active=dev
```

2. 命令行参数
通过启动参数指定环境：
```bash
java -jar app.jar --spring.profiles.active=prod
```

3. 编程方式
在测试或启动代码中通过 `ConfigurableEnvironment` 设置：
```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
    context.getEnvironment().setActiveProfiles("dev");
    context.register(AppConfig.class);
    context.refresh();
}
```

##### **4. 环境隔离的典型场景**
1. **数据库配置：** 在开发、测试、生产环境中使用不同的数据源。
2. **Bean 实例配置：** 根据环境加载不同的实现类，如日志管理（开发用控制台日志，生产用文件日志）。
3. **第三方服务：** 开发时使用 Mock 服务，生产环境使用真实服务。

----

#### 延申问答
1. **`@Profile` 和 `@Conditional` 的区别？**
	- `@Profile` 是基于**环境**的 Bean 加载注解，使用更直观。
	- `@Conditional` 提供更强的条件控制，可结合自定义逻辑控制 Bean 的加载。
2. **如何为默认环境设置 `@Profile`？**
	- 使用 `@Profile("default")`，当未指定激活的 Profile 时加载对应的配置。
3. **多个 Profile 的使用？**
	- 可以同时激活多个 Profile，Spring 会按顺序加载：
		```properties
		spring.profiles.active=dev,test
		```
4. **如何在测试中隔离环境？**
	- 使用 `@ActiveProfiles` 注解指定测试环境：
		```java
		@RunWith(SpringRunner.class)
		@SpringBootTest
		@ActiveProfiles("test")
		public class MyServiceTest {
		}
		```
### [Spring框架中的@Async注解是如何实现异步方法的？](https://notes.kamacoder.com/questions/500556)
#### 知识索引
- **Spring 基础 → 多线程与异步处理 → @Async注解**

----

#### 简洁回答
`@Async` 注解用于将标注的方法声明为异步方法。Spring 会通过代理机制调用这些方法，将其运行在独立的线程中，从而实现异步执行。需要配置 `@EnableAsync` 并提供线程池以支持异步任务的管理。

----

#### 详细回答

##### 使用步骤
1. 启用异步支持
```java
@Configuration
@EnableAsync
public class AsyncConfig {
}
```
2. 定义异步方法
在方法上添加 `@Async` 注解，声明该方法为异步方法：
```java
@Service
public class AsyncService {

    @Async
    public void performAsyncTask() {
        System.out.println("Async Task Start: " + Thread.currentThread().getName());
        try {
            Thread.sleep(2000); // 模拟耗时操作
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Async Task End");
    }
}
```

3. 调用异步方法
通过 Spring 容器管理的 Bean 调用异步方法：
```java
@RestController
public class AsyncController {

    @Autowired
    private AsyncService asyncService;

    @GetMapping("/async")
    public String executeAsync() {
        asyncService.performAsyncTask();
        return "Task Submitted";
    }
}
```

---

##### 配置线程池
Spring 默认使用一个简单的线程池（`SimpleAsyncTaskExecutor`）。为提升性能和控制线程管理，可配置自定义线程池。
```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "customTaskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("CustomExecutor-");
        executor.initialize();
        return executor;
    }
}
```
##### 指定线程池：
```java
@Async("customTaskExecutor")
public void performAsyncTask() {
    System.out.println("Executing with custom executor: " + Thread.currentThread().getName());
}
```

----

##### 特点与限制
1. **基于代理机制：**
	- `@Async` 使用 Spring AOP 代理异步方法，调用方法时，Spring 将其提交给线程池管理。
2. **方法调用限制：**
	- 必须通过 Spring 容器管理的 Bean 调用，直接在同类中调用无法生效。
3. **返回值支持：**
	- 异步方法可以返回 `void` 或 `Future`：
	```java
		@Async
		public CompletableFuture<String> asyncMethod() {
		    return CompletableFuture.completedFuture("Completed");
		}
	```
4. **异常处理：**
	- 异步方法的异常不会直接抛出，可通过 `AsyncUncaughtExceptionHandler` 捕获：
		```java
		@Configuration
		public class AsyncExceptionHandler implements AsyncConfigurer {
		    @Override
		    public void configureAsyncUncaughtExceptionHandler(AsyncUncaughtExceptionHandler handler) {
		        handler = (ex, method, params) -> {
		            System.err.println("Exception in async method: " + method.getName());
		        };
		    }
		}
		```


----

#### 延申问答
1. **如何实现全局异步异常处理？**
	- 通过实现 `AsyncUncaughtExceptionHandler` 接口，集中管理异步任务的未捕获异常。
2. **`@Async` 与自定义线程池的结合方式？**
	- 配置多个线程池，并在 `@Async` 中通过名称指定不同任务使用的线程池。
3. **与 Spring Scheduler 的区别？**
	- `@Async` 是事件驱动的异步处理，通常由方法调用触发。
	- Spring Scheduler 通过 `@Scheduled` 定时触发任务。
4. **如何调试异步任务的执行？**
	- 自定义线程池时设置线程名称前缀，结合日志系统（如 SLF4J）打印线程名称，方便调试。
### [Spring框架中的消息源（MessageSource）是如何工作的？](https://notes.kamacoder.com/questions/500557)
#### 知识索引
- **Spring 基础 → 配置管理 → 消息源（MessageSource）**

----

#### 简洁回答
`MessageSource` 是 Spring 提供的国际化支持接口，用于加载和解析消息资源文件，动态返回对应语言环境（`Locale`）的消息。通过 `getMessage` 方法，开发者可以根据消息键（`code`）、参数（`args`）和语言环境（`Locale`）获取国际化消息。

**`MessageSource` 的作用**
Spring 的 `MessageSource` 接口定义了一种机制，用于根据语言环境（`Locale`）动态加载消息。
- **主要功能：**
	- 管理多语言资源文件（如 `messages_en.properties` 和 `messages_zh.properties`）。
	- 根据用户语言偏好提供对应的消息内容。
### [Spring框架中如何配置和使用自定义的Validator进行表单验证？](https://notes.kamacoder.com/questions/500558)
#### 知识索引
- **Spring MVC → 表单验证与数据绑定 → 自定义 Validator**

----

#### 简洁回答
通过实现 `org.springframework.validation.Validator` 接口，自定义验证逻辑，配置步骤如下：
1. **实现自定义 Validator 类**：编写验证逻辑。
2. **在控制器中注册 Validator**：调用验证器并通过 `BindingResult` 捕获验证结果。
3. **结合注解式验证**：与 `@Valid` 或 `@Validated` 配合使用，实现灵活的验证规则。
### [Spring框架中的@InitBinder注解的作用是什么？](https://notes.kamacoder.com/questions/500559)
#### 知识索引
- **Spring MVC → 控制器相关 → @InitBinder注解**

----
#### 简洁回答
`@InitBinder` 注解用于**初始化Web 数据绑定**，允许定制 Web 请求参数的绑定行为。常用于自定义数据格式转换（如日期格式）或其他字段的绑定规则。

----
#### 详细回答
1. **作用：**
	- `@InitBinder` 可以注册自定义的属性编辑器，用于将**请求参数**自动转换为** Java 对象**。例如，转换日期格式或将字符串转换为特定的对象。
2. **用法：**
	```java
	@Controller
	public class MyController {
	    @InitBinder
	    public void initBinder(WebDataBinder binder) {
	        // 注册自定义日期格式编辑器
	        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
	        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
	    }
	    @RequestMapping("/submit")
	    public String submitForm(@RequestParam Date startDate) {
	        // startDate 会自动根据自定义的格式进行绑定
	        return "formSubmitted";
	    }
	}
	```
3. **特点：**
	- `@InitBinder` 可以绑定到类级别的方法或特定的方法上，控制器中的多个方法可以拥有自己的数据绑定初始化器。
	- 通常用于格式化字段或做类型转换，使得 Web 请求中的数据更加灵活。

----

#### 延伸问答
1. **`@InitBinder` 与 `@ModelAttribute` 的区别：**
	- `@InitBinder` 用于配置数据绑定器，处理**请求参数的转换（如格式化、类型转换）**；
	-  `@ModelAttribute` 用于将请求参数**绑定**到方法参数或模型对象中，通常用于**预处理或填充模型数据**。
2. **如何自定义多个字段的格式化？**
	- 使用 `@InitBinder` 可以通过注册多个 `CustomEditor` 或自定义的 `Converter` 来处理不同类型字段的转换和格式化。
3. **如何处理复杂对象的绑定？**
	- 对于复杂对象，可以通过在 `@InitBinder` 方法中注册多个编辑器，或在自定义的 `PropertyEditor` 中实现更复杂的逻辑，如处理嵌套对象或集合的绑定。
### [Spring框架中的@RequestParam、@PathVariable、@RequestBody等注解的作用是什么？](https://notes.kamacoder.com/questions/500560)
#### 知识索引

- **Spring MVC → 控制器相关 → @RequestParam、@PathVariable、@RequestBody 注解**


----
#### 简洁回答

- `@RequestParam` 用于绑定**请求参数**到方法参数。
- `@PathVariable` 用于从**URL 路径**中提取参数。
- `@RequestBody` 用于将**请求体**中的内容绑定到方法参数，通常用于**处理 JSON 或 XML 数据**。


----
#### 详细回答
1. **@RequestParam**
	- 例如，`/search?keyword=java` 中的 `keyword` 会被绑定到方法参数上。
	```java复制代码
	@RequestMapping("/search")
	public String search(@RequestParam String keyword) {
	    // keyword 会自动绑定到请求中的参数
	    return "searchResult";
	}
	```
2. **@PathVariable**
	- 例如，URL 模式 `/user/{id}`，`id` 会绑定到方法参数中。
	```java
	@RequestMapping("/user/{id}")
	public String getUser(@PathVariable("id") Long userId) {
	    // userId 会自动绑定到路径中的 id 变量
	    return "userDetails";
	}
	```
3. **@RequestBody**
	- 用于将 HTTP 请求体中的数据绑定到方法参数，通常用于处理 JSON 或 XML 格式的数据。
	- 在 RESTful 风格的 API 中常用，用于接收客户端传递的对象。
	```java
	@PostMapping("/user")
	public String createUser(@RequestBody User user) {
	    // user 会从请求体中解析并绑定到参数
	    return "userCreated";
	}
	```


----
#### 延伸问答
1. **`@RequestParam` 和 `@PathVariable` 的区别：**
	- `@RequestParam` 绑定的是查询参数或表单数据
	-  `@PathVariable` 绑定的是路径中的变量。
2. **`@RequestBody` 在处理 JSON 数据时的常见用法：**
	- 需要配置 `HttpMessageConverter`，Spring 会自动将请求体中的 JSON 数据转换为 Java 对象，反之亦然。
### [Spring框架中如何配置和使用自定义的HandlerInterceptor？](https://notes.kamacoder.com/questions/500561)
#### 知识索引
- **Spring MVC → 拦截器机制 → 自定义 HandlerInterceptor**

----

#### 简洁回答
Spring 的 `HandlerInterceptor` 接口用于拦截 HTTP 请求，允许在控制器方法执行前后插入逻辑。实现步骤：
1. **实现 `HandlerInterceptor` 接口**：编写自定义拦截器。
2. **注册拦截器**：通过实现 `WebMvcConfigurer`，在 `addInterceptors` 方法中注册。
3. **配置拦截路径**：指定拦截器应用的 URL 路径模式。
### [Spring框架中的@ResponseBody注解的作用是什么？](https://notes.kamacoder.com/questions/500562)
#### 知识索引

- **Spring MVC → 控制器相关 → @ResponseBody 注解**


----
#### 简洁回答

`@ResponseBody` 注解用于将控制器方法的**返回值**直接写入 **HTTP 响应体**，而不是解析为视图。通常用于构建 RESTful API，返回 JSON、XML 或其他类型的数据。通常与 `@RequestMapping` 或其他请求映射注解一起使用。


----
#### 详细回答
1. **作用：**
	- 将方法的返回对象转换为指定格式（如 JSON、XML）并直接写入响应体。
	- 在处理 RESTful API 请求时特别常用，可以返回数据而不需要视图解析。
2. **用法：**
	```java
	@RestController
	public class MyController {
	    @RequestMapping("/user")
	    @ResponseBody
	    public User getUser() {
	        User user = new User("John", 30);
	        return user; // 返回的数据会被转换为 JSON 格式并写入响应体
	    }
	}
	```
3. **与 `@RestController` 的关系：**
	- `@RestController` 是 `@Controller` 和 `@ResponseBody` 的组合注解，表示该类中的每个方法都默认以 `@ResponseBody` 方式处理返回值。


----
#### 延伸问答

1. **`@ResponseBody` 与 `@RequestBody` 的区别：**
	- `@RequestBody` 用于将**请求体**中的数据绑定到方法参数
	- `@ResponseBody` 用于将方法的返回值写入**响应体**。
2. **如何设置 `@ResponseBody` 返回 JSON 格式：**
	- Spring 会自动根据方法返回类型和请求头中的 `Accept` 字段来决定返回的数据格式（默认 JSON）。可以使用 `@JsonFormat` 等注解控制返回的 JSON 格式。
### [Spring框架中如何配置和使用自定义的HttpMessageConverter？](https://notes.kamacoder.com/questions/500563)
#### 知识索引
- **Spring MVC → 数据绑定与转换 → 自定义 HttpMessageConverter**

----

#### 简洁回答

自定义 `HttpMessageConverter` 是为了扩展 Spring MVC 的数据转换功能，用于将请求数据解析为对象或将响应对象转换为特定格式。实现步骤：
1. **实现 `HttpMessageConverter` 接口**：定义自定义的数据解析和写入逻辑。
2. **注册自定义 Converter**：通过 `WebMvcConfigurer` 的 `configureMessageConverters` 方法将其添加到 Spring 的转换链中。
3. **测试自定义格式**：验证其支持的 MIME 类型或数据格式。
### [Spring框架中的@ModelAttribute在方法参数和返回值上的作用有何不同？](https://notes.kamacoder.com/questions/500564)
#### 知识索引
- **Spring MVC → 参数绑定与模型管理 → @ModelAttribute**

----

#### 简洁回答
- **用于方法参数**：将请求中的参数绑定到模型对象，并直接作为方法参数传入控制器方法。应用：处理表单提交时，将多个请求参数绑定到一个对象。
- **用于方法级别**：在控制器方法执行前，预先填充模型数据，将返回值加入到模型中供视图使用。应用：准备通用的模型数据（如下拉列表、表单数据等），以便在视图中共享这些数据。
### [Spring框架中如何配置和使用自定义的PropertyEditor？](https://notes.kamacoder.com/questions/500565)
#### 知识索引
- **Spring 基础 → 数据绑定与类型转换 → 自定义 PropertyEditor**

----

#### 简洁回答
自定义 `PropertyEditor` 用于扩展 Spring 的数据绑定机制，适配特殊的数据类型转换。实现步骤：
1. **实现 `PropertyEditorSupport` 子类**：定义转换逻辑。
2. **注册 `PropertyEditor`**：通过 `@InitBinder` 方法将自定义的 `PropertyEditor` 注册到 `WebDataBinder` 中。
3. **使用自定义类型**：自动将请求参数绑定到目标对象的复杂类型字段。
### [Spring框架中的@RequiredArgsConstructor、@AllArgsConstructor等Lombok注解与Spring的集成是怎样的？](https://notes.kamacoder.com/questions/500566)
#### 知识索引
- **Spring 基础 → 工具与集成 → Lombok 注解**

----

#### 简洁回答
Lombok 的 `@RequiredArgsConstructor` 和 `@AllArgsConstructor` 注解可生成构造函数，减少样板代码。与 Spring 集成时，这些注解可自动生成依赖注入所需的构造函数，结合 `@Component`、`@Service` 等注解，支持构造器注入，尤其适用于依赖项不可变的场景。
### [Spring框架中如何配置和使用自定义的ApplicationContextInitializer？](https://notes.kamacoder.com/questions/500567)
#### 知识索引
- **Spring 核心 → 容器扩展机制 → ApplicationContextInitializer**

----

#### 简洁回答
`ApplicationContextInitializer` 是 Spring 提供的扩展点，用于在 `ApplicationContext` 刷新之前进行初始化配置。
配置和使用步骤：
1. **实现 `ApplicationContextInitializer` 接口**：定义初始化逻辑。
2. **注册自定义初始化器**：通过 `META-INF/spring.factories` 文件、代码注册或 Spring Boot 配置激活。
3. **应用场景**：动态修改环境变量、注册 Bean、设置属性等。
### [Spring框架中的@Lazy注解的作用是什么？](https://notes.kamacoder.com/questions/500568)
#### 简洁回答
`@Lazy` 注解用于延迟加载 Bean：只有在第一次访问该 Bean 时，Spring 才会初始化它，而不是在容器启动时立即创建。
有助于在 Bean 的初始化成本较高或并非总是需要的情况下优化启动性能。

----

#### 详细回答
##### 使用方式
1. **类级别：** 在类上使用 `@Lazy`，标记该类的所有 Bean 都采用延迟加载策略。
2. **方法级别：** 在 `@Bean` 方法上使用 `@Lazy`，延迟加载特定的 Bean。
3. **依赖注入中的延迟加载：** 延迟注入某个依赖，通过 `@Lazy` 标注在字段或参数上。
4. **与 `@Configuration` 配合：** 在整个配置类上使用 `@Lazy`，延迟加载配置类内的所有 Bean。

##### 应用场景
1. **性能优化：** 在大型项目中，有些 Bean 初始化较耗时但并非启动时必须加载，比如某些外部服务的连接配置或缓存管理 Bean。
2. **减少启动时间：** 延迟加载的 Bean 可以显著降低应用启动时间，特别是开发和测试环境中。
3. **解决循环依赖：** 对于发生循环依赖的 Bean，可以使用 `@Lazy` 延迟初始化一个 Bean，以打破依赖循环。

----

#### 延伸问答
- [ ] **@Lazy 是否适用于所有 Bean 作用域？**
	- **单例作用域（`singleton`）：** `@Lazy` 通常与单例作用域一起使用，效果最佳。
	- **非单例作用域（如 `prototype`）：** 无需使用 `@Lazy`，因为 `prototype` 本身就按需实例化。
- [ ] **@Lazy 与惰性初始化（Lazy Initialization）的区别？**
	- `@Lazy` 是针对特定 Bean 的延迟加载。
	- 全局惰性初始化可以通过配置文件启用：`spring.main.lazy-initialization=true`
3. **@Lazy 的局限性：**
	- 仅在第一次访问时延迟加载，之后的访问不会延迟。
	- 如果 Bean 是通过反射、拦截器等间接访问，可能会导致未按预期加载。
### [Spring框架中如何配置和使用自定义的BeanPostProcessor来修改Bean的属性或行为？](https://notes.kamacoder.com/questions/500569)
#### 知识索引
- **Spring IoC → Bean 生命周期扩展 → BeanPostProcessor**

----

#### 简洁回答
`BeanPostProcessor` 是 Spring 提供的扩展点接口，允许在 Bean 初始化前后插入自定义逻辑，修改 Bean 的属性或行为。
1. **实现 `BeanPostProcessor` 接口**：覆盖 `postProcessBeforeInitialization` 和 `postProcessAfterInitialization` 方法。
2. **注册自定义处理器**：通过配置类或 Spring 自动扫描注册处理器。
3. **应用场景**：增强 Bean 功能（如动态代理、属性注入等）。
### [Spring框架中如何管理事务的隔离级别和传播行为？请举例说明。](https://notes.kamacoder.com/questions/500570)
##### 事务隔离级别（Isolation）（5）

Spring 提供了五种事务隔离级别`@Transactional(isolation = Isolation.XXX)`：
1. **DEFAULT：**通常默认为 `READ_COMMITTED`。
2. **READ_UNCOMMITTED（读未提交）：**最低的隔离级别，允许事务读取尚未提交的数据，可能导致脏读、不可重复读和幻读。
3. **READ_COMMITTED（读已提交，默认）：**仅允许读取已经提交的数据，**避免了脏读**，但可能会出现不可重复读和幻读问题。
4. **REPEATABLE_READ（可重复读）：**确保在同一个事务内的多次读取结果一致，**避免脏读和不可重复读**，但可能会有幻读问题。
5. **SERIALIZABLE（可串行化）：**最高的隔离级别，通过强制事务按顺序执行，**完全避免脏读、不可重复读和幻读**，代价是性能显著下降。


|隔离级别|脏读|不可重复读|幻读|
|:-:|:-:|:-:|:-:|
|READ_UNCOMMITTED|是|是|是|
|READ_COMMITTED|否|是|是|
|REPEATABLE_READ|否|否|是|
|SERIALIZABLE|否|否|否|
- **脏读（Dirty Read）**：一个事务读取了另一个**尚未提交的事务的数据**，如果该事务**回滚**，则数据是**不一致**的。
- **不可重复读（Non-repeatable Read）**：在同一事务内的多次读取，前后**数据**不一致，因为其他事务**修改了**该数据并提交。
- **幻读（Phantom Read）**：在一个事务内的多次查询，查询**结果集**不同，因为其他事务**插入或删除了数据**。


##### 事务传播行为（Propagation）（7）

`@Transactional(propagation = Propagation.REQUIRES_NEW)`
1. **PROPAGATION_REQUIRED（默认）：** 如果当前存在事务，则用当前事务，如果没有事务则新起一个事务
2. **PROPAGATION_SUPPORTS：** 支持当前事务，如果不存在，则以非事务方式执行
3. **PROPAGATION_MANDATORY：** 支持当前事务，如果不存在，则抛出异常
	- 应用场景：必须在现有事务中执行的场景。常用于**确保方法调用链的一致性**。
4. **PROPAGATION_REQUIRES_NEW：** 创建一个新事务，如果存在当前事务，则挂起当前事务
	- 应用场景：**日志记录、通知服务**等。即使主事务失败，独立事务的操作也应该成功执行。
5. **PROPAGATION_NOT_SUPPORTED：** 不支持当前事务，始终以非事务方式执行
	- 应用场景：需要明确禁止事务的场景，比如**读取配置信息、不需要事务控制的数据查询**。
6. **PROPAGATION_NEVER：** 不支持当前事务，如果当前存在事务，则抛出异常
	- 应用场景：需要保证绝对没有事务的场景，比如某些**不允许在事务中执行的数据库操作**。
7. **PROPAGATION_NESTED：** 如果当前事务存在，则在嵌套事务中执行，内层事务依赖外层事务，如果外层失败，则会回滚内层，内层失败不影响外层。
	- 应用场景：需要部分回滚或局部事务的业务逻辑。比如，**订单中的部分操作可能会失败，但不希望整个订单回滚**。

**用途：**
1. **控制事务的传播和嵌套**：根据具体业务需求，可以指定是否使用现有事务或开启新的事务，解决事务的传播问题。
2. **确保独立操作的事务隔离**：某些操作（如日志记录、发送通知）应当独立于主事务执行，即使主事务失败，这些操作也可以成功完成。
3. **控制事务的边界和一致性**：不同的业务场景可能需要不同的事务边界，例如强制某个方法必须在事务中执行，或者确保某个方法永远不在事务中运行。
### [解释Spring框架中的循环依赖问题，并说明Spring是如何解决Bean之间的循环依赖的。](https://notes.kamacoder.com/questions/500571)
#### 简洁回答
- 循环依赖问题是指多个 Bean 循环引用、相互依赖，导致 Spring 容器无法正常初始化它们。
- Spring 通过 **三级缓存机制** 来解决循环依赖，如果发生循环依赖的话，就去 三级缓存`singletonFactories`中拿到三级缓存中存储的`ObjectFactory`并调用它的`getObject()`方法来获取这个循环依赖对象的**前期暴露对象**（虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了），并且放到二级缓存中，这样在循环依赖时，就不会重复初始化了！

----

#### 详细回答
##### Spring三级缓存机制
1. **一级缓存（singletonObjects）：** 存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。（原型 Bean 不在里面）
2. **二级缓存（earlySingletonObjects）：** 存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中ObjectFactory产生的对象，与三级缓存配合使用，，可以防止 AOP 的情况下，每次调用ObjectFactory.getObject()都是会产生新的代理对象。
3. **三级缓存（singletonFactories）：** 存放ObjectFactory，ObjectFactory的getObject()方法（最终调用的是getEarlyBeanReference()方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。

##### Spring 创建 Bean 的流程
1. 先去 **一级缓存 `singletonObjects`** 中获取，存在就返回；
2. 如果不存在或者对象正在创建中，于是去 **二级缓存 `earlySingletonObjects`** 中获取；
3. 如果还没有获取到，就去 **三级缓存 `singletonFactories`** 中获取，通过执行 `ObjectFacotry` 的 `getObject()` 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中。
- **举例：** 
	1. 当 Spring 创建 A 之后，发现 A 依赖了 B ，又去创建 B，B 依赖了 A ，又去创建 A；
	2. 在 B 创建 A 的时候，那么此时 A 就发生了循环依赖，由于 A 此时还没有初始化完成，因此在 一二级缓存 中肯定没有 A；
	3. 那么此时就去三级缓存中调用 getObject() 方法去获取 A 的 前期暴露的对象 ，也就是调用上边加入的 getEarlyBeanReference() 方法，生成一个 A 的 前期暴露对象；
	4. 然后就将这个 ObjectFactory 从三级缓存中移除，并且将前期暴露对象放入到二级缓存中，那么 B 就将这个前期暴露对象注入到依赖，来支持循环依赖。
	5. 完成 `BeanB` 的初始化后，`BeanA` 的初始化继续完成。

##### 只用两级缓存够吗？
在没有 AOP 的情况下，可以只使用一级和三级缓存来解决循环依赖问题。但当涉及到 AOP 时，二级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了“同一个 Bean 有多个代理对象”的问题。

##### 注意事项 
1. 增加了内存开销（需要维护三级缓存，也就是三个 Map），降低了性能（需要进行多次检查和转换）
2. Spring 三级缓存机制仅适用于单例 Bean。对于非单例的 bean 和`@Async`注解的 bean不支持循环依赖，会抛出异常。
3. 如果循环依赖发生在构造器注入时，Spring 无法通过三级缓存解决，因为 Bean 在构造器阶段需要完全实例化。


----

#### 延伸问答
- [ ] **SpringBoot 允许循环依赖发生么？**
	- SpringBoot 2.6 默认允许循环依赖，SpringBoot 2.6以后官方不再推荐。（循环依赖本身就是一种设计缺陷，不应忽视编码的规范和质量。）
	- SpringBoot 2.6以后的循环依赖解决方式：
		1. （暴力）可以通过配置设置允许循环依赖存在：`spring.main.allow-circular-references=true`
		2. （推荐）在导致循环依赖的 Bean 上添加 `@Lazy` 注解标识需要懒加载/延迟加载
- [ ] **构造器注入的循环依赖如何解决？**
	- 使用 `@Lazy` 标识需要懒加载/延迟加载
### [Spring框架中的@Primary注解的作用是什么？在哪些场景下会用到它？](https://notes.kamacoder.com/questions/500572)
@Qualifier和@Primary的都是解决 Bean 注入时的歧义问题，即当一个接口有多个实现时，Spring 无法确定该注入哪个具体的 Bean
- @Qualifier指定名称选择对应的实现 Bean。
- @Primary 指定默认注入哪个 Bean。
- @Qualifier 可以覆盖 @Primary 的默认行为。
### [Spring框架中如何配置和使用JTA（Java Transaction API）进行分布式事务管理？](https://notes.kamacoder.com/questions/500573)
#### 知识索引
- **Spring 事务管理 → 分布式事务管理 → JTA**

----

#### 简洁回答
JTA（Java Transaction API）是一种标准的事务管理 API，用于分布式事务管理。Spring 通过 `PlatformTransactionManager` 和 JTA 的实现（如 Atomikos、Bitronix 或 JTA 的默认实现）支持分布式事务。配置步骤：
1. 配置 JTA 事务管理器（如 Atomikos）。
2. 设置 `JtaTransactionManager` 并整合数据源。
3. 在代码中通过注解（`@Transactional`）或编程方式管理分布式事务。
### [Spring框架中的ApplicationContext和BeanFactory有什么区别？](https://notes.kamacoder.com/questions/500574)
#### 知识索引
- **Spring IoC → 容器实现与扩展 → ApplicationContext 和 BeanFactory**

----

#### 简洁回答
- **`BeanFactory`** 是 Spring 的基础 IoC 容器，提供 Bean 的创建与管理功能，延迟加载 Bean。
- **`ApplicationContext`** 是 `BeanFactory` 的扩展，添加了国际化、事件发布、AOP 等高级功能，默认预加载所有单例 Bean。
- 一般推荐使用 `ApplicationContext`，除非有资源受限的特殊需求。
### [Spring框架中如何配置和使用自定义的ApplicationContextListener？](https://notes.kamacoder.com/questions/500575)
#### 知识索引
- **Spring 核心 → 容器扩展机制 → ApplicationContextListener**

----

#### 简洁回答
`ApplicationListener` 是 Spring 提供的事件监听接口，用于监听容器中的事件，例如上下文刷新、启动或关闭。
配置和使用步骤：
1. **实现 `ApplicationListener` 接口**：定义事件处理逻辑。
2. **注册监听器**：通过代码、注解或配置文件将监听器注册到容器中。
3. **触发事件**：监听内置事件或自定义事件。
### [Spring框架中的@Cacheable、@CachePut、@CacheEvict注解的作用是什么？如何配置Spring Cache？](https://notes.kamacoder.com/questions/500576)
#### 知识索引
- **Spring 核心 → 缓存管理 → @Cacheable、@CachePut、@CacheEvict**

----

#### 简洁回答
- **`@Cacheable`**：方法执行前检查缓存，若存在缓存数据则直接返回，否则执行方法并将结果缓存。
- **`@CachePut`**：每次执行方法并将结果更新到缓存中。
- **`@CacheEvict`**：用于移除缓存数据，可清除单个或多个缓存条目。

**配置 Spring Cache：**
1. 启用缓存：使用 `@EnableCaching`。
2. 配置缓存实现（如 ConcurrentMap、Redis、EhCache）。
3. 使用注解标记缓存逻辑。
### [Spring框架中如何配置和使用自定义的PropertySourcesPlaceholderConfigurer？](https://notes.kamacoder.com/questions/500577)
#### 知识索引
- **Spring 基础 → 配置管理 → PropertySourcesPlaceholderConfigurer**

----

#### 简洁回答
`PropertySourcesPlaceholderConfigurer` 是 Spring 提供的类，用于解析 `@Value` 注解或 XML 配置文件中的占位符（如 `${property}`）。
配置和使用步骤：
1. **定义 Bean**：在配置类或 XML 文件中注册 `PropertySourcesPlaceholderConfigurer`。
2. **加载自定义配置源**：通过设置 `location` 或自定义 `PropertySource` 加载外部配置文件。
3. **结合 `@Value` 注解使用**：动态注入属性值。
### [Spring框架中的@Scheduled注解是如何实现定时任务的？如何配置定时任务的执行计划？](https://notes.kamacoder.com/questions/500578)
#### 知识索引
- **Spring 核心 → 调度任务 → @Scheduled**

----

#### 简洁回答
`@Scheduled` 注解用于标记定时任务，支持多种触发机制：固定间隔、延迟执行、Cron 表达式等。
配置步骤：
1. 启用定时任务：使用 `@EnableScheduling` 注解。
2. 使用 `@Scheduled` 注解标记方法，指定执行计划。
3. 配置执行计划：可通过属性如 `fixedRate`、`cron` 等设置。
### [Spring框架中如何配置和使用自定义的EmbeddedValueResolver？](https://notes.kamacoder.com/questions/500579)
#### 知识索引
- **Spring 核心 → 配置管理 → EmbeddedValueResolver**

----

#### 简洁回答
`EmbeddedValueResolver` 是 Spring 提供的一个类，用于解析 `String` 中的占位符。它结合 `PropertyPlaceholderConfigurer` 或 `@Value` 注解，解析和替换字符串中的占位符（例如 `${property}`）。
配置步骤：
1. **创建 `EmbeddedValueResolver` 实例**，并传入 `ApplicationContext`。
2. **调用 `resolveStringValue` 方法** 解析带占位符的字符串。
### [Spring框架中的@Import注解的作用是什么？它如何导入其他配置类？](https://notes.kamacoder.com/questions/500580)
#### 知识索引
- **Spring 核心 → 配置管理 → @Import**

----

#### 简洁回答
`@Import` 注解用于导入其他配置类、组件或 Java 配置文件，使其成为当前应用上下文的一部分。
它可以用来导入：
- 配置类（`@Configuration` 注解的类）。
- `ImportSelector` 或 `ImportBeanDefinitionRegistrar` 定义的组件。
### [Spring框架中如何配置和使用自定义的ConversionService进行类型转换？](https://notes.kamacoder.com/questions/500581)
#### 知识索引
- **Spring 核心 → 数据绑定与转换 → ConversionService**

----

#### 简洁回答
`ConversionService` 用于在 Spring 中执行类型转换操作，可以通过自定义 `Converter` 或 `Formatter` 来扩展它的功能。
配置步骤：
1. 定义自定义的 `Converter` 或 `Formatter`。
2. 配置 `ConversionService`，并将其注入到 Spring 容器中。
3. 在数据绑定或其他需要类型转换的地方使用该 `ConversionService`。
### [Spring框架中的@Conditional注解是如何实现条件化Bean创建的？](https://notes.kamacoder.com/questions/500582)
#### @Conditional条件加载Bean

**主要作用**
- **有条件地加载 Bean**：`@Conditional` 根据某个条件来决定某个 Bean 是否需要注入到 Spring 容器中。条件可以是操作系统类型、类路径是否存在某个类、某个属性的值等。
- **实现动态配置**：可以根据环境（如开发、测试、生产）或特定上下文条件动态装配 Bean，避免不必要的 Bean 被加载。

**使用场景**
- 在不同的操作系统或环境中注入不同的 Bean。
- 根据应用程序的配置文件、属性值来动态启用某些功能。
- 在条件满足时，才装配某些依赖或服务。

**常见的内置条件**
- `@ConditionalOnProperty` 用于根据配置文件中的某个属性值来决定是否装配 Bean。常用于启用或禁用某些功能模块。
- `@ConditionalOnClass` 用于判断类路径中是否存在某个类。如果存在，则装配相应的 Bean。
- `@ConditionalOnMissingBean` 用于当容器中不存在某个类型的 Bean 时，才注册当前的 Bean。可以用来避免重复注册 Bean。
- `@ConditionalOnBean` 的作用与 `@ConditionalOnMissingBean` 相反，用于当容器中存在某个类型的 Bean 时，才装配当前的 Bean。

```
// 自定义条件类
public class OnLinuxCondition implements Condition {
 &nbsp; &nbsp;@Override
 &nbsp; &nbsp;public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
 &nbsp; &nbsp; &nbsp; &nbsp;return System.getProperty("os.name").contains("Linux");
 &nbsp;  }
}
```
```
// 在配置类中使用
@Configuration
public class AppConfig {
 &nbsp; &nbsp;@Bean
 &nbsp; &nbsp;@Conditional(OnLinuxCondition.class)
 &nbsp; &nbsp;public MyService myService() {
 &nbsp; &nbsp; &nbsp; &nbsp;return new MyService();
 &nbsp;  }
}
```
### [Spring框架中如何配置和使用自定义的EmbeddedDatabaseBuilder来创建嵌入式数据库？](https://notes.kamacoder.com/questions/500583)
#### 知识索引
- **Spring 数据访问 → 数据源配置 → EmbeddedDatabaseBuilder**

----

#### 简洁回答
`EmbeddedDatabaseBuilder` 用于在 Spring 中创建嵌入式数据库（如 H2、HSQL、Derby）。它简化了数据库配置，允许在应用程序中嵌入一个数据库，而不需要外部数据库服务。
配置步骤：
1. 使用 `EmbeddedDatabaseBuilder` 配置数据库类型和属性。
2. 创建 `EmbeddedDatabase` 实例，并通过 Spring 配置类注入数据源。
### [Spring框架中的@EnableAspectJAutoProxy注解的作用是什么？它如何启用AspectJ自动代理？](https://notes.kamacoder.com/questions/500584)
#### 知识索引
- **Spring AOP → AOP 配置 → @EnableAspectJAutoProxy**

----

#### 简洁回答
`@EnableAspectJAutoProxy` 注解用于启用 AspectJ 自动代理功能，使 Spring AOP 框架能够自动为标注了 `@Aspect` 注解的类创建代理对象。
配置步骤：
1. 在配置类中添加 `@EnableAspectJAutoProxy` 注解。
2. 标注 `@Aspect` 的类作为切面类使用。
### [Spring框架中如何配置和使用自定义的ResourceLoader来加载资源？](https://notes.kamacoder.com/questions/500585)
#### 知识索引
- **Spring 核心 → 资源管理 → ResourceLoader**

----

#### 简洁回答
`ResourceLoader` 用于加载应用程序中的资源（如文件、类路径资源、URL 资源等）。可以通过实现 `ResourceLoader` 或使用 Spring 提供的 `DefaultResourceLoader` 来加载资源。
配置步骤：
1. 创建并注入自定义的 `ResourceLoader` 实例。
2. 使用 `ResourceLoader` 的 `getResource()` 方法加载资源。
### [Spring框架中的@EnableTransactionManagement注解的作用是什么？它如何启用声明式事务管理？](https://notes.kamacoder.com/questions/500586)
#### 知识索引
- **Spring 核心 → 事务管理 → @EnableTransactionManagement**

----

#### 简洁回答
`@EnableTransactionManagement` 注解用于启用 Spring 的声明式事务管理。它会自动为带有 `@Transactional` 注解的方法提供事务支持。
配置步骤：
1. 在配置类上添加 `@EnableTransactionManagement` 注解。
2. 配置 `DataSource` 和 `PlatformTransactionManager`，并在方法上使用 `@Transactional` 来管理事务。
### [Spring框架中如何配置和使用自定义的MessageSourceAccessor来访问国际化消息？](https://notes.kamacoder.com/questions/500587)
#### 知识索引
- **Spring 国际化 → 消息资源 → MessageSourceAccessor**

----

#### 简洁回答
`MessageSourceAccessor` 是 Spring 提供的一个工具类，用于简化访问国际化消息的操作。它通过 `MessageSource` 提供消息资源的访问，通常用于在代码中动态获取国际化的消息。
配置步骤：
1. 配置 `MessageSource` Bean。
2. 使用 `MessageSourceAccessor` 获取国际化消息。
### [Spring框架中的@ImportResource注解的作用是什么？它如何导入XML配置文件？](https://notes.kamacoder.com/questions/500588)
#### 知识索引

- **Spring 配置 → 注解配置 → @ImportResource**


----
#### 简洁回答

`@ImportResource` 注解用于将外部的 XML 配置文件导入到 Spring 的 Java 配置类中，使得 Java 配置可以与 XML 配置共存。
### [Spring框架中如何配置和使用自定义的BeanNameGenerator来生成Bean的名称？](https://notes.kamacoder.com/questions/500589)
#### 知识索引
- **Spring 配置 → 自定义配置 → BeanNameGenerator**

----

#### 简洁回答

`BeanNameGenerator` 是 Spring 中的一个接口，用于自定义生成 Bean 的名称。通过实现该接口并在配置中指定，可以控制 Spring 容器在注册 Bean 时为其分配的名称。
### [Spring框架中的@Lazy注解在集合类型上的行为是怎样的？](https://notes.kamacoder.com/questions/500590)
#### 知识索引

- **Spring IoC → 注解配置 → @Lazy**

----

#### 简洁回答

`@Lazy` 注解在集合类型上会影响集合中每个元素的加载方式。当集合中的每个 Bean 使用 `@Lazy` 注解时，它们会在实际需要时才被初始化，而不是在应用启动时就立即加载。

----

#### 详细回答

##### **1. `@Lazy` 注解的基本作用**
`@Lazy` 注解用于延迟加载 Bean。当一个 Bean 被标注为 `@Lazy` 时，Spring 容器会在第一次访问该 Bean 时才会实例化它，而不是在容器启动时就立即创建。这样可以优化应用启动性能，尤其是在 Bean 很多、启动时间较长的情况下。

##### **2. `@Lazy` 在集合类型上的行为**

- **单个 Bean 的懒加载**：如果一个单独的 Bean 被标记为 `@Lazy`，则该 Bean 会在实际访问时才会被加载和初始化。
- **集合中的懒加载**：当集合类型的依赖项（如 `List`、`Set` 等）中的元素标注了 `@Lazy`，Spring 会将这些元素的加载方式设置为懒加载，意味着每个元素只有在被访问时才会实例化。


##### **3. 为什么使用 `@Lazy` 在集合上**

- **减少内存使用和启动时间**：对于包含大量 Bean 的集合，使用 `@Lazy` 可以有效减少启动时对资源的占用，只有在实际需要的时候才加载相关 Bean。
- **按需加载**：某些 Bean 可能在运行时才会被用到，使用 `@Lazy` 可以避免不必要的创建和初始化，提升性能。

----

#### 延伸问答

**Q：如果集合中的 Bean 依赖项没有标注 `@Lazy`，会发生什么？**
**A：** 如果集合中的 Bean 没有标注 `@Lazy`，则这些 Bean 会在 Spring 容器启动时一并实例化。这样可能导致不必要的资源消耗，特别是在集合中包含大量 Bean 时。
**Q：`@Lazy` 在集合类型上适用于哪些场景？**
**A：** `@Lazy` 适用于那些集合元素数量较多，且这些元素的使用是按需的场景。常见于插件式应用或需要延迟加载的场景中。
### [Spring框架中如何配置和使用自定义的ApplicationContextAware来获取ApplicationContext？](https://notes.kamacoder.com/questions/500591)
#### 知识索引
- **Spring IoC → Bean生命周期 → ApplicationContextAware**

----

#### 简洁回答
`ApplicationContextAware` 是一个接口，允许 Spring Bean 获取 `ApplicationContext` 实例。通过实现该接口并重写 `setApplicationContext` 方法，Bean 可以在初始化时自动获取 `ApplicationContext`，从而访问 Spring 容器中的所有 Bean。

----

#### 详细回答

##### **1. `ApplicationContextAware` 的作用**
`ApplicationContextAware` 是 Spring 框架提供的一个接口，主要用于让 Bean 在创建时能够获取到 `ApplicationContext` 实例。通过实现该接口，Bean 可以访问 Spring 容器中的所有 Bean，从而在运行时动态地获取其他 Bean 或进行容器管理。

##### **2. 如何配置和使用 `ApplicationContextAware`**
**（1）实现 `ApplicationContextAware` 接口**
实现该接口需要重写 `setApplicationContext` 方法，该方法会在容器初始化时被调用，并传入当前的 `ApplicationContext` 实例。通过该方法，您可以将 `ApplicationContext` 存储在 Bean 中，供以后使用。

**（2）使用自定义 `ApplicationContextAware` 实现**
通过 `ApplicationContext`，可以访问整个 Spring 容器中的 Bean，实现灵活的依赖注入或动态访问。这种方式通常适用于需要动态获取 Bean 或容器上下文信息的场景。

---

#### **延申问答**
- **Q1：`ApplicationContextAware` 和 `@Autowired` 注解有什么区别？**
	- `@Autowired` 是一种自动注入的方式，通过容器直接注入其他 Bean。而 `ApplicationContextAware` 更加灵活，可以让 Bean 动态获取容器，并且支持更复杂的容器访问场景。
- **Q2：如何避免 `ApplicationContextAware` 造成的代码耦合？**
	- 为了避免代码耦合过高，可以通过其他方式访问容器，比如使用 Spring 的工厂模式、事件发布等，而不是直接依赖 `ApplicationContext`。
### [Spring框架中的@Resource注解是如何处理依赖注入的？它与@Autowired有何不同？](https://notes.kamacoder.com/questions/500592)
#### 知识索引

- **Spring IoC → 注解配置 → @Resource 和 @Autowired**


----
#### 简洁回答

`@Resource` 注解用于通过名称自动注入 Bean，默认根据 Bean 名称进行匹配；如果没有找到对应的名称，它会回退到按类型注入。`@Autowired` 注解则默认按照类型进行自动注入，如果存在多个候选 Bean，可以使用 `@Qualifier` 注解来指定具体的 Bean。
### [Spring框架中如何配置和使用自定义的EmbeddedServletContainerCustomizer来自定义Servlet容器？](https://notes.kamacoder.com/questions/500593)
#### 知识索引
- **Spring Boot → Web开发 → Servlet容器配置**

----

#### 简洁回答
`EmbeddedServletContainerCustomizer` 接口用于在 Spring Boot 中自定义嵌入式 Servlet 容器的配置。通过实现该接口并定义自定义的容器配置，可以调整如端口、上下文路径、最大连接数等容器属性。

----

#### 详细回答

##### **1. `EmbeddedServletContainerCustomizer` 的作用**

在 Spring Boot 中，`EmbeddedServletContainerCustomizer` 接口用于自定义嵌入式 Servlet 容器（如 Tomcat、Jetty 或 Undertow）的配置。通过实现该接口，您可以调整容器的各种配置项，例如：
- 设置服务器端口
- 配置上下文路径
- 调整连接池大小
- 配置 SSL 等。

这种方式适用于需要定制 Servlet 容器行为的场景，通常比修改 `application.properties` 文件更加灵活。

---

#### 延伸问答

**1. 为什么要使用 `EmbeddedServletContainerCustomizer`？**
`EmbeddedServletContainerCustomizer` 主要用于 Spring Boot 中的嵌入式 Servlet 容器的定制。当需要改变默认的嵌入式容器配置（如端口、上下文路径等）时，可以使用该接口提供的灵活定制功能，而无需修改 `application.properties` 文件。
**2. `EmbeddedServletContainerCustomizer` 与 `WebServerFactoryCustomizer` 有什么区别？**
`WebServerFactoryCustomizer` 是 `EmbeddedServletContainerCustomizer` 的继任者，它提供了更广泛的自定义能力，并且支持更多类型的 Web 服务器（如 Tomcat、Jetty、Undertow）。从 Spring Boot 2.x 开始，推荐使用 `WebServerFactoryCustomizer` 替代 `EmbeddedServletContainerCustomizer`。
### [Spring框架中的@EnableWebMvc注解的作用是什么？它如何启用Spring MVC的高级特性？](https://notes.kamacoder.com/questions/500594)
#### 简洁回答
`@EnableWebMvc` 作用：提供Spring MVC的默认配置和高级特性。
- 自动注册注册 MVC 必需的组件（如 `HandlerMapping`、`HandlerAdapter`）
- 提供静态资源处理、全局异常处理、消息转换等功能。

----

#### 详细回答
##### 如何启用高级特性？
1. **消息转换器（Message Converters）：** 自动注册 `HttpMessageConverter`，支持 JSON 和 XML 数据的序列化与反序列化。使用场景：在 RESTful API 中直接返回或接收 JSON 数据。
2. **静态资源映射：** 提供对 `/resources/**` 等静态文件路径的默认映射。使用场景：直接访问 CSS、JS、图片等资源。
3. **全局异常处理：** 提供异常处理机制，可通过 `@ControllerAdvice` 或自定义 `HandlerExceptionResolver` 捕获和处理全局异常。
4. **视图解析：** 配置 `InternalResourceViewResolver`，将逻辑视图名映射为实际的 JSP 文件路径。
5. **自定义拦截器：** 通过实现`WebMvcConfigurer` 接口的`addInterceptors()`方法添加拦截器。

##### 使用注意事项
- 如果使用 `@EnableWebMvc`，Spring 会禁用一些默认的自动配置（例如静态资源处理）。需要通过实现 `WebMvcConfigurer` 接口手动配置相关功能。
- 如果不需要完全控制 MVC 配置，可以直接使用 `spring-boot-starter-web` 提供的自动配置。

----

#### 延伸问答
- [ ] **`@EnableWebMvc` 和 `WebMvcConfigurer` 的关系是什么？**
	- `@EnableWebMvc` 通过启用 `DelegatingWebMvcConfiguration` 实现了 Spring MVC 的配置。
	- `WebMvcConfigurer` 提供了扩展 MVC 配置的钩子方法（如 `addInterceptors` 和 `configureMessageConverters`）。
- [ ] **在 Spring Boot 中是否需要显式使用 `@EnableWebMvc`？**
	通常不需要，Spring Boot 自动配置了 Web MVC 功能。如果需要完全自定义配置，可以结合 `@EnableWebMvc` 和 `WebMvcConfigurer` 实现。
- [ ] **如何自定义消息转换器？**
	在实现 `WebMvcConfigurer` 的 `configureMessageConverters` 方法中添加或修改消息转换器：
	```java
	@Override
	public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
	    converters.add(new MappingJackson2HttpMessageConverter());
	}
	```
### [Spring框架中如何配置和使用自定义的HandlerMethodArgumentResolver来处理自定义的请求参数？](https://notes.kamacoder.com/questions/500595)
#### 知识索引

- **Spring MVC → 请求处理 → 自定义参数解析器**


----

#### 简洁回答

`HandlerMethodArgumentResolver` 接口允许开发者自定义请求参数的解析逻辑。通过实现该接口并注册到 Spring MVC 的配置中，可以自定义如何将 HTTP 请求中的参数绑定到方法的参数上。常用于解析复杂类型或自定义注解的参数。


----

#### 详细回答

##### **1. `HandlerMethodArgumentResolver` 的作用**

`HandlerMethodArgumentResolver` 是 Spring MVC 提供的接口，用于自定义请求方法参数的解析逻辑。当控制器方法有特殊的参数类型时（例如自定义类型或通过特定注解标记的参数），可以通过实现此接口自定义参数的解析过程。Spring 会在调用控制器方法前，根据 `HandlerMethodArgumentResolver` 中的配置解析请求参数并将其传递给方法。

##### **2. 如何实现自定义的 `HandlerMethodArgumentResolver`**
**步骤：**
1. **实现 `HandlerMethodArgumentResolver` 接口**
	该接口有两个方法需要实现：
	- `supportsParameter`：检查是否支持对某个特定参数进行解析。
	- `resolveArgument`：处理具体的参数解析逻辑。
2. **注册到 Spring MVC 中**
	自定义的解析器需要在 Spring 配置中进行注册，使得 Spring MVC 在处理请求时能够使用它。
	
##### **3. `HandlerMethodArgumentResolver` 的常见用途**
- **处理自定义参数类型**：如将请求中的 JSON 字符串转换为自定义的 Java 对象。
- **处理特殊的请求头或请求体数据**：例如，解析某些复杂类型的参数。
- **处理自定义注解的参数**：如解析标注了特定注解的参数（例如 `@CustomParam`）并执行自定义逻辑。


----

#### 延伸问答
1. **`HandlerMethodArgumentResolver` 与 `@RequestParam`、`@PathVariable` 有何关系？**
	`HandlerMethodArgumentResolver` 是用于实现更复杂的请求参数绑定，超出了 Spring 默认的 `@RequestParam` 和 `@PathVariable` 的功能。Spring MVC 的默认机制已经处理了这些注解，但如果你需要处理更复杂的绑定（比如自定义的注解或对象类型），就需要使用自定义的 `HandlerMethodArgumentResolver`。

2. **如何优化自定义 `HandlerMethodArgumentResolver` 的性能？**
	如果解析器只处理少量特定的参数，性能通常不是问题。但如果解析的对象较为复杂，可以考虑：
	- 避免在每次请求中都进行大量的反射或计算。
	- 使用缓存来存储解析结果。
	- 对复杂参数的解析逻辑进行优化，减少不必要的计算或处理。
### [Spring框架中的@EnableScheduling注解的作用是什么？它如何启用定时任务的支持？](https://notes.kamacoder.com/questions/500596)
#### 知识索引
- **Spring Core → 注解配置 → @EnableScheduling**

----

#### 简洁回答
`@EnableScheduling` 注解用于启用 Spring 的定时任务支持。它会自动配置任务调度器，并使 Spring 管理的方法支持定时任务执行。

----

#### 详细回答

##### **1. `@EnableScheduling` 的作用**
`@EnableScheduling` 是一个 Spring 注解，用于启用基于注解的定时任务功能。它会自动在 Spring 上下文中配置定时任务相关的组件，使得使用 `@Scheduled` 注解的方法能够被定期执行。这个注解通常用于 Spring 配置类中，标志着该类启用了定时任务功能。

##### **2. 如何使用 `@EnableScheduling` 启用定时任务**
**步骤：**
1. **在 Spring 配置类中添加 `@EnableScheduling` 注解**
	通过在 Spring 配置类（通常是一个 `@Configuration` 注解的类）中添加 `@EnableScheduling`，启用 Spring 的定时任务调度功能。
2. **使用 `@Scheduled` 注解标注定时任务方法**
	在需要定时执行的方法上添加 `@Scheduled` 注解，可以通过该注解指定任务的执行频率、延时等参数。
	
**3. 定时任务的执行方式**
- `@Scheduled(fixedRate = 5000)`：每隔固定时间执行一次任务，单位为毫秒。
- `@Scheduled(cron = "0 0 0 * * ?")`：使用 Cron 表达式指定任务的执行计划，例如这里是每天午夜12点执行。

----

#### 延伸问答
1. **如何控制定时任务的线程池？**
	Spring 默认使用一个简单的单线程池执行定时任务。如果需要更复杂的调度或多线程执行，可以通过 `TaskScheduler` 接口自定义线程池。

2. **如何动态停止某个定时任务？**
	可以通过 `ScheduledFuture` 来管理和停止任务。例如，通过 `@Scheduled` 注解运行的任务可以动态调整或停止。
### [Spring框架中如何配置和使用自定义的HandlerMethodReturnValueHandler来处理自定义的返回值？](https://notes.kamacoder.com/questions/500597)
#### 知识索引
- **Spring MVC → 返回值处理 → 自定义返回值处理器**

----

#### 简洁回答
`HandlerMethodReturnValueHandler` 接口允许开发者自定义如何处理控制器方法的返回值。通过实现该接口，可以自定义返回值的处理逻辑，如将返回对象转换为特定格式或进行额外的处理。自定义的 `HandlerMethodReturnValueHandler` 需要在 Spring 配置中注册。

----

#### 详细回答

##### **1. `HandlerMethodReturnValueHandler` 的作用**
`HandlerMethodReturnValueHandler` 是 Spring MVC 提供的接口，用于在控制器方法执行后处理其返回值。默认情况下，Spring MVC 会根据方法的返回值类型自动选择合适的返回值处理器（如 `@ResponseBody` 或视图解析）。通过自定义 `HandlerMethodReturnValueHandler`，可以实现特定类型的返回值处理，如将对象转换为 JSON、XML 或其他格式，或者实现自定义的返回值格式化逻辑。

##### **2. 如何实现和配置 `HandlerMethodReturnValueHandler`**
**步骤：**
1. **实现 `HandlerMethodReturnValueHandler` 接口**
	`HandlerMethodReturnValueHandler` 接口有两个关键方法：
	- `supportsReturnType`：检查是否支持处理特定类型的返回值。
	- `handleReturnValue`：处理返回值的具体逻辑。
2. **注册自定义的返回值处理器**
	在 Spring MVC 配置中通过 `WebMvcConfigurer` 接口注册自定义的 `HandlerMethodReturnValueHandler`。

**关键点：**
- **`supportsReturnType`**：决定该返回值处理器是否能够处理指定类型的返回值。
- **`handleReturnValue`**：实际处理返回值的逻辑，例如将返回值转换成 JSON 或 XML 格式，或者执行其他操作。

----

#### 延伸问答
**1. 如何使用自定义返回值处理器处理不同的返回类型？**
通过在 `supportsReturnType` 方法中定义逻辑，可以让处理器支持不同的返回类型，例如 `String`、`CustomResponse` 或特定的对象类型。这使得你可以为不同的返回值类型定义不同的处理逻辑。

**2. `HandlerMethodReturnValueHandler` 与 `HandlerMethodArgumentResolver` 有什么区别？**
	- `HandlerMethodArgumentResolver` 用于处理**请求**中的参数绑定，将请求中的数据转化为控制器方法的参数。
	- `HandlerMethodReturnValueHandler` 用于处理**控制器方法**的返回值，将方法返回的对象转化为响应的内容。
	这两个接口都用于数据的转换和处理，但其作用的方向不同，一个是从请求到方法参数，另一个是从方法返回值到响应输出。

**3. 是否可以通过注解自动注册自定义的 `HandlerMethodReturnValueHandler`？**
目前，Spring MVC 没有提供像 `@Autowired` 这样自动注册返回值处理器的机制，需要通过 `WebMvcConfigurer` 手动注册。
### [Spring框架中的@Value注解如何支持SpEL（Spring Expression Language）表达式？](https://notes.kamacoder.com/questions/500598)
#### 知识索引
- **Spring Core → 注解配置 → @Value**

----

#### 简洁回答
`@Value` 注解支持 SpEL 表达式，用于动态注入值。通过在 `@Value` 中使用 `${}`，可以解析表达式并从上下文、系统环境或配置文件中获取值，支持在注入时进行计算或条件判断。
### [Spring框架中如何配置和使用自定义的WebMvcConfigurer来定制Spring MVC的行为？](https://notes.kamacoder.com/questions/500599)
#### 简洁回答
将类标记为 `@Configuration` 并实现 `WebMvcConfigurer` 接口中的方法，可以自定义 Spring MVC 的行为。
例如，可以添加拦截器、格式化器、消息转换器或自定义静态资源映射。

----

#### 详细回答
##### 1、创建自定义 `WebMvcConfigurer`
```java
@Configuration
public class MyWebMvcConfigurer implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoggingInterceptor()).addPathPatterns("/**");
    }

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/home").setViewName("home");
    }
}
```
##### 2、常用的 `WebMvcConfigurer` 方法**
###### （1）`addInterceptors` 添加自定义拦截器。
```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
	registry.addInterceptor(new LoggingInterceptor()).addPathPatterns("/**");
}
```

###### （2）`addViewControllers` 配置简单的视图映射，无需控制器逻辑。
```java
@Override
public void addViewControllers(ViewControllerRegistry registry) {
	registry.addViewController("/login").setViewName("loginPage");
}
```
###### （3）`configureMessageConverters` 自定义消息转换器，用于 JSON/XML 的序列化与反序列化。
```java
@Override
public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
	converters.add(new MappingJackson2HttpMessageConverter());
}
```
###### （4）`addResourceHandlers` 配置静态资源的访问路径。
```java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
	registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
}
```
###### （5）`configureViewResolvers` 自定义视图解析器。
```java
@Override
public void configureViewResolvers(ViewResolverRegistry registry) {
	registry.jsp("/WEB-INF/views/", ".jsp");
}
```
###### （6）`configurePathMatch` 定制路径匹配规则，例如忽略 URL 后缀。
```java
@Override
public void configurePathMatch(PathMatchConfigurer configurer) {
	configurer.setUseSuffixPatternMatch(false);
}
```

----

#### 延伸问答
- [x] **`WebMvcConfigurer` 与 `@EnableWebMvc` 的关系是什么？**
	- `@EnableWebMvc` 会启用 Spring MVC 的核心配置
	-  `WebMvcConfigurer` 提供了扩展点，允许开发者在默认配置上添加自定义行为。
- [ ] **如何管理多个 `WebMvcConfigurer`？**
	- Spring 容器会自动识别所有实现了 `WebMvcConfigurer` 的 Bean，并按优先级顺序组合执行，优先级可以通过 `@Order` 注解控制。
- [ ] **与 `WebMvcConfigurationSupport` 的区别？**
	- `WebMvcConfigurer` 是轻量级的扩展机制，基于默认配置。
	- `WebMvcConfigurationSupport` 是完全接管 MVC 配置的高级机制，适合需要完全自定义 MVC 的场景。
## Spring Boot
### [什么是Spring Boot？](https://notes.kamacoder.com/questions/500600)
#### 定义
Spring Boot 旨在简化 Spring 应用的开发和部署。
#### 核心特点：
1. **自动配置**：基于类路径依赖智能化地配置 Spring 应用，避免手动 XML 配置或 Java 配置。
2. **内嵌服务器**：支持内嵌 Tomcat、Jetty 等，无需外部应用服务器。
3. **简化依赖管理**：通过 Spring Boot Starter 提供一站式依赖管理。
4. **生产级特性**：内置监控、健康检查、日志管理等功能。
### [Spring Boot的主要特点是什么？](https://notes.kamacoder.com/questions/500601)
1. 自动配置
	- 核心注解：`@EnableAutoConfiguration`。
	- 例如：添加 `spring-boot-starter-web`，Spring Boot 会自动配置内嵌的 Tomcat 和 Spring MVC。
2. 内嵌服务器
	- 支持内嵌 Tomcat、Jetty、Undertow，无需单独部署应用服务器。
	- 通过 `java -jar` 即可运行，便于快速开发和部署。
3. 开箱即用的 Starter 组件
	- 提供了一系列 Starter，简化依赖管理。
	- 例如：`spring-boot-starter-data-jpa` 集成了 Hibernate 和 Spring Data JPA。
4. 生产级特性
	- 提供内置的监控、健康检查、性能指标。
	- 集成 `Spring Boot Actuator`，方便开发和运维团队实时监控应用。
### [Spring Boot Starter有什么用？](https://notes.kamacoder.com/questions/500602)
#### 定义
- Spring Boot Starter 是一组**预定义依赖包**，旨在**简化依赖管理**。
- 提供一站式的依赖管理，通过一个单独的 Starter 依赖即可集成某种功能，而无需手动管理繁杂的依赖关系和版本。
#### 特点
1. 约定优于配置，无需手动配置
	- 每个 Starter 都包含一组经过验证的依赖及其版本，无需手动配置。
	- 例如，`spring-boot-starter-web` 自动引入 Spring MVC、Tomcat、Jackson 等依赖。
2. 提供默认配置**避免兼容性问题**
3. 支持扩展和自定义
#### 举例
- `spring-boot-starter-web`：构建 RESTful Web 应用。
- `spring-boot-starter-data-jpa`：集成 JPA 和 Hibernate。
- `spring-boot-starter-test`：集成 JUnit、Mockito 和 Spring Test。
- `spring-boot-starter-security`：集成 Spring Security。
### [Spring Boot常用注解？](https://notes.kamacoder.com/questions/500603)
#### 核心配置相关
1. **`@SpringBootApplication`**
	- 功能：标记为 Spring Boot 应用的入口，集成了 `@Configuration`、`@EnableAutoConfiguration` 和 `@ComponentScan`。
#### RESTful API 开发相关
1. **`@RestController`**
	- 功能：标记类为 REST 控制器，等同于 `@Controller` + `@ResponseBody`。
2. **`@GetMapping` / `@PostMapping` / `@PutMapping` / `@DeleteMapping`**
	- 功能：用于定义 HTTP 请求的映射，对应 GET、POST、PUT、DELETE 方法。
3. **`@RequestParam` / `@PathVariable`**
	- 功能：获取 URL 参数或路径变量。

#### 数据访问相关
1. **`@Entity`**
	- 功能：标记类为 JPA 实体，与数据库表映射。
2. **`@Repository`**
	- 功能：标记类为持久层组件，用于异常转换。
3. **`@Transactional`**
	- 功能：声明事务，确保方法在事务范围内执行。

### [如何在Spring Boot中禁用Actuator端点安全性？](https://notes.kamacoder.com/questions/500604)
【待补充】
1. 修改配置文件
2. 自定义安全配置
3. 禁用Spring Security（开发环境推荐，生产环境慎用）
#### 修改配置文件
```properties
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always
spring.security.enabled=false
```

#### 自定义安全配置
```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests()
            .requestMatchers("/actuator/**").permitAll() // 允许所有用户访问 Actuator 端点
            .anyRequest().authenticated()
            .and().csrf().disable();
        return http.build();
    }
}
```

#### 禁用Spring Security
```properties
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration
```

### [如何在自定义端口上运行Spring Boot应用程序？](https://notes.kamacoder.com/questions/500605)
1.  在 `application.properties` 文件中，添加或修改 `server.port` 配置项
	```
	server.port=8081
	```
2. 如果使用 `application.yml` 文件
	```
	  port: 8081
	```
3. 可以通过命令行参数来指定端口
	```
	java -jar myapp.jar --server.port=8081
	```
### [Spring Boot中的YAML配置与properties配置有什么区别？](https://notes.kamacoder.com/questions/500606)
#### 语法格式
- **`properties` 配置：** 基于键值对的格式，使用 `=` 或 `:` 分隔键和值。
- **`YAML` 配置：** 基于缩进的层级结构，使用冒号 `:` 分隔键和值，且支持复杂的嵌套结构。

#### 可读性
- **`properties` 配置：** 对于简单的配置项来说，`properties` 格式相对直观，但对于复杂的嵌套配置会显得冗长且难以管理。
- **`YAML` 配置：** 更具层次感，适合处理复杂的配置，配置文件更简洁且易于理解和维护。支持注释和文档化，易于组织和描述配置结构。

####  支持的数据结构
- **`properties` 配置：** 主要用于简单的键值对，支持基本类型的数据，如字符串、数字、布尔值等。
- **`YAML` 配置：** 支持复杂的层级结构，允许列表、字典、嵌套对象等数据类型。

#### 总结
- **简洁性：** YAML 更适合复杂的、多层次的配置，`properties` 更适合简单的配置。
- **可读性：** YAML 由于缩进和层级结构，通常更易于阅读和维护。
- **性能：** `properties` 稍快，但差异在大多数应用场景中并不显著。
### [如何在Spring Boot中实现应用程序的安全性？](https://notes.kamacoder.com/questions/500607)
【待学习】
在** Spring Boot** 中实现**应用程序安全性**主要依赖 **Spring Security**，具体可以通过以下步骤：
1. **引入依赖：** 添加 `spring-boot-starter-security` 启用默认安全配置（如 HTTP Basic 身份验证）。
	[追问：如何禁用默认安全配置](https://notes.kamacoder.com/question/100604)
3. **自定义安全规则：** 使用 `SecurityFilterChain` 配置 URL 访问权限和认证方式（如角色控制、表单登录）。
4. **密码加密和安全性增强：** 使用 `BCryptPasswordEncoder` 加密用户密码，并结合 HTTPS、JWT 等保护敏感数据。
### [Spring Boot中的自动配置是如何工作的？](https://notes.kamacoder.com/questions/500608)
#### 关键词提示
-  `@EnableAutoConfiguration` `META-INF/spring.factories` 
-   扫描依赖、条件匹配、Bean注册
---
#### 面试版回答
##### 1. 核心机制
通过 `@EnableAutoConfiguration` 注解自动导入 `META-INF/spring.factories` 文件中指定的自动配置类。
##### 2. 工作流程
	1. **扫描依赖：** 根据类路径中的依赖（如 Starter）决定要加载的自动配置类。
	2. **条件匹配：** 通过 `@Conditional` 注解验证是否满足加载条件。
	3. **Bean 注册：** 满足条件的自动配置类会注册相关的 Spring Bean。
##### 3. 自定义与禁用
	- **禁用：** `spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration`
	- **自定义：** `org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.example.MyAutoConfiguration`

### [如何在Spring Boot中集成ActiveMQ？](https://notes.kamacoder.com/questions/500609)
【待学习】

---

#### 面试者回答
1. 引入依赖
2. 配置ActiveMQ的连接信息
3. 创建消息发送和接收逻辑

---

#### 详细回答
1. **引入依赖：**
	```xml
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-activemq</artifactId>
	</dependency>
	```

2. **配置 ActiveMQ的连接信息**
	```properties
	spring.activemq.broker-url=tcp://localhost:61616
	spring.activemq.user=admin
	spring.activemq.password=admin
	```

3. **创建消息发送和接收逻辑：**
	- **发送消息：**
		```java
		@Service
		public class Producer {
		    @Autowired
		    private JmsTemplate jmsTemplate;
		    public void sendMessage(String destination, String message) {
		        jmsTemplate.convertAndSend(destination, message);
		    }
		}
		```
	- **接收消息：**
		```java
		@Component
		public class Consumer {
		    @JmsListener(destination = "test-queue")
		    public void receiveMessage(String message) {
		        System.out.println("Received: " + message);
		    }
		}
		```
### [什么是Swagger？如何在Spring Boot中集成Swagger？](https://notes.kamacoder.com/questions/500610)
#### 知识索引
Spring Boot → API 文档工具集成 → Swagger 集成

---

#### 简洁回答
Swagger 是一个用于生成、描述、调用和可视化 RESTful 风格的 Web 服务的工具。
在 Spring Boot 中集成 Swagger，需要添加相关依赖，配置 Swagger 相关信息，然后使用注解来描述 API。

---

#### 详细回答
##### **Swagger 简介**
Swagger 可以帮助开发人员**设计、构建、记录和使用 RESTful Web 服务**。它提供了一种**交互式的文档**方式
	- 让后端开发人员可以**清晰地定义 API** 的接口信息，包括接口路径、请求方法、请求参数、返回值等
	- 方便前端开发人员或其他使用者**理解和测试 API**。
##### **在 Spring Boot 中集成 Swagger 步骤**：
- - **添加依赖**：在项目的 pom.xml 文件中添加 Swagger 相关的依赖，通常是`springfox - swagger2`和`springfox - swagger - ui`。例如：
```xml
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox - swagger2</artifactId>
        <version>2.9.2</version>
    </dependency>
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox - swagger - ui</artifactId>
        <version>2.9.2</version>
    </dependency>
```

- **配置 Swagger**：创建一个配置类，用于配置 Swagger 的相关信息。例如：
```java
    @Configuration
    @EnableSwagger2
    public class SwaggerConfig {
        @Bean
        public Docket api() {
            return new Docket(DocumentationType.SWAGGER_2)
                   .select()
                   .apis(RequestHandlerSelectors.basePackage("com.example.demo.controller"))
                   .paths(PathSelectors.any())
                   .build();
        }
    }
```
- 这个配置类中，`@Configuration`注解表示这是一个配置类，`@EnableSwagger2`注解用于启用 Swagger 2。`Docket`对象用于定制 Swagger 的文档信息，在这里通过`apis`方法指定了要扫描的控制器包路径，`paths`方法表示扫描所有的路径。

- **使用注解描述 API**：在控制器类和方法中使用 Swagger 的注解来详细描述 API。例如：
```java
    @RestController
    @RequestMapping("/api")
    public class MyController {
        @ApiOperation("获取用户信息")
        @GetMapping("/user/{id}")
        public User getUser(@ApiParam("用户ID") @PathVariable("id") Long id) {
            // 实现获取用户信息的逻辑
            User user = new User();
            user.setId(id);
            user.setName("John");
            return user;
        }
    }
```
- 其中，`@ApiOperation`注解用于描述方法的功能，`@ApiParam`注解用于描述方法的参数。

---

#### 延申问答
- **问题 1：如何在 Swagger 文档中添加认证信息？**
	- **回答**：可以在 Swagger 配置类中添加安全相关的配置。例如，对于基本认证（Basic Authentication），可以这样配置：
	```java
		@Configuration
		@EnableSwagger2
		public class SwaggerConfig {
			@Bean
			public Docket api() {
				return new Docket(DocumentationType.SWAGGER_2)
					   .select()
					   .apis(RequestHandlerSelectors.basePackage("com.example.demo.controller"))
					   .paths(PathSelectors.any())
					   .build()
					   .securitySchemes(Arrays.asList(basicAuthScheme()))
					   .securityContexts(Arrays.asList(securityContext()));
			}
			private SecurityScheme basicAuthScheme() {
				return new BasicAuth("basicAuth");
			}
			private SecurityContext securityContext() {
				return SecurityContext.builder()
					   .securityReferences(Arrays.asList(basicAuthReference()))
					   .forPaths(PathSelectors.any())
					   .build();
			}
			private SecurityReference basicAuthReference() {
				return new SecurityReference("basicAuth", new AuthorizationScope[0]);
			}
		}
	```
	- 这样在 Swagger UI 中就会出现认证输入框，用户可以输入用户名和密码进行认证。
- **问题 2：如何自定义 Swagger 文档的外观和布局？**
	- **回答**：可以通过修改 Swagger - ui 的 HTML 和 CSS 文件来定制外观和布局。不过这相对复杂一些。更简单的方法是通过一些已有的 Swagger - ui 主题插件或者通过修改 Swagger - ui 的 JavaScript 配置来实现部分定制。例如，可以通过修改`index.html`文件中 Swagger - ui 的初始化参数来改变一些显示效果，如隐藏某些组件或者修改标题等。另外，也可以通过在后端的 Swagger 配置类中进一步定制`Docket`对象的属性来控制文档的内容展示方式，比如可以控制哪些接口显示、如何分组等。
### [Spring Boot中的Spring Profiles是什么？如何使用？](https://notes.kamacoder.com/questions/500611)
#### 简要回答
**Spring Profiles** 用于在不同的环境中（如开发、测试、生产等）配置和加载不同的 Bean 或者配置属性。它**允许根据激活的配置文件**实现**应用程序在不同环境下的差异化配置**。
例如，在开发环境中，你可能希望使用内存数据库（如 H2）来方便快速地进行开发和测试；而在生产环境中，你会使用真实的数据库（如 MySQL 或 Oracle）。Spring Profiles 就可以帮助你轻松地切换这些配置。

### [Spring Boot Batch提供了哪些功能？](https://notes.kamacoder.com/questions/500612)
#### 简要回答
Spring Boot Batch 用于处理**大量数据批处理操作**的框架，它提供了以下主要功能：

1. **任务定义与执行**
	- **Job（作业）定义**：可以通过编程或配置的方式定义一个批处理作业。一个**作业（Job）** 包含了多个**步骤（Step）** ，这些步骤按照特定的顺序执行，用于完成复杂的数据处理任务。例如，一个数据迁移作业可能包括从源数据库读取数据、对数据进行转换、然后将转换后的数据写入目标数据库等多个步骤。
	- **Job Execution（作业执行）**：提供了对作业执行的管理功能，包括作业的**启动、暂停、恢复和停止**。它能够跟踪作业的执行状态，例如正在运行、已完成、失败等状态，并且可以在作业执行出现错误时进行适当的处理。

---

2. **数据读取（Reading）**
	- **多种数据读取源支持**：可以从各种数据源读取数据，如关系型数据库（通过 JDBC）、文件系统（如 CSV、XML 文件）等。例如，使用`JdbcCursorItemReader`可以从数据库表中逐行读取数据，它允许在数据库游标上进行迭代读取，适用于处理大型数据集。对于文件读取，像`FlatFileItemReader`能够读取平面文件（如 CSV），并将文件内容解析为对象。
	- **自定义读取逻辑**：提供了扩展点，允许开发者自定义数据读取逻辑。这对于处理特殊格式的数据或者非标准数据源非常有用。比如，当需要从一个 Web 服务接口获取数据并作为批处理的输入时，可以通过实现自定义的`ItemReader`接口来完成。
3. **数据处理（Processing）**
	- **数据转换和业务逻辑处理**：在数据读取后，可以对数据进行各种处理操作。例如，对从数据库读取的用户信息进行数据清洗，包括**去除空值、格式化日期字段**等操作。还可以进行复杂的业务逻辑处理，如根据用户的消费记录计算用户的信用评分等。
	- **可组合的处理步骤**：多个处理步骤可以组合在一起，形成一个数据处理管道。每个步骤可以专注于一个特定的处理任务，这样可以使代码更加模块化和易于维护。例如，一个步骤用于数据验证，另一个步骤用于数据转换，它们可以按照顺序依次执行。
4. **数据写入（Writing）**
	- **多种数据写入目标支持**：能够将处理后的数据写入到不同的目标位置，如数据库、文件系统等。例如，使用`JdbcBatchItemWriter`可以将数据批量写入到数据库表中，提高写入效率。对于写入文件，可以使用`FlatFileItemWriter`将对象数据转换为文本格式并写入文件。
	- **写入事务管理**：在数据写入过程中，提供了事务管理功能，确保数据的一致性。如果在写入过程中出现错误，能够根据配置进行回滚操作，避免数据损坏。例如，在向数据库写入一批订单数据时，如果部分数据写入失败，事务可以回滚，保证数据库中的数据完整性。

---

5. **监控和元数据管理**
	- **作业和步骤的监控**：可以**监控**批处理作业和各个步骤的执行情况，包括**已处理的记录数、处理速率、开始时间和结束时间**等信息。这些监控数据有助于了解批处理作业的性能和进度，例如可以通过监控发现数据处理过程中的瓶颈步骤。
	- **元数据存储和查询**：存储**批处理作业的元数据**，如作业定义、执行历史、执行状态等信息。这些元数据可以被查询，用于**审计、故障排查和作业调度**等目的。例如，通过查询作业的历史执行记录，可以分析之前作业失败的原因。
### [如何在Spring Boot中使用FreeMarker模板引擎？](https://notes.kamacoder.com/questions/500613)
#### 知识索引
Spring Boot → 模板引擎集成 → FreeMarker 集成

---

#### 简洁回答
- 在 pom.xml 添加 FreeMarker 依赖。
- 在 application.properties 配置属性。
- 在控制器返回视图名称来使用。

#### 详细回答
- **添加依赖**：在项目的 pom.xml 文件里加入 FreeMarker 的 starter 依赖：
```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring - boot - starter - freemarker</artifactId>
    </dependency>
```

- **配置属性（可选）**：在 application.properties（或 application.yml）中配置 FreeMarker 的属性。
	- `spring.freemarker.suffix=.ftl`用于指定 FreeMarker 模板文件的后缀，默认是.ftl。
	- `spring.freemarker.charset=UTF - 8`用来设置模板文件的编码。

- **创建模板文件**：在 resources/templates 目录下创建 FreeMarker 模板文件（.ftl 文件）

- **在控制器中使用**：首先创建一个 Spring MVC 控制器类，如下：
```java
    @Controller
    public class HelloController {
        @RequestMapping("/hello")
        public String hello(Model model) {
            model.addAttribute("name", "World");
            return "hello";
        }
    }
```

- 对于这个例子，`/hello`这个请求会进入`hello`方法。`model.addAttribute`方法会把一个名为`name`，值为`World`的属性添加到模型里。最后返回的`hello`就是模板文件的名字（去掉后缀.ftl），Spring Boot 会自动使用 FreeMarker 引擎来渲染这个模板，然后返回给客户端。

#### 延申问答
- **问题 1：如果想在 FreeMarker 模板中使用自定义的函数或者工具类，该怎么做？**
	- **回答**：可以通过在配置类中定义一个`FreeMarkerConfigurer`类型的 Bean，然后使用`getConfiguration().setSharedVariable`方法来添加自定义的函数或者工具类到 FreeMarker 的共享变量中。
- **问题 2：FreeMarker 模板中的数据格式化是如何实现的？**
	- **回答**：FreeMarker 提供了多种内置的格式化指令。例如，`${date?string("yyyy - MM - dd")}`可以将一个日期类型的数据格式化为指定的字符串格式。同时，也可以自定义格式化工具类，通过上述共享变量的方式添加到模板中使用。
### [Spring Boot中如何处理异常？](https://notes.kamacoder.com/questions/500614)
1. **默认异常处理机制**
	- Spring Boot 提供了默认的异常处理机制。当一个未被捕获的异常抛出时，Spring Boot 会返回一个带有错误信息的 HTTP 响应（如果是 Web 应用）。例如，对于一个简单的 Spring Boot RESTful API，当出现运行时异常（如`NullPointerException`）时，默认会返回一个包含 500（Internal Server Error）状态码的响应，并且响应体中可能会有一些简单的错误提示信息，如异常的类型和简单描述。
2. **使用`@ControllerAdvice`和`@ExceptionHandler`注解**
	- **全局异常处理**：可以使用`@ControllerAdvice`注解创建一个全局异常处理类。这个类可以捕获整个应用（多个`Controller`）中抛出的异常。例如：
	```
	import org.springframework.http.HttpStatus;
	import org.springframework.http.ResponseEntity;
	import org.springframework.web.bind.annotation.ControllerAdvice;
	import org.springframework.web.bind.annotation.ExceptionHandler;
	@ControllerAdvice
	public class GlobalExceptionHandler {
	    @ExceptionHandler(NullPointerException.class)
	    public ResponseEntity<String> handleNullPointerException(NullPointerException ex) {
	        return new ResponseEntity<>("发生了空指针异常：" + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
	    }
	}
	```
	- 在这个例子中，当应用中的任何`Controller`方法抛出`NullPointerException`时，`handleNullPointerException`方法会被调用。它会返回一个带有自定义错误消息和`500`状态码的`ResponseEntity`。
	- **多种异常类型处理**：可以在同一个`GlobalExceptionHandler`类中定义多个`@ExceptionHandler`方法来处理不同类型的异常。例如，可以添加一个方法来处理`NumberFormatException`：
	```
	@ExceptionHandler(NumberFormatException.class)
	public ResponseEntity<String> handleNumberFormatException(NumberFormatException ex) {
	    return new ResponseEntity<>("数字格式错误：" + ex.getMessage(), HttpStatus.BAD_REQUEST);
	}
	```
3. **自定义异常和处理**
	- **定义自定义异常类**：可以创建自己的异常类来表示特定的业务错误。例如，定义一个`BusinessException`类：
	```
	public class BusinessException extends RuntimeException {
	    public BusinessException(String message) {
	        super(message);
	    }
	}
	```
	- **处理自定义异常**：然后在`@ControllerAdvice`类中添加一个方法来处理这个自定义异常：
	```
	@ExceptionHandler(BusinessException.class)
	public ResponseEntity<String> handleBusinessException(BusinessException ex) {
	    return new ResponseEntity<>("业务异常：" + ex.getMessage(), HttpStatus.CONFLICT);
	}
	```
4. **在`RestController`中处理异常**
	- **局部异常处理**：在单个`RestController`中，可以使用`@ExceptionHandler`注解来处理该`Controller`内部的异常。这样的处理方式只对这个`Controller`有效，而不是全局的。例如：

	```
	import org.springframework.http.HttpStatus;
	import org.springframework.http.ResponseEntity;
	import org.springframework.web.bind.annotation.ExceptionHandler;
	import org.springframework.web.bind.annotation.RestController;
	@RestController
	public class MyController {
	    @ExceptionHandler(IllegalArgumentException.class)
	    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException ex) {
	        return new ResponseEntity<>("参数错误：" + ex.getMessage(), HttpStatus.BAD_REQUEST);
	    }
	}
	```
5. **使用`ResponseStatusException`**
	- Spring Boot 还提供了`ResponseStatusException`来方便地抛出带有指定状态码的异常。例如：

	```
	import org.springframework.http.HttpStatus;
	import org.springframework.web.bind.annotation.GetMapping;
	import org.springframework.web.bind.annotation.RestController;
	import org.springframework.web.server.ResponseStatusException;
	@RestController
	public class AnotherController {
	    @GetMapping("/test")
	    public String test() {
	        throw new ResponseStatusException(HttpStatus.NOT_FOUND, "资源未找到");
	    }
	}
	```
	- 当访问`/test`路径时，会抛出一个带有`404`（Not Found）状态码的异常，并且返回自定义的错误消息。
### [如何在Spring Boot中实现分页和排序？](https://notes.kamacoder.com/questions/500615)
1. **使用 Spring Data JPA 实现分页和排序**
	- **依赖引入**：首先确保项目中引入了`spring - data - jpa`依赖。在`pom.xml`（如果是 Maven 项目）中添加以下内容：
	```
	<dependency>
	    <groupId>org.springframework.data</groupId>
	    <artifactId>spring - data - jpa</artifactId>
	    <version>版本号</version>
	</dependency>
	```
	- **在 Repository 接口中定义方法**：如果有一个`User`实体类，对应的`UserRepository`接口（继承`JpaRepository`）可以定义分页和排序相关的方法。例如：

	```
	import org.springframework.data.domain.Page;
	import org.springframework.data.domain.Pageable;
	import org.springframework.data.jpa.repository.JpaRepository;
	import com.example.entity.User;
	public interface UserRepository extends JpaRepository<User, Long> {
	    Page<User> findAll(Pageable pageable);
	}
	```
	- **在 Service 层使用分页和排序**：在`UserService`类中，可以这样调用分页和排序方法。例如：

	```
	import org.springframework.data.domain.Page;
	import org.springframework.data.domain.PageRequest;
	import org.springframework.data.domain.Sort;
	import org.springframework.stereotype.Service;
	import javax.annotation.PostConstruct;
	import java.util.ArrayList;
	import java.util.List;
	@Service
	public class UserService {
	    private UserRepository userRepository;
	    public UserService(UserRepository userRepository) {
	        this.userRepository = userRepository;
	    }
	    public Page<User> getUsers(int page, int size, String sortBy) {
	        Sort sort = Sort.by(sortBy).ascending();
	        PageRequest pageRequest = PageRequest.of(page, size, sort);
	        return userRepository.findAll(pageRequest);
	    }
	}
	```
	- 在这里，`getUsers`方法接受页码`page`、每页大小`size`和排序字段`sortBy`作为参数。通过`Sort.by`方法创建排序规则，`PageRequest.of`方法创建包含页码、每页大小和排序规则的`PageRequest`对象，最后调用`userRepository.findAll`方法获取分页和排序后的用户数据。
	- **在 Controller 层暴露接口**：在`UserController`中可以将分页和排序后的用户数据返回给客户端。例如：

	```
	import org.springframework.data.domain.Page;
	import org.springframework.http.HttpStatus;
	import org.springframework.http.ResponseEntity;
	import org.springframework.web.bind.annotation.GetMapping;
	import org.springframework.web.bind.annotation.RequestParam;
	import org.springframework.web.bind.annotation.RestController;
	@RestController
	public class UserController {
	    private UserService userService;
	    public UserController(UserService userService) {
	        this.userService = userService;
	    }
	    @GetMapping("/users")
	    public ResponseEntity<Page<User>> getUsers(
	            @RequestParam(defaultValue = "0") int page,
	            @RequestParam(defaultValue = "10") int size,
	            @RequestParam(defaultValue = "id") String sortBy) {
	        Page<User> users = userService.getUsers(page, size, sortBy);
	        return new ResponseEntity<>(users, HttpStatus.OK);
	    }
	}
	```
	- 这个`/users`接口接受`page`、`size`和`sortBy`作为请求参数，默认页码为`0`，每页大小为`10`，排序字段为`id`。它调用`userService.getUsers`方法获取分页和排序后的用户数据，并将结果作为`ResponseEntity`返回给客户端。

---

2. **使用自定义 SQL 实现分页和排序（适用于复杂场景）**
	- **编写 SQL 语句**：如果使用原生 SQL 或者自定义查询来实现分页和排序，可以在`UserRepository`接口中使用`@Query`注解。例如：
	```
	import org.springframework.data.domain.Page;
	import org.springframework.data.domain.Pageable;
	import org.springframework.data.jpa.repository.JpaRepository;
	import org.springframework.data.jpa.repository.Query;
	import com.example.entity.User;
	public interface UserRepository extends JpaRepository<User, Long> {
	    @Query("SELECT u FROM User u WHERE u.age > :minAge ORDER BY u.name DESC")
	    Page<User> findUsersByAgeGreaterThanOrderByNameDesc(@Param("minAge") int minAge, Pageable pageable);
	}
	```
	- 这里的`@Query`注解定义了一个自定义查询，查询年龄大于`minAge`的用户，并按照姓名倒序排序。同时，它接受一个`Pageable`对象来实现分页。
	- **在 Service 和 Controller 层使用**：在`UserService`和`UserController`层的使用方式与上述类似，将自定义查询方法融入到业务逻辑和接口暴露中。
### [Spring Boot中的CSRF攻击是什么？如何防范？](https://notes.kamacoder.com/questions/500616)
##### **什么是 CSRF 攻击（跨站请求伪造）**
- **定义**：CSRF（Cross - Site Request Forgery）攻击是一种恶意攻击方式。攻击者会诱导用户访问一个恶意网站，这个恶意网站会包含一些隐藏的表单或者自动执行的 JavaScript 代码，这些代码会在用户已经登录受信任网站（目标网站）的情况下，以用户的身份向目标网站发送请求。
- **攻击示例**：- 例如，用户已经登录了银行网站（假设为`bank.com`），并且银行网站在用户登录后会通过 Cookie 来识别用户身份。攻击者创建一个恶意网站（`evil.com`），在这个网站的页面中有一个隐藏的表单，表单的`action`属性指向银行网站的转账接口（如`bank.com/transfer`），并且表单中包含了转账的金额和收款账户等信息。当用户访问`evil.com`时，浏览器会自动发送这个表单，因为用户已经在银行网站登录，银行网站会根据用户的 Cookie 识别这是一个合法用户的请求，从而执行转账操作，导致用户资金损失。

##### **Spring Boot 中如何防范 CSRF 攻击**
- **使用 Spring Security 开启 CSRF 保护（默认开启）**
	- Spring Boot 与 Spring Security 集成后，默认是开启 CSRF 保护的。Spring Security 会为每个用户生成一个 CSRF 令牌（Token），并将其存储在用户的会话（Session）中。
- **在 RESTful API 中使用 CSRF 保护**
	- 对于 RESTful API，通常是使用 HTTP 头来传递 CSRF 令牌。在 Spring Boot 应用中，可以在客户端（如 JavaScript 代码）获取 CSRF 令牌并添加到请求头中。
	- 例如，在一个使用 Vue.js 的前端应用中，可以在登录成功后获取 CSRF 令牌，并在后续的请求中添加到请求头。在 Spring Boot 后端，可以通过配置 Spring Security 来检查请求头中的 CSRF 令牌。
### [WebSocket在Spring Boot中的应用场景是什么？](https://notes.kamacoder.com/questions/500617)
1. **实时通信场景**
	- **聊天应用**
		- 在即时通讯软件（如在线客服系统、社交聊天软件）中，WebSocket 是实现实时聊天功能的理想选择。Spring Boot 结合 WebSocket 可以轻松构建一个高效的聊天服务器。例如，在一个在线客服系统中，当客户向客服发送消息时，消息能够通过 WebSocket 立即传输到客服端，而不需要像传统的 HTTP 请求那样频繁地轮询服务器查看是否有新消息。这大大提高了消息传递的实时性，减少了延迟和网络带宽的浪费。
		- 多个用户之间的群聊场景也能很好地利用 WebSocket。当一个用户在群聊中发送消息时，服务器可以通过 WebSocket 连接将消息广播给所有其他在线的用户，确保所有参与者能够同时收到最新的聊天内容。
	- **实时数据更新与推送**
		- 在金融领域，比如股票交易软件，需要实时推送股票价格的变化。Spring Boot 应用可以通过 WebSocket 连接将股票价格的实时数据从服务器推送到客户端。当股市有价格波动时，服务器能够立即将新的价格信息发送给所有关注该股票的客户端，让投资者能够及时获取最新的交易信息。
		- 体育赛事的实时比分更新也是类似的应用场景。在体育直播网站上，比赛的比分、进球信息等数据可以通过 WebSocket 实时推送至用户的浏览器，用户无需刷新页面就能第一时间了解比赛的最新进展。

2. **协同工作场景**
	- **在线文档协作**
		- 对于在线文档编辑工具（如 Google Docs 的部分功能实现方式），多个用户可以同时编辑一份文档。WebSocket 在其中起到了关键作用，它允许服务器实时同步各个用户对文档的修改操作。当一个用户在文档中输入文字、插入图片或者进行格式调整时，这些操作会通过 WebSocket 立即传播到其他正在编辑该文档的用户端，使得所有用户看到的文档内容始终保持同步。
	- **实时协作绘图工具**
		- 在一些实时协作绘图的应用中，多个用户可以在同一个画布上进行绘画创作。Spring Boot 与 WebSocket 可以实现用户操作的实时同步，比如一个用户绘制了一条直线，这个绘制动作可以通过 WebSocket 实时传输到其他用户的绘图界面，实现多人协同绘图的实时交互体验。

3. **游戏开发场景**
	- **多人在线游戏**
		- 在多人在线游戏（如多人在线角色扮演游戏、竞技游戏）中，WebSocket 可以用于玩家之间的实时交互。例如，在一个多人在线竞技游戏中，玩家的位置移动、技能释放等操作信息需要实时同步给其他玩家。通过 WebSocket，服务器可以及时将这些游戏状态的变化发送给其他玩家，保证游戏的实时性和流畅性。
		- 游戏中的聊天频道也可以利用 WebSocket 实现实时聊天功能，方便玩家在游戏过程中进行沟通和协作。
4. **物联网场景**
	- **设备状态监控与控制**
		- 假设一个智能家居系统，Spring Boot 作为后端服务器，通过 WebSocket 可以实时接收来自各种物联网设备（如智能摄像头、温度传感器、智能门锁等）发送的状态信息。例如，智能摄像头捕捉到有人闯入时，可以通过 WebSocket 立即将报警信息发送给用户的手机应用，让用户能够及时收到通知。同时，用户也可以通过 WebSocket 向物联网设备发送控制指令，如远程控制智能门锁的开关。
### [AOP在Spring Boot中的应用是什么？](https://notes.kamacoder.com/questions/500618)
#### 面试者回答
AOP（Aspect-Oriented Programming，面向切面编程）主要应用于日志记录、性能监控、事务管理等。

---

#### 详细回答
##### 1. 日志记录
```java
@Aspect
@Component
public class LoggingAspect {
	@Before("execution(* com.example.service.*.*(..))")
	public void logBefore(JoinPoint joinPoint) {
		System.out.println("Executing: " + joinPoint.getSignature());
	}
}
```
##### 2. 性能监控
```java
@Around("execution(* com.example.service.*.*(..))")
public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
	long start = System.currentTimeMillis();
	Object result = joinPoint.proceed();
	long executionTime = System.currentTimeMillis() - start;
	System.out.println("Executed in: " + executionTime + "ms");
	return result;
}
```
##### 3. 事务管理
通过 AOP 自动管理方法的事务边界（Spring 已内置支持，`@Transactional` 注解即为 AOP 实现）。
### [如何在Spring Boot中配置和使用Redis？](https://notes.kamacoder.com/questions/500619)
#### **添加 Redis 依赖**
`<artifactId>spring - boot - starter - data - redis</artifactId>`

#### **配置 Redis 连接信息**
主机地址（`host`）、端口号（`port`）以及密码（如果需要）

#### **使用 RedisTemplate 操作 Redis**
- 在 Spring Boot 的服务类（如`@Service`注解标注的类）中注入`RedisTemplate`来操作 Redis。
- 在`Controller`类中注入`RedisService`来对外提供基于 Redis 的接口。

#### **使用 Redis 缓存（通过`@Cacheable`等注解）**
- 在 Spring Boot 主类上添加`@EnableCaching`注解来开启缓存功能。
- 在`Service`类的方法上使用`@Cacheable`、`@CachePut`和`@CacheEvict`等缓存相关注解。
### [Spring Boot与Spring框架的区别是什么？](https://notes.kamacoder.com/questions/500620)
#### 知识索引
Spring Boot → 与 Spring 框架对比 → 基本概念对比

---

#### 简洁回答
Spring Boot 是对 Spring 框架的进一步封装，简化配置，快速构建。

---

#### 详细回答
- **Spring ** ：配置复杂、大量使用 XML 配置文件来定义 Bean、依赖关系、事务管理等诸多内容。
- **Spring Boot**：采用**约定优于配置**的原则，简化配置。

---

#### 延申问答
- **问题 1：Spring Boot 在简化 Spring 框架配置的同时，会不会失去灵活性？**
	- **回答**：不会。Spring Boot 虽然有很多默认的自动配置，但开发者可以通过自定义配置来覆盖这些默认配置。例如，在自动配置的数据源不符合要求时，可以在`application.properties`中指定自己的数据源相关配置，或者通过创建一个自定义的`DataSource`类型的 Bean 来完全替换自动配置的数据源。
- **问题 2：如果已经有一个基于 Spring 框架的大型项目，能否逐步引入 Spring Boot？**
	- **回答**：可以。可以在项目的部分模块中先尝试使用 Spring Boot 的相关特性。例如，在一个新的微服务模块中使用 Spring Boot 来构建，利用它的自动配置和快速启动的优势。同时，对于与原有 Spring 框架模块的交互，可以通过合适的接口或者服务调用方式来实现整合。
### [如何在Spring Boot中读取配置文件的信息？](https://notes.kamacoder.com/questions/500621)
#### 知识索引
Spring Boot → 配置管理 → 读取配置文件信息

---

#### 简洁回答
- @Value 注解注入单个属性
- 使用 @ConfigurationProperties 注解将配置文件中的一组属性绑定到一个 Java 对象上。

---

#### 详细回答
- **使用 @Value 注解**：- 首先，在 application.properties（或 application.yml）中定义属性，例如：`myapp.name=My Application`。
	- 然后，在需要使用该属性的类中，通过 @Value 注解来注入属性。例如：
```java
    @Component
    public class MyComponent {
        @Value("${myapp.name}")
        private String applicationName;
        // 可以在类的其他方法中使用applicationName这个变量
    }
```

- 这种方式适用于读取单个属性，比较简单直接。但是如果要读取多个相关属性，代码会比较分散。
- **使用 @ConfigurationProperties 注解**：- 假设在 application.yml 中有如下配置：
```yaml
    myapp:
      name: My Application
      version: 1.0
      settings:
        timeout: 5000
        maxConnections: 100
```

- 可以创建一个 Java 类来绑定这些属性，例如：
```java
    @Component
    @ConfigurationProperties(prefix = "myapp")
    public class MyAppProperties {
        private String name;
        private String version;
        private Settings settings;
        // 对应的getter和setter方法
        public static class Settings {
            private int timeout;
            private int maxConnections;
            // 对应的getter和setter方法
        }
    }
```
- 这样，Spring Boot 会自动将配置文件中`myapp`前缀下的属性绑定到`MyAppProperties`类的相应属性上。在其他类中，可以通过注入`MyAppProperties`对象来使用这些属性。

---

#### 延伸问答
- **问题 1：如果配置文件中的属性名和 Java 类中的属性名不一致，如何处理？**
	- **回答**：当使用 @ConfigurationProperties 注解时，可以在注解中使用`ignoreUnknownFields = false`来禁止绑定不存在的属性，并且可以通过在 Java 类的属性上添加`@JsonProperty`（如果是 JSON 格式的配置文件，如 application.yml）或者其他自定义的转换注解来指定属性名的映射关系。
- **问题 2：如何读取不同环境下的配置文件（如开发环境、生产环境）？**
	- **回答**：Spring Boot 支持多环境配置。可以通过在配置文件命名上遵循一定的规则，如`application - dev.properties`（开发环境）、`application - prod.properties`（生产环境）等。然后在启动应用时，可以通过`--spring.profiles.active=dev`（激活开发环境配置）这样的命令行参数或者在 IDE 中设置环境变量来指定使用哪个环境的配置文件。同时，也可以在配置文件中使用`spring.profiles`属性来指定某个配置块所属的环境，例如：


收起

yaml

```
    spring:
      profiles: dev
      myapp:
        name: Dev Application
```

这个配置块只有在开发环境下才会被加载。
### [如何在Spring Boot中实现定时任务？](https://notes.kamacoder.com/questions/500622)
#### **使用`@Scheduled`注解（简单定时任务）**
- 引入了`spring - boot - starter`相关依赖
- 在任意的 Spring 管理的组件（如`@Service`、`@Component`等注解标注的类）中，可以创建定时任务方法。使用`@Scheduled`注解来指定任务的执行时间。

#### **动态配置定时任务（使用`SchedulingConfigurer`）**
- 如果需要动态地配置定时任务，例如在运行时根据配置文件或者数据库中的配置来改变定时任务的执行时间，可以实现`SchedulingConfigurer`接口。

#### **使用 Quartz 框架（复杂定时任务场景）**使用 Quartz 框架（复杂定时任务场景）**
- 如果`@Scheduled`注解不能满足复杂的定时任务需求，如分布式环境下的定时任务管理、任务持久化、任务依赖等，可以考虑使用 Quartz 框架。
- 在`application.properties`或`application.yml`文件中可以配置 Quartz 的相关参数，如数据库连接（如果需要将任务信息持久化到数据库）、线程池大小等。
- 在这个`QuartzConfig`配置类中，首先通过`JobBuilder`创建了一个`JobDetail`对象，用于定义任务的详细信息（如任务类、任务名称和组等）。然后通过`TriggerBuilder`创建了一个`Trigger`对象，用于定义任务的触发时间规则（如间隔时间、开始时间等）。最后通过`Scheduler`将`JobDetail`和`Trigger`关联起来，实现定时任务的调度。


### [Spring Boot如何与Kafka整合？](https://notes.kamacoder.com/questions/500623)
Spring Boot 可以通过 `spring-kafka` 依赖轻松整合 Kafka。配置 Kafka 的生产者（Producer）和消费者（Consumer）来发送和接收消息。通过配置 `application.properties` 或 `application.yml`，并使用 `@KafkaListener` 注解监听消息。

##### 1. 添加依赖
在 `pom.xml` 中添加 `spring-kafka` 依赖

##### 2. 配置 Kafka
在 `application.properties` 或 `application.yml` 中配置 Kafka 连接信息

##### 3. 创建生产者和消费者
- **生产者：** 使用 `KafkaTemplate` 发送消息。
- **消费者：** 使用 `@KafkaListener` 注解监听消息。
### [如何在Spring Boot中进行单元测试？](https://notes.kamacoder.com/questions/500624)
在 Spring Boot 中进行单元测试，通常使用 `@SpringBootTest` 进行集成测试，`@MockBean` 模拟外部依赖。也可以通过 `@DataJpaTest`、`@WebMvcTest` 等注解进行特定的层级测试。
##### 1. 使用 `@SpringBootTest`

`@SpringBootTest` 启动整个 Spring 上下文，进行集成测试：`@SpringBootTest`。
##### 2. 模拟依赖 `@MockBean`

使用 `@MockBean` 模拟数据库或外部服务依赖：`@MockBean private MyRepository myRepository;`。
##### 3. 针对性测试

- `@DataJpaTest` 用于 JPA 测试：`@DataJpaTest`。
- `@WebMvcTest` 用于 Web 层测试：`@WebMvcTest(MyController.class)`。
### [Spring Boot Actuator提供了哪些功能？](https://notes.kamacoder.com/questions/500625)
Spring Boot Actuator 提供了生产环境下的监控、管理和审计功能，主要包括健康检查、指标暴露、应用环境信息、日志级别动态修改等。
##### 1. 健康检查（Health Checks）

提供应用健康状态的端点，例如 `/actuator/health`，显示服务的健康状况。
##### 2. 应用指标（Metrics）

暴露应用运行时的性能指标，如内存使用、请求计数等，通过 `/actuator/metrics` 获取。
##### 3. 环境信息（Environment Info）

通过 `/actuator/env` 端点暴露应用的环境配置信息。
##### 4. 审计和日志

提供 `/actuator/auditevents` 审计事件和 `/actuator/loggers` 动态修改日志级别的功能。
##### 5. 自定义端点

支持开发自定义的 Actuator 端点。
### [如何在Spring Boot中部署到外部服务器？](https://notes.kamacoder.com/questions/500626)
在 Spring Boot 中部署到外部服务器，通常是将应用打包成 WAR 文件，部署到外部 Servlet 容器（如 Tomcat、Jetty），或者通过 Docker 容器化部署。
##### 1. 生成 WAR 文件

在 `pom.xml` 中修改为 `provided` 作用域：`<scope>provided</scope>`，生成 WAR 文件。
##### 2. 部署到外部容器

将 WAR 文件部署到 Tomcat 或 Jetty 等容器的 `webapps` 文件夹中。
##### 3. 使用 Docker 容器化部署

创建 `Dockerfile`，将 JAR 文件复制到容器中，并设置 `ENTRYPOINT`：`ENTRYPOINT ["java", "-jar", "/myapp.jar"]`。
### [Spring Boot与Docker的集成步骤是什么？](https://notes.kamacoder.com/questions/500627)
Spring Boot 与 Docker 集成的步骤包括：构建 JAR 文件、创建 Dockerfile、构建 Docker 镜像和运行容器。

##### 1. 构建 JAR 文件
使用 `mvn clean package` 或 `gradle build` 构建 Spring Boot JAR 文件。

##### 2. 创建 Dockerfile
在项目根目录创建 `Dockerfile`，内容包括基础镜像、复制 JAR 文件和设置容器启动命令：
```
FROM openjdk:11
COPY target/myapp.jar myapp.jar
ENTRYPOINT ["java", "-jar", "/myapp.jar"]
```
##### 3. 构建 Docker 镜像
使用命令 `docker build -t myapp .` 构建 Docker 镜像。

##### 4. 运行容器
使用命令 `docker run -p 8080:8080 myapp` 启动容器，映射端口 8080。
### [什么是微服务？Spring Boot在微服务架构中的应用是什么？](https://notes.kamacoder.com/questions/500628)
微服务是一种架构风格，将应用拆分成多个独立、自治的服务，每个服务执行单一业务功能。Spring Boot 在微服务架构中用于快速构建、配置和部署这些独立的服务。

##### 1. 微服务的定义
微服务架构将应用程序拆分成多个小型、独立的服务，每个服务通过轻量级的通信协议（如 HTTP REST API）进行交互。每个服务通常是围绕业务功能进行划分，独立部署，独立扩展。

##### 2. Spring Boot 在微服务中的作用
- **快速开发**：Spring Boot 提供了开箱即用的配置和内嵌的服务器（如 Tomcat），简化微服务的构建过程。
- **独立运行**：通过 JAR 或 WAR 打包，Spring Boot 应用可以独立运行，适合微服务架构。
- **配置管理**：Spring Cloud 配合 Spring Boot 提供了服务发现、配置中心、负载均衡等支持，进一步完善微服务架构的实现。

##### 3. 微服务架构的优点
- **独立性**：每个微服务独立开发、部署和扩展。
- **灵活性**：可以使用不同技术栈实现不同服务。
- **高可用性**：服务之间解耦，提高了系统的容错性和可靠性。
### [Spring Cloud中的服务发现与注册是什么？如何使用？](https://notes.kamacoder.com/questions/500629)
#### 简要回答

服务发现与注册是微服务架构中服务自动注册和查找其他服务的机制，Spring Cloud 使用 **Eureka**、**Consul** 或 **Zookeeper** 来实现。服务通过注册中心注册自己，其他服务通过注册中心发现并调用。
##### 1. 服务发现与注册的定义

服务发现是指服务自动地注册到一个注册中心，供其他服务查找并调用。
##### 2. 如何使用服务发现与注册

- **Eureka 客户端配置**：在 `application.properties` 中配置 Eureka 服务端地址
	`eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka`
- **启用服务发现**：在启动类中使用 `@EnableDiscoveryClient` 注解启用客户端
	`@EnableDiscoveryClient @SpringBootApplication public class Application {}`
- **服务注册**：Spring Boot 默认会通过 `@EnableDiscoveryClient` 自动注册服务，基于应用名称注册。
- **服务发现**：使用 `@LoadBalanced` 配置 `RestTemplate` 来自动发现并调用服务
	`@Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); }`

##### 3. 其他服务发现工具

- **Consul**：配置 `spring.cloud.consul.discovery`，类似于 Eureka。
### [Spring Cloud Config是什么？如何在Spring Boot中使用？](https://notes.kamacoder.com/questions/500630)
#### 简要回答
Spring Cloud Config 是一个集中式配置管理工具，用于管理多个微服务的配置信息，可以将配置信息存储在 Git、SVN 或本地文件系统中。Spring Boot 微服务通过 Spring Cloud Config 客户端从配置服务器加载这些配置信息。

##### 1. Spring Cloud Config的作用
- 集中管理多个微服务的配置文件。
- 支持热更新配置，无需重启服务。
- 配置存储支持 Git、SVN 或本地文件系统。

##### 2. 如何在Spring Boot中使用
- **配置 Spring Cloud Config Server**：
	1. 创建一个 Spring Boot 应用并添加 `spring-cloud-config-server` 依赖。
	2. 在主类中使用 `@EnableConfigServer` 注解启用配置服务器。
	3. 在 `application.yml` 中配置 Git 仓库位置。
**配置 Spring Cloud Config Client**：
	1. 创建一个 Spring Boot 应用并添加 `spring-cloud-starter-config` 依赖。
	2. 在 `application.yml` 中配置 Config Server 地址。
	3. 配置文件从配置服务器加载，应用会在启动时自动加载。

##### 3. 配置文件热更新
通过启用 `@RefreshScope` 注解，结合 `POST /actuator/refresh` 刷新配置。

### [Spring Cloud Gateway是什么？如何在Spring Boot中使用？](https://notes.kamacoder.com/questions/500631)
Spring Cloud Gateway 是一个基于 Spring WebFlux 构建的 API 网关，它提供了动态路由、负载均衡、限流等功能，主要用于微服务架构中作为流量入口。使用时，通过配置路由和过滤器来控制请求流向和处理。
##### 1. Spring Cloud Gateway的作用

- 提供请求路由：将请求路由到具体的微服务。
- 提供过滤器：用于实现请求的预处理、后处理、限流、认证等功能。

##### 2. 如何在Spring Boot中使用

- 在 `pom.xml` 中添加依赖：
	`spring-cloud-starter-gateway`
- 配置路由：在 `application.yml` 或 `application.properties` 中配置路由规则
- 在启动类中添加 `@EnableGateway` 注解（在 Spring Cloud 版本 >= 2020 时不需要）。

##### 3. 其他配置

- **过滤器**：可以定义自定义过滤器，用于处理请求和响应。
	示例：`spring.cloud.gateway.filters.addRequestHeader=Authorization, Bearer token`
## Spring Cloud
### [Spring Cloud是什么？它解决了什么问题？](https://notes.kamacoder.com/questions/500632)
Spring Cloud 是一套**基于 Spring Boot**  的**微服务开发工具集**，它提供了常见的微服务架构所需的功能，包括**服务发现、配置管理、断路器、负载均衡**等。它帮助开发者更简便地构建和维护大规模分布式系统。
##### 1. Spring Cloud 解决的问题

- **服务注册与发现**：通过 Spring Cloud Netflix Eureka、Consul 或 Zookeeper 实现微服务的动态注册与发现。
- **分布式配置管理**：集中化管理多个微服务的配置文件，支持动态更新和热加载。
- **负载均衡**：利用 Ribbon 或其他组件在多个服务实例之间进行负载均衡。
- **断路器**：通过 Hystrix 提供容错处理，防止某个微服务故障蔓延。
- **API 网关**：Spring Cloud Gateway 或 Zuul 提供统一的流量入口，管理请求路由、限流、过滤等。
- **消息总线**：通过 Spring Cloud Bus 实现微服务之间的消息广播，支持事件驱动架构。

##### 2. Spring Cloud 的组成模块

- **Spring Cloud Config**：集中式配置管理。
- **Spring Cloud Netflix**：包含 Eureka（服务发现）、Ribbon（负载均衡）、Hystrix（断路器）等组件。
- **Spring Cloud Gateway / Zuul**：API 网关，处理路由、过滤等。
- **Spring Cloud Stream**：基于消息驱动的微服务，支持 Kafka、RabbitMQ 等消息中间件。
- **Spring Cloud Sleuth**：分布式追踪，结合 Zipkin 或其他工具进行日志关联。

##### 3. Spring Cloud 在微服务架构中的应用

Spring Cloud 提供了一站式解决方案，可以有效简化微服务开发过程，帮助开发者专注于业务实现而不必从零开始实现分布式系统的基础设施。
### [Spring Cloud和Dubbo的区别是什么？](https://notes.kamacoder.com/questions/500633)
#### 简要回答
Spring Cloud 和 Dubbo 都是常用的微服务框架，但它们的重点和使用场景有所不同。
- Spring Cloud 更加注重**全栈微服务解决方案**，提供完整的微服务治理体系，
- 而 Dubbo 更专注于**高性能、跨语言**的服务调用框架，适用于**高吞吐量、低延迟**的场景。

##### 1. Spring Cloud vs Dubbo 的定位

- **Spring Cloud**：是一个基于 Spring Boot 的微服务架构工具集，集成了服务注册与发现、配置管理、负载均衡、断路器等功能，适合构建完整的微服务架构。
- **Dubbo**：是一款高性能的 RPC 框架，原生支持分布式服务，专注于提供高效、可靠的远程调用，特别适用于跨语言的服务调用。

##### 2. 核心功能和使用场景

- **Spring Cloud**：- 提供完整的微服务解决方案，包括服务治理、配置管理、API 网关、消息总线等。
	- 适合需要统一治理和分布式架构的微服务系统。
	- 使用场景：微服务架构中各个模块的协作与治理，如服务注册、负载均衡、断路器等。
- **Dubbo**：- 主要专注于高效的服务调用，支持 RPC 调用，适用于低延迟、高并发的分布式服务。
	- 适合高性能的远程调用场景，尤其是在大规模分布式系统中。
	- 使用场景：跨服务间的高效、稳定的远程过程调用，特别是需要跨语言调用时。

##### 3. 技术栈差异

- **Spring Cloud**：是基于 Spring Boot 的，通常与 Spring 全家桶（如 Spring Boot、Spring Data、Spring Security）紧密集成，适合于 Java 生态系统。
- **Dubbo**：原生为 Java 语言开发，但通过扩展可以支持其他语言（如 Python、C++），侧重于 RPC 服务通信。

##### 4. 生态系统

- **Spring Cloud**：提供丰富的生态工具和开源组件（如 Eureka、Hystrix、Zuul、Spring Cloud Config）。
- **Dubbo**：虽然也有相应的服务发现与负载均衡功能，但其核心功能主要集中在服务调用上，生态较为轻量。

##### 5. 性能和扩展性

- **Spring Cloud**：集成了众多中间件，灵活性和扩展性较强，但性能相对较低。
- **Dubbo**：由于其高性能的 RPC 调用机制，在高吞吐量、低延迟场景下表现更好。
### [Spring Cloud Eureka的作用是什么？它是如何实现服务注册的？](https://notes.kamacoder.com/questions/500634)
#### 简要回答
Spring Cloud **Eureka** 是一个**服务注册与发现**的工具，用于构建**基于云的分布式系统**。在微服务架构中，服务实例**通过 Eureka 进行注册**，其他服务可以通过 Eureka **查找并调用已注册的服务**。

##### 1. Eureka 的作用

- **服务注册**：Eureka Server 作为服务注册中心，管理所有微服务实例的信息，帮助服务实例自动注册并定期续约。
- **服务发现**：Eureka Client 通过向 Eureka Server 查询已注册的服务信息，实现服务的发现和调用，支持客户端负载均衡。
- **高可用性**：Eureka 具有自我保护机制，即使部分服务不可用，仍能保持其他服务的正常运行。

##### 2. Eureka 如何实现服务注册

- **服务注册**：每个微服务在启动时，向 Eureka Server 发送注册请求，将服务实例的信息（如 IP、端口等）注册到 Eureka Server 上。
	- 使用 `@EnableEurekaClient` 注解来启用服务注册功能。
	- 在 `application.yml` 或 `application.properties` 中配置 Eureka 服务地址。
	```
	yaml复制代码eureka:
	  client:
	    service-url:
	      defaultZone: http://localhost:8761/eureka/
	```
- **服务续约**：每个服务实例会定期向 Eureka Server 发送续约请求，确认它们的存活状态。若服务未能在一定时间内续约，Eureka 会将其从注册中心移除。

##### 3. 服务发现过程

- **客户端调用**：微服务客户端通过 Eureka 服务器查询服务实例信息，获取可用的服务列表。
- **负载均衡**：客户端可以结合 Ribbon（Spring Cloud 提供的负载均衡器）实现服务的负载均衡调度。
### [如何配置Spring Cloud Eureka客户端和服务端？](https://notes.kamacoder.com/questions/500635)
配置 Spring Cloud Eureka 客户端和服务端，服务端提供注册中心功能，客户端通过 Eureka 注册和发现服务。服务端配置 Eureka Server，客户端通过配置 Eureka Client 连接到服务端，实现服务注册与发现。
##### 1. 配置 Eureka 服务端（Eureka Server）

- **步骤**：创建一个 Spring Boot 应用，添加 `@EnableEurekaServer` 注解，启动 Eureka 服务端。
- **依赖**：在 `pom.xml` 中添加 Eureka Server 依赖。
- **主类**：在主类上添加 `@EnableEurekaServer` 注解，启用 Eureka 服务功能。
- **配置文件**：在 `application.yml` 中配置 Eureka Server。

##### 2. 配置 Eureka 客户端（Eureka Client）

- **步骤**：在微服务应用中添加 `@EnableEurekaClient` 注解，配置 Eureka 客户端连接到 Eureka 服务端。
- **依赖**：在 `pom.xml` 中添加 Eureka Client 依赖。
- **主类**：在主类上添加 `@EnableEurekaClient` 注解，启用 Eureka 客户端功能。
- **配置文件**：在 `application.yml` 中配置 Eureka 客户端连接到 Eureka Server。

##### 3. 启动流程

- 启动 Eureka 服务端应用，它会启动并监听指定端口（如 `8761`）。
- 启动 Eureka 客户端应用，它会自动向 Eureka 服务端注册，成为可用服务。

##### 4. 服务注册与发现

- Eureka 客户端会将服务实例注册到 Eureka Server。
- 其他微服务可以通过 Eureka Server 查询已注册的服务实例，实现服务发现。
### [Eureka的自我保护模式是什么？在什么情况下会触发？](https://notes.kamacoder.com/questions/500636)
Eureka 的自我保护模式是一种机制，旨在保护 Eureka Server 在服务实例断开连接时的稳定性。当 Eureka Server 不能从客户端接收到足够的心跳时，它会进入自我保护模式，避免过早地将服务实例标记为不可用。
##### 1. 自我保护模式的触发条件

- **心跳超时**：Eureka Server 在一段时间内未收到来自某个服务实例的心跳信息时，默认会标记该实例为失效。但当发现大量服务实例心跳失效时，Eureka 为了防止误判服务宕机，会触发自我保护模式。
- **网络问题**：例如网络中断、Eureka Server 与客户端之间的连接不稳定时，也会触发自我保护模式。

##### 2. 自我保护模式的作用

- **避免错误移除服务**：进入自我保护模式后，Eureka Server 会忽略服务实例的过期时间，不会立即将实例从注册中心移除，避免在服务暂时不可用时将其误判为宕机。
- **维护系统可用性**：即使部分服务无法连接，Eureka 也会维持现有注册信息，确保系统的高可用性。

##### 3. 自我保护模式的禁用

- **配置禁用**：可以通过配置禁用自我保护模式（不推荐，但适用于某些特殊场景），即在 `application.yml` 中设置：
```
eureka:
  server:
    evict-interval-timer-in-ms: 1000  # 默认 60 秒，这个设置会使得失效实例被及时清除
    enable-self-preservation: false  # 禁用自我保护模式
```
### [Spring Cloud Ribbon是如何实现客户端负载均衡的？](https://notes.kamacoder.com/questions/500637)
#### 简要回答

Spring Cloud Ribbon 是一个客户端负载均衡工具，它通过拦截 HTTP 请求并根据负载均衡策略（如轮询、随机等）选择合适的服务实例进行请求。Ribbon 在服务调用时，动态选择服务实例，避免直接调用服务的硬编码 IP 和端口。
##### 1. 客户端负载均衡实现

- **服务发现**：Ribbon 可以与 Eureka 等服务注册与发现机制集成，动态获取服务实例。
- **负载均衡策略**：Ribbon 提供多种负载均衡策略（如轮询、加权轮询、随机等），可以通过配置文件或代码方式指定。
	默认轮询策略通过 `@LoadBalanced` 注解实现，配置时 Ribbon 会自动为服务实例分配负载均衡策略。

##### 2. Ribbon的工作机制

- **拦截请求**：Ribbon 在客户端发起请求时，拦截请求并查询服务实例列表。
- **选择服务**：根据配置的负载均衡策略（例如轮询、随机），Ribbon 选择一个可用的服务实例来转发请求。
- **请求转发**：Ribbon 根据选定的服务实例的 IP 和端口，将请求发送到目标服务。

##### 3. 使用Ribbon实现负载均衡

- **依赖**：引入 `spring-cloud-starter-netflix-ribbon` 依赖。
- **注解**：在 `RestTemplate` 上使用 `@LoadBalanced` 注解启用 Ribbon 的负载均衡功能。
- **使用**：使用 Ribbon 发送请求时，`RestTemplate` 会自动选择一个服务实例并发送请求。


##### 4. 配置负载均衡策略

- **轮询**：默认的负载均衡策略是轮询。
- **自定义策略**：可以在配置文件中自定义 Ribbon 的负载均衡策略，如随机策略等。


##### 5. 扩展和自定义

- **自定义负载均衡规则**：通过实现 `IRule` 接口，可以创建自定义的负载均衡策略。
### [Ribbon的负载均衡策略有哪些？如何配置？](https://notes.kamacoder.com/questions/500638)
#### 简要回答

Ribbon 提供了多种负载均衡策略，主要包括 **轮询**、**随机**、**加权轮询**、**响应时间加权** 等。通过配置不同的策略，可以定制化负载均衡行为。可以在 `application.yml` 或 `application.properties` 文件中配置负载均衡策略，也可以通过代码自定义策略。
##### 1. 负载均衡策略

- **轮询（Round Robin）**：请求依次分配给各个实例，最常用的负载均衡策略。
- **随机（Random）**：随机选择一个实例来处理请求。
- **加权轮询（Weighted Round Robin）**：不同实例根据配置的权重分配请求，高权重实例承担更多请求。
- **响应时间加权（Response Time Weighted）**：根据服务响应时间来动态选择服务实例，响应时间短的实例优先。

##### 2. 配置负载均衡策略

- **轮询**（默认策略）
	Ribbon 默认使用轮询策略，不需要特别配置。
- **随机策略**
	可以通过配置 `ribbon.NFLoadBalancerRuleClassName` 来选择随机策略。
- **加权轮询**
	配置 `ribbon.NFLoadBalancerRuleClassName` 和 `ribbon.ServerList` 来指定权重。
- **响应时间加权**
	配置 `ribbon.NFLoadBalancerRuleClassName` 来使用响应时间加权策略。

##### 3. 使用自定义负载均衡策略

可以通过代码方式配置负载均衡策略，例如创建自定义的 `ILoadBalancer` 和 `IRule` 实现，注入到 Spring 配置中。

##### 4. 总结

- **默认策略**：Ribbon 默认使用轮询策略。
- **自定义策略**：可以通过配置文件或代码自定义策略，例如使用 `RandomRule`、`WeightedResponseTimeRule` 等。
- **动态权重**：可以基于服务的响应时间或其他因素动态调整负载均衡策略。
### [Spring Cloud Feign是什么？它与Ribbon和Hystrix的关系是什么？](https://notes.kamacoder.com/questions/500639)
#### 简要回答

Spring Cloud Feign 是一个**声明式的 Web 服务客户端**，它**简化了 HTTP 请求的编写**，使得**服务之间的调用更加方便**。它与 Ribbon 和 Hystrix **紧密集成**，分别负责**负载均衡**和**容错处理**。Feign 会自动集成 Ribbon 进行客户端负载均衡，并且可以通过 Hystrix 实现容错和断路器功能。

##### 1. Feign的作用

- **声明式 HTTP 客户端**：通过注解的方式定义服务接口，简化了 HTTP 请求的发送。
- **简化代码**：无需手动编写 REST 调用逻辑，Feign 自动生成 HTTP 请求的实现。

##### 2. Feign 与 Ribbon

- **Ribbon 集成**：Feign 默认集成了 Ribbon，实现了客户端负载均衡。每次调用 Feign 客户端时，Ribbon 会负责选择合适的服务实例。

##### 3. Feign 与 Hystrix

- **Hystrix 集成**：Feign 可以与 Hystrix 集成来实现断路器模式，对失败的请求进行降级处理。

##### 4. 使用场景

- **Feign** 适用于简化微服务之间的 HTTP 调用，特别是在服务间通信中通过注解方式声明接口，并实现客户端负载均衡和容错功能。
### [如何使用Spring Cloud Feign进行服务间的HTTP调用？](https://notes.kamacoder.com/questions/500640)
#### 简要回答

使用 Spring Cloud Feign 进行服务间的 HTTP 调用，通过定义 Feign 客户端接口并使用 `@FeignClient` 注解指定服务名称。Feiign 会自动生成 HTTP 请求的实现，并通过 Ribbon 实现负载均衡。

##### 1. 添加依赖

首先在 `pom.xml` 中添加 Feign 和 Spring Cloud Starter 依赖。

##### 2. 启用 Feign 客户端

在主应用类上添加 `@EnableFeignClients` 注解以启用 Feign。

##### 3. 定义 Feign 客户端接口

使用 `@FeignClient` 注解定义一个接口来表示远程服务，`value` 指定服务名称，方法参数和返回值类型与目标服务的接口一致。

##### 4. 在 Service 层调用 Feign 客户端

在你的 Service 类中注入 Feign 客户端接口并调用其方法。

##### 5. 配置负载均衡和超时

Feign 会自动集成 Ribbon 来实现负载均衡，可以通过 `application.yml` 配置默认的超时或重试策略。

##### 6. 使用 Hystrix 进行容错处理（可选）

为了实现容错，可以配置 Feign 与 Hystrix 集成。
### [Hystrix是什么？它解决了什么问题？](https://notes.kamacoder.com/questions/500641)
#### 简要回答

Hystrix 是一个**容错库**，用于处理**分布式系统中的服务失败问题**，主要通过实现 **“断路器”模式** 来避免级联故障，提升系统的稳定性和可靠性。

##### 1. 解决的问题

- **服务容错**：避免服务之间的故障传播，保护系统免受故障影响。
- **防止级联故障**：当某个服务故障时，自动停止对该服务的调用，防止故障影响到其他服务。
- **降级处理**：当调用的服务不可用时，提供默认响应或回退逻辑，确保服务继续可用。

##### 2. 断路器模式

Hystrix 通过断路器模式，当某个服务失败达到一定阈值时，断路器会被触发，停止对该服务的调用，直到该服务恢复正常。
##### 3. 核心功能

- **熔断**：检测请求的失败率，超出设定阈值时自动触发熔断，停止访问不健康的服务。
- **隔离**：通过线程池或信号量隔离不同服务的调用，防止故障扩散。
-
### [如何配置Hystrix的线程池和命令属性？](https://notes.kamacoder.com/questions/500642)
#### 简要回答

Hystrix的线程池和命令属性配置涉及控制线程池大小、超时、回退等。通过`@HystrixCommand`注解或`HystrixPropertiesManager`设置。
##### Hystrix线程池配置

线程池通过`hystrix.command.default.execution.isolation.strategy`控制，默认是`THREAD`，使用独立线程池。
##### 线程池大小

通过`hystrix.threadpool.default.coreSize`配置线程池大小，决定最大并发量。
##### 超时配置

通过`hystrix.command.default.execution.timeoutInMilliseconds`设置命令的超时时间。
##### 回退配置

通过`fallbackMethod`指定失败后的回退方法，保证服务降级时仍能返回合理响应。
##### 自定义配置

可以在`application.yml`中按需调整配置，或在代码中通过`HystrixCommandProperties`进行个性化配置。
### [Spring Cloud Zuul是什么？它如何作为API网关工作？](https://notes.kamacoder.com/questions/500643)
#### 简要回答

Spring Cloud Zuul是一个API网关，它负责请求路由、负载均衡、身份认证、权限控制、监控、日志等功能。通过Zuul，微服务应用中的客户端可以统一访问各种服务接口，并且可以做请求的转发、过滤和路由。Zuul基于Netflix的Zuul实现，提供了动态路由功能，能够将请求转发到后端微服务，同时支持API聚合。
### [Zuul的路由和过滤机制是怎样的？](https://notes.kamacoder.com/questions/500644)
#### 简要回答

**Zuul的路由机制：**
- 通过配置路由规则，将请求转发到相应的微服务。
- 配置项包括`zuul.routes`，通过服务ID或URL进行路由配置。

**Zuul的过滤机制：**
- **前置过滤器**：在请求到达后端服务前执行，用于进行身份验证、日志记录等。
- **后置过滤器**：在请求完成后执行，处理响应，修改响应数据等。
- **路由过滤器**：负责实际的请求路由，决定请求转发的目标地址。
- **异常过滤器**：用于处理路由过程中发生的异常。
### [Spring Cloud Config是什么？它如何管理分布式配置？](https://notes.kamacoder.com/questions/500645)
#### 简要回答

**Spring Cloud Config：**
- 是一个集中化的配置管理工具，用于管理分布式系统中的应用配置。
- 支持将配置存储在Git、SVN等外部仓库中，也支持本地文件系统。

**分布式配置管理：**
- **Config Server**：负责读取并提供配置文件（例如从Git仓库中加载）。
- **Config Client**：通过`@RefreshScope`和`@Value`注解来获取和更新配置信息。
- 支持动态刷新配置，通过`/actuator/refresh`端点实现配置的实时更新。
### [如何配置Spring Cloud Config Server和Client？](https://notes.kamacoder.com/questions/500646)
#### 简要回答

**Config Server配置：**
- 在`@SpringBootApplication`类上使用`@EnableConfigServer`注解启用Config Server。
- 配置`application.properties`或`application.yml`来指定配置源：- `spring.cloud.config.server.git.uri=Git仓库地址`
	- 或 `spring.cloud.config.server.native.searchLocations=本地文件路径`

**Config Client配置：**
- 在客户端应用的`application.properties`中配置Config Server地址：- `spring.cloud.config.uri=http://localhost:8888`
- 使用`@RefreshScope`注解来支持动态刷新配置。
- 在`@Value`或`@ConfigurationProperties`中读取配置。
### [Spring Cloud Bus是什么？它如何与Config Server结合使用？](https://notes.kamacoder.com/questions/500647)
#### 简要回答

**Spring Cloud Bus：**
- Spring Cloud Bus是一个用于传播事件或消息的机制，通常用于微服务架构中的广播通信。
- 它通过消息中间件（如RabbitMQ或Kafka）在多个服务之间传播事件。

**与Config Server结合：**
- 当Config Server中的配置发生变化时，Spring Cloud Bus可以通过事件广播将配置信息推送到所有相关的客户端。
- 客户端使用`@RefreshScope`注解来动态刷新配置，避免重启服务。
- 配置刷新事件通常通过`POST /actuator/refresh`端点触发，通过Bus广播到所有微服务。
### [Spring Cloud Stream是什么？它解决了什么问题？](https://notes.kamacoder.com/questions/500648)
#### 简要回答

**Spring Cloud Stream：**
- Spring Cloud Stream是一个用于构建消息驱动微服务的框架，它简化了消息队列的配置和消息的处理。
- 提供了对消息中间件（如Kafka、RabbitMQ）的抽象和集成，支持消息发布、接收及处理。

**解决的问题：**
- 简化了分布式系统中的消息传递和事件流处理。
- 隐藏了底层消息中间件的细节，提供统一的编程模型。
- 支持弹性和可扩展的消息驱动架构，适合微服务之间的异步通信。
### [如何使用Spring Cloud Stream与RabbitMQ或Kafka集成？](https://notes.kamacoder.com/questions/500649)
#### 简要回答

**Spring Cloud Stream与RabbitMQ集成：**
- 在`application.yml`中配置RabbitMQ连接信息
- 使用`@StreamListener`注解监听队列
- 配置`spring-cloud-stream-binder-rabbit`依赖。

**Spring Cloud Stream与Kafka集成：**
- 在`application.yml`中配置Kafka连接信息
- 使用`@StreamListener`注解监听Kafka主题
- 配置`spring-cloud-stream-binder-kafka`依赖
### [Spring Cloud Sleuth和Zipkin的作用是什么？它们如何帮助追踪微服务调用？](https://notes.kamacoder.com/questions/500650)
#### 简要回答

**Spring Cloud Sleuth：**
- Spring Cloud Sleuth是一个分布式追踪工具，它为微服务中的请求生成**唯一的跟踪ID（trace ID）和跨度ID（span ID）**。
- 自动为每个请求添加跟踪信息，并将这些信息**传递给下游服务**，帮助分析请求流向和性能瓶颈。

**Zipkin：**
- Zipkin是一个分布式追踪系统，负责**收集、存储和查询由Sleuth生成的追踪数据**。
- Zipkin提供了一个UI界面，可以查看每个请求的详细追踪信息，帮助开发者分析请求的生命周期。

**如何帮助追踪微服务调用：**
- **Sleuth**：自动为每个请求生成唯一标识，追踪跨微服务的请求流转。
- **Zipkin**：作为后端存储和展示工具，提供了追踪数据的查询和可视化功能，帮助定位微服务之间的性能问题或错误。
### [如何配置Spring Cloud Sleuth和Zipkin以追踪服务调用？](https://notes.kamacoder.com/questions/500651)
#### 简要回答

**配置Spring Cloud Sleuth：**
- 在`pom.xml`中添加`spring-cloud-starter-sleuth`依赖
- Spring Cloud Sleuth会自动为应用中的请求添加分布式追踪信息，如`traceId`和`spanId`。

**配置Zipkin：**
- 在`pom.xml`中添加`spring-cloud-starter-zipkin`依赖
- 在`application.yml`中配置Zipkin服务器地址
### [Spring Cloud Gateway与Zuul的区别是什么？](https://notes.kamacoder.com/questions/500652)
#### 简要回答

**功能差异：**
- **Spring Cloud Gateway**：基于反应式编程，采用Netty作为底层框架，支持高并发、高性能，适合现代微服务架构中的API网关需求。
- **Zuul**：基于Servlet的架构，采用Tomcat作为底层容器，适用于传统的同步请求处理。

**性能差异：**
- **Spring Cloud Gateway**：由于使用反应式编程和Netty，能够处理更高的并发请求，性能更优。
- **Zuul**：性能相对较低，特别是在高并发环境下，响应速度较慢。

**可扩展性：**
- **Spring Cloud Gateway**：提供了更为灵活的路由功能，支持基于功能的过滤器，易于扩展。
- **Zuul**：虽然支持过滤器，但灵活性不如Spring Cloud Gateway。

**总结：**
- Spring Cloud Gateway相较于Zuul**在性能和可扩展性上更为强大，适合更高并发和微服务架构**，特别是在基于反应式编程的环境中。而Zuul在传统基于Servlet的架构中应用较多。
### [如何使用Spring Cloud Gateway进行路由和过滤？](https://notes.kamacoder.com/questions/500653)
#### 简要回答

**路由配置：**
- 使用`RouteLocator`定义路由规则，通过`Path`、`Method`等条件匹配请求。
- 可在`application.yml`或Java代码中配置。

**过滤器：**
- 支持**全局过滤器**和**局部过滤器**，在请求和响应生命周期中进行处理。
- 过滤器类型：`pre`（请求前）、`post`（请求后）、`error`（错误处理）。
### [Spring Cloud OpenFeign与Feign的区别是什么？](https://notes.kamacoder.com/questions/500654)
#### 简要回答

**Feign：**
- 是一个声明式的HTTP客户端，简化了服务间的HTTP调用。
- 仅提供HTTP请求功能，依赖于外部库（如Ribbon、Hystrix）来支持负载均衡和容错。

**Spring Cloud OpenFeign：**
- 是Spring Cloud中对Feign的集成，增强了与Spring的兼容性和易用性。
- 提供更多功能，如与Spring Security集成、自动化配置、使用Spring MVC注解等。

**主要区别：**
- OpenFeign通过Spring Boot的自动配置功能**简化了使用，并且集成了Spring的其他功能（如负载均衡、断路器等）**。
- Feign本身独立，需要手动配置其他功能。
### [Spring Cloud Alibaba是什么？它包含了哪些组件？](https://notes.kamacoder.com/questions/500655)
**Spring Cloud Alibaba：**
- 是一个基于Spring Cloud的**微服务解决方案**，结合了**阿里巴巴开源项目**，提供了**分布式系统的开发支持**。
- 旨在简化微服务架构的构建，支持高可用、分布式事务、服务治理等功能。

**包含的组件：**
1. **Nacos：** 提供服务发现和配置管理。
2. **Sentinel：** 提供流量控制、熔断和降级功能。
3. **RocketMQ：** 消息队列服务，支持高吞吐量和高可用。
4. **Seata：** 分布式事务解决方案。
5. **Dubbo：** 分布式RPC框架，提供高性能的服务调用。
### [Nacos在Spring Cloud中的作用是什么？它如何替代Eureka？](https://notes.kamacoder.com/questions/500656)
#### 简要回答

**Nacos在Spring Cloud中的作用：**
- Nacos是Spring Cloud Alibaba生态中的**服务发现与配置管理中心**。
- 它提供了**服务注册与发现、动态配置管理、命名服务**等功能，支持**动态更新配置，适应微服务架构的需求**。

**如何替代Eureka：**
- Nacos通过实现服务注册与发现功能，替代了Eureka的作用。
- 它支持与Spring Cloud整合，并通过`@EnableDiscoveryClient`注解启用服务注册与发现。
- Nacos还支持集群模式，提供更高的可用性和性能。
### [Sentinel是什么？它如何用于服务限流和熔断？](https://notes.kamacoder.com/questions/500657)
#### 简要回答

**Sentinel是什么：**
- Sentinel是阿里巴巴**开源的分布式系统流量控制组件**，专门用于微服务架构中的服务稳定性保护。
- 它提供了**流量控制、熔断降级、系统自适应保护**等功能。

**如何用于服务限流和熔断：**
- **限流：** 通过配置流量控制规则，如QPS、线程数等，Sentinel限制服务的最大并发量，避免系统过载。
- **熔断：** 当服务异常率超过设定的阈值时，Sentinel会启动熔断机制，自动切断请求流向，防止故障蔓延，保证系统稳定。
- **配置方式：** 通过注解（如`@SentinelResource`）或配置文件灵活配置限流和熔断策略。
### [如何使用Spring Cloud Alibaba Sentinel进行服务保护？](https://notes.kamacoder.com/questions/500658)
#### 简要回答
**使用Spring Cloud Alibaba Sentinel进行服务保护的步骤：**
1. **引入依赖：** 在`pom.xml`中添加Spring Cloud Alibaba Sentinel的相关依赖。
2. **配置Sentinel：** 在`application.properties`或`application.yml`中配置Sentinel相关属性，指定流控规则等。
3. **使用注解保护方法：** 使用`@SentinelResource`注解来保护服务接口，指定降级和流控策略。
4. **设置流控规则：** 可以通过Sentinel控制台或代码中动态配置流控规则，进行QPS限流、线程数限制等。
5. **启用Sentinel监控：** 启动Sentinel控制台，通过`localhost:8080`访问，实时监控流量控制、熔断降级等策略。
### [Spring Cloud Circuit Breaker除了Hystrix还有哪些选择？](https://notes.kamacoder.com/questions/500659)
#### 简要回答

**Spring Cloud Circuit Breaker的其他选择：**
1. **Resilience4j：**
	Resilience4j是一个轻量级的Java库，提供了断路器、限流、重试等功能，适合微服务架构。可以通过`spring-cloud-starter-circuitbreaker-resilience4j`来集成。
2. **Sentinel：**
	由阿里巴巴开发，Sentinel除了提供流控，还能实现断路器、限流、降级等功能，适用于高并发和复杂的微服务场景。
	可以通过`spring-cloud-starter-alibaba-sentinel`来集成。
### [Spring Cloud Gateway如何支持跨域请求？](https://notes.kamacoder.com/questions/500660)
#### 简要回答

**Spring Cloud Gateway支持跨域请求的方式：**
1. **全局CORS配置：** 可以通过`CorsConfiguration`类配置全局的跨域请求策略，如`allowedOrigins`、`allowedMethods`等。
2. **通过`application.yml`配置：** Spring Cloud Gateway支持在`application.yml`中直接配置CORS。
3. **通过Gateway的`GlobalFilter`定制CORS：** 可以创建自定义的`GlobalFilter`来处理跨域请求。
### [Spring Cloud Config Server如何支持加密/解密的配置属性？](https://notes.kamacoder.com/questions/500661)
#### 简要回答

**Spring Cloud Config Server支持加密/解密配置属性的方式：**
1. **加密和解密配置：** Spring Cloud Config支持在配置属性中加密敏感信息，如数据库密码。使用`{cipher}`前缀标识加密的属性。
2. **配置加密密钥：** Spring Cloud Config Server需要配置一个加密密钥来进行加密和解密操作。可以通过配置`bootstrap.yml`或`application.yml`中的`encrypt.key`来指定密钥。
3. **使用JCE（Java Cryptography Extension）加密：** 默认情况下，Config Server使用JCE进行对称加密。可以配置使用对称或非对称加密算法进行敏感数据的加密。
4. **客户端解密：** 配置文件中的加密值会被`{cipher}`解密并提供给客户端。客户端的解密操作与服务端配置一致。
### [如何使用Spring Cloud进行服务间的安全通信？](https://notes.kamacoder.com/questions/500662)
#### 简要回答

**使用Spring Cloud进行服务间的安全通信的方法：**
1. **OAuth 2.0认证：**
	- 使用Spring Security和Spring Cloud OAuth配置OAuth 2.0认证。
	- 配置`Authorization Server`颁发令牌，`Resource Server`验证令牌。
2. **JWT（JSON Web Token）：**
	- 在服务之间传递JWT令牌以验证身份。
	- 配置JWT解析器，校验服务间请求的有效性。
3. **TLS/SSL加密：**
	- 配置HTTPS支持，启用SSL证书，确保通信内容被加密。
	- 在`application.yml`中指定证书文件路径和密码
4. **共享密钥或API Key：**
	- 配置共享密钥或API Key验证服务间请求，通过自定义拦截器或过滤器进行验证。
5. **Spring Cloud Gateway集成：**
	- 在API网关上配置认证和授权策略，对下游服务的请求进行校验。

### [Spring Cloud LoadBalancer与Ribbon的区别是什么？](https://notes.kamacoder.com/questions/500663)
#### 简要回答

**Spring Cloud LoadBalancer与Ribbon的主要区别：**
1. **架构：**
	- **Ribbon**：基于Netflix的实现，已停止维护。
	- **Spring Cloud LoadBalancer**：Spring Cloud官方提供的替代方案，基于`Reactor`，更轻量且支持响应式编程。
2. **性能：**
	- **Ribbon**：同步调用，适用于阻塞式应用。
	- **Spring Cloud LoadBalancer**：支持同步和异步调用，更适合现代响应式微服务架构。
3. **扩展性：**
	- **Ribbon**：扩展能力有限，需要手动配置负载均衡策略。
	- **Spring Cloud LoadBalancer**：更容易与Spring生态系统集成，扩展配置更加灵活。
4. **默认支持：**
	- **Ribbon**：Spring Cloud Netflix组件默认集成。
	- **Spring Cloud LoadBalancer**：Spring Cloud的官方负载均衡解决方案，默认支持新版本的Spring Cloud。
### [Spring Cloud Task是什么？它适用于什么场景？](https://notes.kamacoder.com/questions/500664)
#### 简要回答

**Spring Cloud Task：**
- Spring Cloud Task是一个**轻量级框架**，专门用于简化**短生命周期任务**的创建和管理。
- 提供了对**一次性任务或批处理任务**的支持，适合快速开发并轻松集成到微服务架构中。

**适用场景：**
1. **短生命周期任务：**
	如临时的文件处理、数据库迁移或批量数据导入。
2. **批处理工作流启动：**
	在Spring Cloud Data Flow中作为批处理任务的触发器。
3. **事件驱动的异步任务：**
	需要在特定事件发生时执行的轻量任务。
4. **无状态任务：**
	不需要长时间运行且无需状态持久化的任务。
### [如何使用Spring Cloud Stream处理消息的重试和死信队列？](https://notes.kamacoder.com/questions/500665)
#### 简要回答

**消息重试：**
- Spring Cloud Stream支持消息处理失败后的自动重试，通过`spring.cloud.stream.bindings.<binding-name>.consumer`配置重试属性：
- `max-attempts`定义最大重试次数，`back-off`配置重试间隔。

**死信队列：**
- 消息在重试失败后会被发送到死信队列。
- **RabbitMQ**：配置`autoBindDlq`属性自动绑定死信队列
- **Kafka**：配置`dlq-name`属性指定死信主题

**总结：**
- 配置**重试机制**确保消息处理的**可靠性**。
- 使用**死信队列**记录无法处理的消息，以便后续分析或人工干预。
### [Spring Cloud Function是什么？它如何简化函数式编程？](https://notes.kamacoder.com/questions/500666)
#### 简要回答

**Spring Cloud Function：**
- 是一个支持** **的框架，用于无缝开发、部署和执行云原生函数。
- 通过统一编程模型，将业务逻辑以函数的形式实现，同时与不同的运行时环境（如AWS Lambda、Azure Functions）解耦。

**简化函数式编程的方式：**
1. **统一编程模型：** 提供`Supplier`、`Function`、`Consumer`接口，统一了函数开发方式。
2. **无运行时绑定：** 函数逻辑与底层运行环境解耦，可部署在任意云环境或本地。
3. **事件驱动支持：** 支持消息中间件（如Kafka、RabbitMQ）和REST的事件驱动调用。
4. **弹性扩展：** 提供轻量级的运行时，支持按需扩展。
### [Spring Cloud Contract是什么？它如何用于消费者驱动的契约测试？](https://notes.kamacoder.com/questions/500667)
**Spring Cloud Contract：**
- 是一个**契约测试工具**，用于确保服务提供者和消费者之间的**接口兼容**。
- 通过定义契约（contract）文件，验证服务端是否符合消费者的预期，避免集成时出现不一致。

**消费者驱动的契约测试：**
1. **契约定义：**- 在提供者端编写契约文件（Groovy或YAML），描述请求和响应的结构。
2. **自动生成测试：**- Spring Cloud Contract根据契约自动生成服务提供者的测试代码，验证接口的实现是否符合契约。
3. **Stub生成：**- 生成消费者测试用的Stub，模拟服务提供者行为，帮助消费者端独立测试。
4. **适配微服务架构：**- 避免服务端和客户端的集成不一致问题，提升系统稳定性和交付质量。
### [如何使用Spring Cloud Data Flow进行数据流管理？](https://notes.kamacoder.com/questions/500668)
**Spring Cloud Data Flow：**
- 是一个用于微服务数据流的编排工具，支持实时数据流处理和批量任务调度。

**使用步骤：**
1. **安装和启动：**
	- 下载Spring Cloud Data Flow Server和Shell。
	- 启动Data Flow Server和消息中间件（如RabbitMQ、Kafka）。
2. **定义数据流：** 使用DSL（数据流语言）定义数据流
3. **应用注册：** 注册应用组件（源、处理器、接收器）。
4. **任务管理：** 支持批量任务，通过定义和调度运行批处理应用。
5. **监控与可视化：** 提供Web UI和Shell工具，用于实时监控数据流的运行状态和性能。

### [Spring Cloud与Kubernetes的集成方式有哪些？](https://notes.kamacoder.com/questions/500669)
#### 简要回答

**Spring Cloud与Kubernetes的主要集成方式：**
1. **服务注册与发现：**
	- 使用Kubernetes的DNS和Service来代替Eureka等服务发现组件。
	- Spring Cloud Kubernetes提供了`spring-cloud-starter-kubernetes`来直接集成Kubernetes的服务发现。
2. **配置管理：**
	- 使用Kubernetes ConfigMap和Secrets管理配置文件。
	- Spring Cloud Kubernetes提供`@ConfigurationProperties`和`ConfigMapPropertySource`来加载Kubernetes中的配置。
3. **负载均衡：**
	- 利用Kubernetes的`ClusterIP`和`Ingress`控制器实现服务的负载均衡。
	- 替代Ribbon，直接使用Kubernetes的服务负载均衡功能。
4. **日志与监控：**
	- 与Kubernetes的`Fluentd`、`Prometheus`和`Grafana`集成，实现分布式日志和监控。
5. **部署与扩展：**
	- 通过Kubernetes的`Deployment`和`Horizontal Pod Autoscaler`实现应用的高可用性和自动扩展。

**总结：**
Spring Cloud Kubernetes将Spring Cloud的功能与Kubernetes原生能力结合，支持**服务治理、配置管理和弹性伸缩**，适用于**云原生微服务架构**。
### [在微服务架构中，如何使用Spring Cloud进行服务监控和告警？](https://notes.kamacoder.com/questions/500670)
#### 简要回答

**使用Spring Cloud进行服务监控和告警的方法：**
1. **Spring Boot Actuator：**
	- 提供健康检查、指标监控（如内存、线程池、HTTP流量等）。
	- 启用`/actuator`端点，通过HTTP或JMX获取实时监控数据。
2. **Spring Cloud Sleuth和Zipkin：**
	- 通过**分布式追踪**，记录微服务之间的请求链路。
	- 利用Zipkin UI查看调用链路、响应时间和性能瓶颈。
3. **Micrometer集成：**
	- 使用Micrometer将监控指标导出到外部系统，如Prometheus、InfluxDB等。
	- 配合Grafana进行指标的可视化展示。
4. **服务告警：**
	- 配置Prometheus的告警规则，监控指标异常（如高延迟、高CPU使用率）。
	- 配合Alertmanager发送邮件、短信或Webhook告警。
5. **API网关监控：**
	- 通过Spring Cloud Gateway的过滤器记录请求日志和性能数据，分析流量情况。

**总结：**
Spring Cloud通过Actuator、Sleuth、Micrometer等组件，结合第三方监控工具（如Prometheus、Grafana），实现了全面的服务监控与告警机制，确保微服务架构的稳定运行。
### [Spring Cloud的版本命名规则是什么？如何选择合适的版本？](https://notes.kamacoder.com/questions/500671)
#### 简要回答

**Spring Cloud版本命名规则：**
1. **基于字母序列：**- Spring Cloud版本以字母顺序命名（如`Hoxton`、`Greenwich`、`Ilford`），每个名称代表一个主要版本。
2. **关联Spring Boot版本：**- 每个Spring Cloud版本都与特定的Spring Boot版本绑定，需确保二者匹配。

**如何选择合适的版本：**
1. **匹配Spring Boot版本：**- 查看Spring Cloud的官方兼容性表，例如：- `Hoxton`适用于Spring Boot 2.2.x和2.3.x。
		- `Greenwich`适用于Spring Boot 2.1.x。
2. **查看稳定性：**- 优先选择标记为`Release`或`Stable`的版本，避免使用`Milestone`或`Snapshot`版本。
3. **考虑社区支持：**- 使用官方文档推荐的最新长期支持版本，确保后续更新和支持服务。
### [解释一下Spring Cloud的“服务雪崩”问题，并说明Hystrix如何帮助解决它。](https://notes.kamacoder.com/questions/500672)
#### 简要回答

**服务雪崩问题：**
- 在微服务架构中，**服务雪崩**指的是当一个服务调用失败时，可能引起连锁反应，使得多个依赖该服务的系统或服务也发生失败，从而导致整个系统的不可用。

**Hystrix如何帮助解决服务雪崩：**
1. **熔断机制：**- Hystrix通过**熔断器**（Circuit Breaker）模式，当检测到服务调用失败达到一定比例时，**自动中断**后续请求，避免大量无效的请求拖垮系统。
2. **隔离机制：**- Hystrix通过**线程池隔离**，将每个服务调用放在独立的线程池中，防止单个服务故障影响其他服务。
3. **回退机制：**- 一旦服务出现故障，Hystrix会调用**回退方法**（Fallback）提供备用逻辑，确保系统依然能响应用户请求。
### [在Spring Cloud中，如何配置服务的健康检查端点？](https://notes.kamacoder.com/questions/500673)
#### 简要回答

**Spring Cloud中配置服务的健康检查端点：**
1. **启用Actuator：**
	- 在`pom.xml`中添加Spring Boot Actuator依赖：
		```
		<dependency>  
		    <groupId>org.springframework.boot</groupId>  
		    <artifactId>spring-boot-starter-actuator</artifactId>  
		</dependency>
		```
2. **配置健康检查端点：**
	- 在`application.properties`或`application.yml`文件中配置健康检查端点暴露：
		```
		management.endpoints.web.exposure.include=health,info
		```
3. **自定义健康检查：**
	- 创建自定义健康检查类并使用`@Component`注解：
		```
		@Component  
		public class CustomHealthIndicator implements HealthIndicator {  
		    @Override  
		    public Health health() {  
		        // 定义健康检查逻辑  
		        return Health.up().withDetail("Custom", "Service is healthy").build();  
		    }  
		}
		```
4. **访问健康检查：**
	- 健康检查端点默认暴露在`/actuator/health`，可以通过访问该URL来检查服务状态。
### [Spring Cloud Gateway如何支持基于路径的路由？](https://notes.kamacoder.com/questions/500674)
#### 简要回答

**Spring Cloud Gateway如何支持基于路径的路由：**
1. **配置路由：**
	- 在`application.yml`文件中定义路由规则：
		```
		spring:
		  cloud:
		    gateway:
		      routes:
		        - id: path_route
		          uri: http://httpbin.org:80
		          predicates:
		            - Path=/get
		```
	- 该配置将请求路径为`/get`的请求转发到`http://httpbin.org:80/get`。
2. **使用`Path`谓词：**
	- `Path`谓词用于匹配URL路径，支持使用`*`通配符、正则表达式等，灵活配置路径路由。
3. **路径变量的使用：**
	- 可以使用路径变量来匹配动态路径，如：
		```
		spring:
		  cloud:
		    gateway:
		      routes:
		        - id: dynamic_path_route
		          uri: http://httpbin.org:80
		          predicates:
		            - Path=/user/{id}
		```
	- 该配置会将请求路径`/user/123`转发到`http://httpbin.org:80/user/123`。
4. **路径的正则匹配：**
	- 通过正则表达式对路径进行匹配：
		```
		spring:
		  cloud:
		    gateway:
		      routes:
		        - id: regex_path_route
		          uri: http://httpbin.org:80
		          predicates:
		            - Path=/api/**/details
		```
	- 上述配置将匹配所有路径为`/api/*/details`的请求。
### [如何使用Spring Cloud Config Server进行配置文件的版本控制？](https://notes.kamacoder.com/questions/500675)
#### 简要回答
**使用Spring Cloud Config Server进行配置文件的版本控制：**
1. **概述：**
	Spring Cloud Config Server支持集中化管理配置文件，可以通过Git、SVN等版本控制系统来管理配置文件。每次配置变更都可以通过版本控制追踪和回滚。
2. **配置Git仓库：**
	配置文件存放在Git仓库中，可以通过Git的分支和提交来控制版本：
	- 在`application.yml`中配置Config Server的Git仓库：
	```
	spring:
	  cloud:
	    config:
	      server:
	        git:
	          uri: https://github.com/my-config-repo
	          searchPaths: config
	          cloneOnStart: true
	```
3. **配置文件版本控制：**
	- 使用Git的分支来管理不同环境的配置（例如`dev`、`prod`）。
	- 配置文件路径可以通过URL来指定：
	```
	spring:
	  application:
	    name: my-service
	```- 该配置会自动查找`my-service.yml`或`my-service.properties`文件。
4. **动态配置更新：**
	- Spring Cloud Config支持热更新，在Config Server端更新配置后，客户端可以通过`@RefreshScope`注解来实现配置的动态刷新。
	- 客户端通过访问`/actuator/refresh`端点刷新配置。
5. **回滚配置：**
	- 通过Git的版本控制机制，可以随时回滚到之前的版本...
### [解释一下Spring Cloud的“服务发现”机制，并比较Eureka和Consul的不同。](https://notes.kamacoder.com/questions/500676)
#### 简要回答

**Spring Cloud的“服务发现”机制：**
1. **服务注册与发现：**
	- 服务发现机制允许服务注册到注册中心，其他服务可以通过注册中心查找到服务。
	- 主要组件是**注册中心**（如Eureka、Consul）和**客户端**（如Ribbon、Feign）配合使用。
2. **工作流程：**
	- 服务启动时，向注册中心注册自己的元数据（如IP、端口、服务名）。
	- 客户端从注册中心查询到服务信息，通过负载均衡进行调用。
3. **动态管理：**
	- 服务的健康检查可以实时监控，确保调用到健康的服务。
	- 服务失效或退出时，注册中心会更新服务列表。


----
#### Eureka与Consul的不同：

##### 1. **注册中心与管理方式：**

- **Eureka**：
	- 由Netflix开发，采用**中心化**的架构，服务通过心跳机制维持与Eureka服务器的连接。
	- 支持服务的自我保护机制，避免注册中心丢失健康实例。
- **Consul**：
	- 由HashiCorp开发，支持**去中心化**的架构，服务通过定期向Consul注册和心跳更新自己的健康状态。
	- 提供更多**分布式功能**，如支持K/V存储、跨数据中心的支持。

##### 2. **服务健康检查：**

- **Eureka**：
	- 通过服务心跳机制检测服务健康。如果心跳超时，服务会从注册中心移除。
- **Consul**：
	- 支持更丰富的健康检查机制，可以定义HTTP、TCP检查等方式，支持通过脚本或API进行健康状态检查。

##### 3. **API与集成：**

- **Eureka**：
	- 提供REST API用于服务的注册、发现和状态管理。
- **Consul**：
	- 提供更强大的API，支持**HTTP、DNS、RPC等多种协议**，且内建多种服务发现机制，适合更复杂的微服务架构。

##### 4. **性能与可扩展性：**

- **Eureka**：
	- 适用于轻量级、集中的微服务架构，支持高可用性，但相对易于集群化。
	- **缺点**：在高并发场景下，中心化可能成为瓶颈。
- **Consul**：
	- 适合分布式、高可用的系统。支持更高的水平扩展，可以更好地应对多数据中心环境。

##### 5. **使用场景：**

- **Eureka**：
	- 适合基于Spring Cloud的微服务架构，集成容易，适用于大多数Spring应用。
	- **典型场景**：Spring Cloud微服务、轻量级服务发现。
- **Consul**：
	- 适合需要跨数据中心、分布式微服务的场景，支持多个语言和框架。
	- **典型场景**：跨多个数据中心的微服务架构，或使用非Spring框架的应用。
### [在Spring Cloud中，如何实现服务的优雅下线？](https://notes.kamacoder.com/questions/500677)
#### 简要回答

**服务的优雅下线：**
1. **定义：**
	服务优雅下线指的是在服务关闭时，能确保现有请求得到处理，同时不接受新请求，确保服务平滑退出。
2. **实现方式：**
	- **Eureka和Spring Cloud的集成：**
		- **Eureka**：服务通过心跳机制注册到Eureka，服务下线时，Eureka会清除该服务的注册信息。
		- **@PreDestroy注解**：在服务关闭时执行清理工作，比如关闭连接、释放资源。
	- **Spring Cloud的优雅下线配置：**- 通过`application.yml`配置关闭Graceful Shutdown，设置超时时间。
		- 配置示例：
			```
			spring:
			  lifecycle:
			    timeout-per-shutdown-phase: 30s
			```
3. **Hystrix与服务的优雅下线：**
	- 使用**Hystrix**的**断路器模式**，确保下线时请求不会过载。
	- 在下线过程中将流量引导到其他健康的实例。
4. **优雅下线的过程：**
	- 停止接收新请求（通过标记服务不可用）。
	- 保持现有请求处理完毕后，再关闭服务。
### [Spring Cloud Stream如何保证消息的顺序性？](https://notes.kamacoder.com/questions/500678)
#### 简要回答

**保证消息顺序性：**
1. **消息中间件支持：**
	- **Kafka**：默认情况下，Kafka能保证单个分区内消息的顺序性。为确保顺序，消息应发送到同一分区。可以使用**消息的key**来保证发送到相同的分区。
	- **RabbitMQ**：RabbitMQ保证同一队列内消息的顺序性。但如果有多个消费者并行消费同一队列，顺序可能会被打乱。
2. **Spring Cloud Stream配置：**
	- **Kafka分区与分配：**
		使用`@StreamListener`监听消息时，可以通过设置分区策略确保同一类型的消息发送到同一分区，从而保证顺序。
		```
		@StreamListener("input")
		public void handleMessage(String message) {
		    // 处理消息
		}
		```
	- **绑定到单个分区：**
		可以通过配置`partitioned`来确保生产者和消费者绑定到特定的分区，保证顺序性。
		```
		spring:
		  cloud:
		    stream:
		      bindings:
		        input:
		          destination: my-topic
		          group: my-group
		          contentType: application/json
		          partitioned: true
		```
3. **消息顺序的挑战与处理：**
	- 需要特别注意如果消息发送到多个分区或多个消费者时，顺序性可能会丧失。通过合理的**消息分区策略**来保证顺序性。
### [如何使用Spring Cloud Bus实现配置更新的实时推送？](https://notes.kamacoder.com/questions/500679)
#### 简要回答

**实现配置更新的实时推送：**
1. **Spring Cloud Bus概述：**
	- Spring Cloud Bus用于通过消息总线将配置更改或事件传播到分布式系统中的所有服务实例。它通常与**Spring Cloud Config**结合使用，能够在配置更新时推送配置变更通知给所有相关微服务。
2. **集成Spring Cloud Bus：**
	- 通过将Spring Cloud Bus与**消息中间件（如RabbitMQ或Kafka）**结合使用，来实现微服务之间的事件传播。
	- **配置Spring Cloud Bus与消息中间件：**
		在`application.yml`中配置消息总线：
		```
		spring:
		  cloud:
		    stream:
		      bindings:
		        output:
		          destination: springCloudBus
		          contentType: application/json
		      kafka:
		        binder:
		          brokers: localhost:9092
		```
3. **配置实时推送：**
	- **Spring Cloud Config与Bus结合：**
		配置中心（Config Server）发布的配置变更，可以通过Spring Cloud Bus推送到所有客户端（Config Client）。通过以下步骤实现：
		1. 在`Config Server`端启用Bus。
		2. 客户端应用程序使用`@RefreshScope`注解刷新配置。
		```
		spring:
		  cloud:
		    config:
		      uri: http://config-server
		```- 通过`POST /actuator/refresh`端点触发配置刷新，Spring Cloud Bus会监听并通过消息总线广播配置变更，所有客户端会实时更新配置。
4. **推送事件和消息：**
	- 使用Spring Cloud Bus推送其他事件（如应用状态变更、服务重启等）。可以通过`@EventListener`监听事件，并使用`ApplicationEventPublisher`发布事件。
		```
		@EventListener
		public void handleRefreshEvent(RefreshEvent event) {
		    // 处理配置更新事件
		}
		```
5. **效果：**
	配置更新一旦发生，Spring Cloud Bus会将更新推送到所有订阅该消息的微服务实例，实现配置的**实时同步**更新。
### [解释一下Spring Cloud的“智能路由”功能，并说明其应用场景。](https://notes.kamacoder.com/questions/500680)
#### 简要回答

**智能路由功能：**
1. **概述：**
	- **智能路由**是Spring Cloud Gateway提供的一个重要功能。它能够根据请求的内容、请求的头信息、参数等进行动态的路由选择，从而确保请求被路由到适当的服务实例。这种能力提升了微服务架构中服务间的灵活性和可扩展性。
2. **应用场景：**
	- **动态路由：** 允许根据请求的URL、请求头、请求方法、请求参数等条件来路由到不同的微服务。例如，可以根据请求的版本号进行版本控制，或者基于用户身份选择不同的微服务实例。
	- **负载均衡：** 智能路由可以结合负载均衡策略（如轮询、加权等）将流量均匀地分配给多个服务实例，确保服务高可用。
	- **灰度发布：** 支持基于请求的特定条件（如请求来源IP、请求内容等）将部分流量引导到新版本的服务进行灰度发布，以减少发布风险。
### [在Spring Cloud中，如何配置服务的元数据？](https://notes.kamacoder.com/questions/500681)
#### 简要回答

**配置服务的元数据：**
1. **概述：**
	服务的元数据通常用于描述服务实例的额外信息，如服务实例的标签、版本、区域等。在Spring Cloud中，可以通过服务注册中心（如Eureka、Consul等）注册服务时，附带元数据，使得消费者能够根据元数据选择合适的服务。
2. **Eureka中配置服务元数据：**
	- 使用`Eureka`作为服务注册中心时，可以在`application.yml`配置中添加元数据：
	```
	eureka:
	  client:
	    service-url:
	      defaultZone: http://localhost:8761/eureka
	spring:
	  application:
	    name: my-service
	instance:
	  metadata-map:
	    version: 1.0.0
	    region: us-east-1
	```
	- 这里`metadata-map`用于添加自定义元数据，如`version`和`region`。
3. **Consul中配置服务元数据：**
	- 对于`Consul`，可以通过在`application.yml`中配置服务的`tags`或`meta`：
	```
	spring:
	  cloud:
	    consul:
	      host: localhost
	      port: 8500
	      discovery:
	        service-name: my-service
	        tags:
	          - version=1.0
	          - region=us-east
	        meta:
	          owner: teamA
	```
4. **消费者使用元数据：**
	- 消费者可以通过`Eureka`或`Consul`的API，查询服务实例的元数据，从而决定选择哪个服务实例。
	- 例如，可以通过`Eureka`的`DiscoveryClient`获取服务实例的元数据：
	```
	DiscoveryClient discoveryClient = applicationContext.getBean(DiscoveryClient.class);
	List<ServiceInstance> instances = discoveryClient.getInstances("my-service");
	for (ServiceInstance instance : instances) {
	    String version = instance.getMetadata().get("version");
	    // 根据版本号选择服务实例
	}
	```


----
#### 延伸问答

1. **如何利用服务元数据进行服务筛选？**
	- 在服务消费端，基于元数据过滤并选择合适的服务实例。例如，可以基于服务的版本或地区进行选择，保证流量路由到正确的服务版本或地理位置。
2. **如何动态更新服务的元数据？**
	- 服务的元数据可以在服务注册后动态更新，例如通过`Eureka`的`metadata-map`属性或`Consul`的`meta`字段更新元数据，帮助实现动态的服务发现和选择。
### [如何使用Spring Cloud Sleuth和Zipkin进行分布式追踪的可视化？](https://notes.kamacoder.com/questions/500682)
- **Spring Cloud Sleuth**：它是 Spring Cloud 中的一个组件，主要用于为分布式系统提供分布式追踪功能。它通过在每个微服务的请求中注入和提取追踪信息，来实现对整个分布式系统中请求链路的跟踪。
- **Zipkin**：是一个分布式追踪系统，它可以收集和存储由 Spring Cloud Sleuth 生成的追踪数据，并提供可视化界面来展示这些数据，帮助开发者更好地理解分布式系统中的请求流程和性能问题。

---

1. **添加依赖：** 在每个需要进行分布式追踪的微服务模块的 pom.xml 文件中，添加 Spring Cloud Sleuth 和 Zipkin 的依赖。
2. **配置应用属性：** 在每个微服务的配置文件（如 application.yml）中，配置 Zipkin 服务器的地址以及其他相关属性。
3. **启动 Zipkin 服务器：** 可以通过多种方式启动 Zipkin 服务器，如使用 Docker 容器启动。
4. **微服务链路追踪：**
	- 当微服务之间发生调用时，Spring Cloud Sleuth 会自动生成和传播追踪信息。每个请求都会有一个唯一的 Trace ID，用于标识整个请求链路，同时每个微服务内部的操作会有一个 Span ID，用于标识该操作在链路中的位置和时间。
	- 例如，在一个由订单服务、库存服务和支付服务组成的分布式系统中，当用户下单时，订单服务会调用库存服务检查库存，然后调用支付服务进行支付。Spring Cloud Sleuth 会在这个过程中为每个服务调用生成相应的 Trace ID 和 Span ID，并将这些信息传递给 Zipkin 服务器。
5. **查看可视化数据：**
	- 启动微服务应用后，访问 Zipkin 的 Web 界面（通常是 http://zipkin-server-url:9411）。
	- 在 Zipkin 界面中，可以通过输入查询条件，如 Trace ID、服务名称、时间范围等，来查找和展示特定的分布式请求链路。
	- 链路展示图会以图形化的方式显示每个微服务之间的调用关系、调用时间、请求状态等信息。通过分析这些信息，可以快速定位性能瓶颈、排查错误原因等。

##### 优化与注意事项
- **采样率调整**：根据系统的流量和性能需求，合理调整 Spring Cloud Sleuth 的采样率。如果采样率过高，可能会导致 Zipkin 服务器接收过多数据，影响性能；如果采样率过低，可能无法全面追踪到系统中的请求链路。
- **数据存储**：考虑 Zipkin 的数据存储方式和容量。默认情况下，Zipkin 将数据存储在内存中，对于生产环境，可能需要将数据存储到更可靠的数据库中，如 MySQL、Cassandra 等，以确保数据的持久性和可扩展性。
- **监控与告警**：结合其他监控工具，对 Zipkin 服务器和微服务进行监控，设置告警机制。当发现链路调用异常、响应时间过长等问题时，及时通知相关人员进行处理。
### [Spring Cloud Gateway如何支持基于请求头的路由？](https://notes.kamacoder.com/questions/500683)
#### 简要回答

**Spring Cloud Gateway支持基于请求头的路由：**
1. **概述：**
	Spring Cloud Gateway提供了灵活的路由匹配方式，支持通过请求头来实现动态路由。这允许开发者根据请求的Header信息，将请求路由到不同的服务。
2. **配置方式：**
	可以在`application.yml`或`application.properties`文件中配置路由规则，使用`requestHeader`进行条件判断，基于请求头的值来选择路由目标。
3. **示例配置：**
	在`application.yml`文件中，定义基于请求头的路由规则：
	```
	spring:
	  cloud:
	    gateway:
	      routes:
	        - id: header_route
	          uri: http://localhost:8081
	          predicates:
	            - Header=X-Custom-Header, customValue
	```这个配置会根据请求头`X-Custom-Header`的值是否为`customValue`，来路由到`http://localhost:8081`。
4. **多个头的匹配：**
	可以通过多个`Header`匹配规则来细化路由条件：
	```
	spring:
	  cloud:
	    gateway:
	      routes:
	        - id: header_route_multiple
	          uri: http://localhost:8082
	          predicates:
	            - Header=X-Custom-Header, customValue
	            - Header=Another-Header, anotherValue
	```
5. **动态请求头匹配：**
	支持通过表达式或动态计算请求头的值来进行更复杂的匹配。
### [如何使用Spring Cloud Alibaba Sentinel进行流量控制？](https://notes.kamacoder.com/questions/500684)
#### 简要回答

**使用Spring Cloud Alibaba Sentinel进行流量控制：**
1. **集成Sentinel：**
	在Spring Cloud应用中集成Sentinel，可以通过`spring-cloud-starter-alibaba-sentinel`依赖进行配置。通过`@EnableCircuitBreaker`注解启用断路器功能，结合Sentinel控制流量。
2. **配置流量控制规则：**
	在Sentinel中，可以通过配置流量控制规则来限制流量。规则可以基于QPS（每秒请求数）或线程池的大小进行控制。流量限制通过配置Sentinel规则管理来实现。
3. **使用注解进行流量控制：**
	可以使用`@SentinelResource`注解对服务方法进行流量控制。例如：
	```
	@SentinelResource(value = "myService", blockHandler = "handleBlock")
	public String myService() {
	    return "Service Response";
	}
	```
4. **流量控制规则示例：**
	通过配置文件或者控制台动态配置流量控制规则，如限制QPS为5：
	```
	spring:
	  cloud:
	    sentinel:
	      transport:
	        dashboard: localhost:8080  # Sentinel Dashboard地址
	```
5. **限流模式：**
	Sentinel支持多种流量控制模式，包括：
	- **QPS限流**：按每秒请求数限制流量。
	- **并发线程数限流**：限制请求的并发线程数。
6. **流量控制策略：**
	可以配置限流时的处理策略，例如：
	- **直接拒绝**：直接返回失败响应。
	- **Warm-up模式**：通过逐渐增加流量来避免突增。
7. **Sentinel控制台：**
	通过Sentinel的控制台，动态调整流量控制规则，实时查看流量情况。
### [在Spring Cloud中，如何实现服务的蓝绿部署？](https://notes.kamacoder.com/questions/500685)
#### 简要回答

**实现服务的蓝绿部署：**
1. **蓝绿部署概念：**
	蓝绿部署是一种减小系统更新风险的技术，通过同时运行两个版本的应用（蓝和绿），在切换流量时确保系统的高可用性。
2. **Spring Cloud和蓝绿部署：**
	在Spring Cloud中，可以通过以下方式实现蓝绿部署：
	- 使用**Spring Cloud Config**进行配置管理，确保不同版本的配置可以灵活切换。
	- 结合**Spring Cloud Gateway**或**Zuul API网关**实现流量的路由切换，按需将流量从“蓝”版本切换到“绿”版本。
3. **服务版本的隔离：**
	- 在容器化环境中，可以通过Kubernetes等容器编排工具为不同的版本创建不同的Pod，实现服务版本的独立部署。
	- 在Spring Cloud中，通过微服务版本控制和自动化部署工具实现蓝绿部署的自动化操作。
4. **流量切换：**
	- 使用API网关（如Spring Cloud Gateway或Zuul）来控制流量的路由。例如，可以通过**请求头**、**URI**等条件判断选择蓝或绿环境。
	- 可以在API网关配置中实现根据业务需求将一部分流量路由到“蓝”环境，另一部分流量路由到“绿”环境，从而确保切换过程不影响用户。
5. **常见工具和实践：**
	- 使用**Kubernetes**的滚动更新或版本标签来实现流量控制。
	- **Spring Cloud Config**和**Spring Cloud Bus**可以实时推送配置更新，确保两套环境之间的配置一致性。
	- 利用**Jenkins**或**GitLab CI**等CI/CD工具实现蓝绿部署的自动化。
6. **回滚机制：**
	- 如果新的版本出现问题，可以快速回滚到“蓝”环境，确保服务的稳定性。通过API网关控制流量切换，在发现问题时迅速回到上一个稳定版本。
### [如何使用Spring Cloud Config Server进行多环境配置管理？](https://notes.kamacoder.com/questions/500686)
#### 简要回答

**使用Spring Cloud Config Server进行多环境配置管理：**
1. **配置文件结构：**
	Spring Cloud Config Server可以通过为每个环境创建不同的配置文件来实现多环境配置管理。
	例如，使用不同的配置文件命名规则：`application-dev.yml`、`application-prod.yml`等。
2. **配置存储方式：**
	- 可以将配置文件存储在Git仓库、SVN、文件系统等地方，Config Server会从这些存储源加载配置。
	- 在Git中，可以使用分支来区分不同环境的配置文件，如`dev`、`prod`分支。
3. **配置加载：**
	- Spring Cloud Config客户端通过`spring.cloud.config.uri`配置指向Config Server的URL。
	- 在`bootstrap.yml`中指定应用的配置文件路径，`spring.profiles.active`来指明当前活跃的环境，如`dev`或`prod`。
4. **动态配置更新：**
	- 使用**Spring Cloud Bus**与Config Server结合，支持动态刷新配置。当配置发生变化时，可以通过消息总线推送更新。
	- 客户端通过`@RefreshScope`注解动态刷新Bean的配置。
5. **环境区分：**
	- 在Config Server端，使用`application-{profile}.properties`来加载不同环境下的配置，如`application-dev.properties`和`application-prod.properties`。通过Spring的`@Value`或`@ConfigurationProperties`来注入这些环境特定的配置。
6. **示例配置：**
	```
	spring:
	  cloud:
	    config:
	      uri: http://config-server:8888
	  profiles:
	    active: dev
	```
7. **优势：**
	- 通过Git或其他配置中心统一管理配置，减少环境间配置差异。
	- 支持不同环境的配置隔离和版本控制，确保配置的可维护性和一致性。
### [解释一下Spring Cloud的“服务降级”策略，并说明其重要性。](https://notes.kamacoder.com/questions/500687)
#### 简要回答

**服务降级策略：**
1. **定义：**
	服务降级是指在微服务架构中，当某个服务因故障无法提供正常响应时，系统不会直接抛出异常，而是返回一个预设的默认响应或简化的服务功能，确保系统的整体可用性。
2. **服务降级的触发：**
	- 当某个服务的调用超时、失败，或者响应结果异常时，系统触发降级。
	- 例如，当调用外部系统接口失败时，可以提供一个默认值或返回一个缓存的数据，而不是报错。
3. **实现方式：**
	- **Hystrix：** 提供了内置的服务降级机制，能够在服务调用失败时执行备用逻辑。
	- **Spring Cloud Circuit Breaker：** 结合Hystrix、Resilience4j等实现服务降级。
	- **Fallback方法：** 在调用失败时，使用`@HystrixCommand(fallbackMethod = "fallbackMethodName")`注解指定降级方法。
4. **重要性：**
	- **提高系统稳定性：** 即使某个服务不可用，系统仍能保持部分功能，避免全盘崩溃。
	- **用户体验：** 降级机制可以让用户体验更平滑，避免长时间等待错误响应或系统崩溃。
	- **保护后端系统：** 降级避免了后端服务的过载，特别是在高并发情况下，能够保护服务的稳定性。
### [在Spring Cloud中，如何实现服务的容错和回退？](https://notes.kamacoder.com/questions/500688)
#### 简要回答

**服务容错与回退：**
1. **服务容错：**
	服务容错指在系统的某个服务发生故障时，系统能通过预设的处理策略继续正常工作，不至于影响整体系统的可用性。Spring Cloud通过Hystrix、Resilience4j等组件实现容错。
2. **回退策略：**
	- **回退方法：** 当某个服务调用失败时，执行回退方法来提供备用逻辑或默认值，避免服务失败时直接抛出错误。
	- **Hystrix实现回退：**
		使用`@HystrixCommand(fallbackMethod = "fallbackMethodName")`指定回退方法。如果调用失败或超时，Hystrix会调用`fallbackMethodName`方法提供备用处理。
3. **实现方式：**
	- **Hystrix：** 在服务方法上使用`@HystrixCommand`注解，配置`fallbackMethod`，实现服务失败后的回退逻辑。
	- **Resilience4j：** 提供类似Hystrix的`@CircuitBreaker`注解，可以定义回退方法，通过`fallbackMethod`属性指定。
4. **重要性：**
	- **提高系统可靠性：** 通过容错和回退机制，系统能够在部分服务不可用时继续提供服务，避免崩溃。
	- **优化用户体验：** 当服务调用失败时，快速返回默认响应或预设值，提升用户体验，不让用户等待过久。
	- **减少系统压力：** 回退逻辑有助于在高并发情况下减轻系统负载，避免因某个服务故障引起全局影响。
### [如何使用Spring Cloud Gateway进行请求的限流和熔断？](https://notes.kamacoder.com/questions/500689)
#### 简要回答

**请求限流与熔断：**
1. **请求限流：**
	Spring Cloud Gateway支持通过`RequestRateLimiter`过滤器实现请求限流。该过滤器基于令牌桶或漏桶算法限制API的请求速率，从而防止服务因请求过多而过载。
	- 配置方式：在`application.yml`中配置限流规则，例如每秒允许的请求数。
	- 示例
		```
		spring:
		  cloud:
		    gateway:
		      routes:
		        - id: rate_limiter_route
		          uri: http://example.org
		          predicates:
		            - Path=/api/*
		          filters:
		            - name: RequestRateLimiter
		              args:
		                redis-rate-limiter.replenishRate=10
		                redis-rate-limiter.burstCapacity=20
		```
2. **熔断机制：**
	Spring Cloud Gateway集成了Hystrix或Resilience4j实现熔断功能。熔断机制用于服务调用失败时防止进一步的请求，保护下游服务并提供回退逻辑。
	- 配置方式：使用Hystrix或Resilience4j在`application.yml`中配置熔断条件。
	- 示例（使用Hystrix）
		```
		spring:
		  cloud:
		    gateway:
		      routes:
		        - id: hystrix_route
		          uri: http://example.org
		          filters:
		            - name: Hystrix
		              args:
		                name: fallbackCommand
		                fallbackUri: forward:/fallback
		```
3. **重要性：**
	- **请求限流：** 限制系统负载，保护后端服务不被过载，避免服务崩溃。
	- **熔断：** 防止错误快速传播，通过熔断机制避免整个系统的崩溃，并为系统提供回退方案，保持用户体验。
### [Spring Cloud Stream如何支持消息的分区？](https://notes.kamacoder.com/questions/500690)
#### 简要回答

**消息分区：**
1. **分区支持概述：**
	Spring Cloud Stream支持基于分区的消息传递。它通过**设置分区键来确保消息在不同的消费者实例之间按分区分配** ， 从而实现**负载均衡**和**消息的有序性**。
2. **分区配置：**
	配置分区时，需要在`application.yml`中设置相关参数，如`spring.cloud.stream.bindings.input.consumer.partitionKeyExpression`来指定消息的分区键。
	- 示例：
		```
		spring:
		  cloud:
		    stream:
		      bindings:
		        input:
		          destination: my-topic
		          consumer:
		            partitionKeyExpression: "headers['partitionKey']"
		```
3. **分区键：**
	Spring Cloud Stream会根据消息的分区键（如消息头中的`partitionKey`）将消息**路由到对应的分区**。通过这种方式，可以确保相同分区的消息始终由相同的消费者处理。
4. **支持的消息中间件：**
	Spring Cloud Stream支持**Kafka**和**RabbitMQ**等**消息中间件的分区机制**，特别是与Kafka的集成时，**Kafka的分区会直接映射到Spring Cloud Stream中的分区**。
5. **应用场景：**
	- 当处理大量并行消息时，分区机制可以帮助水平扩展消费者数量。
	- 保证同一类型的消息被定向到同一分区，以确保顺序性和一致性。
### [如何使用Spring Cloud Alibaba Nacos进行服务的动态配置管理？](https://notes.kamacoder.com/questions/500691)
#### 简要回答

**Nacos动态配置管理：**
1. **集成步骤：**
	- 在`pom.xml`中添加Nacos依赖：
		```
		<dependency>
		    <groupId>com.alibaba.cloud</groupId>
		    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
		</dependency>
		```
	- 在`application.yml`配置Nacos服务器地址：
		```
		spring:
		  cloud:
		    nacos:
		      config:
		        server-addr: localhost:8848
		        file-extension: properties
		        namespace: public
		```
2. **配置文件的管理：**
	- 在Nacos控制台中创建配置项，配置的内容可以通过`application.yml`或`bootstrap.yml`的方式加载。
		```
		spring:
		  application:
		    name: my-app
		  cloud:
		    nacos:
		      config:
		        data-id: application.properties
		```
3. **动态更新：**
	- 通过`@RefreshScope`注解使得配置的更新可以**动态刷新**，而不需要重启应用。
		```
		@RefreshScope
		@Component
		public class MyService {
		    @Value("${my.property}")
		    private String propertyValue;
		}
		```
	- 通过发送POST请求到`/actuator/refresh`端点，或者使用`@EnableConfigServer`来触发配置刷新。
4. **配置的热更新：**
	- 在Nacos中修改配置后，Spring Cloud会自动检测到配置变化并同步更新到应用。可以使用`@Value`或者`@ConfigurationProperties`注入配置值，且它们支持热更新。
5. **命名空间和分组：**
	- **Nacos**支持通过**命名空间和分组**来**管理不同环境和不同模块的配置**，实现**环境隔离和模块化配置管理**。
6. **应用场景：**
	- 动态调整服务配置，而不需要重启应用。
	- 配置的集中管理和版本控制，尤其在微服务架构中尤为重要。
### [在Spring Cloud中，如何实现服务的链路追踪和日志聚合？](https://notes.kamacoder.com/questions/500692)
#### 简要回答

**服务链路追踪：**
1. **集成Spring Cloud Sleuth与Zipkin：**
	- 添加依赖：```
		<dependency>
		    <groupId>org.springframework.cloud</groupId>
		    <artifactId>spring-cloud-starter-sleuth</artifactId>
		</dependency>
		<dependency>
		    <groupId>org.springframework.cloud</groupId>
		    <artifactId>spring-cloud-starter-zipkin</artifactId>
		</dependency>
		```
2. **配置Zipkin服务器：**
	- 在`application.yml`中配置Zipkin服务器地址：
		```
		spring:
		  zipkin:
		    baseUrl: http://localhost:9411
		  sleuth:
		    sampler:
		      probability: 1.0  # 设置采样概率为100%
		```
3. **追踪日志：**
	- Spring Cloud Sleuth自动在每个服务调用中添加`X-B3-TraceId`, `X-B3-SpanId`等信息，作为追踪信息。
	- 日志记录中会自动包含追踪信息，便于追踪整个请求的流转。

**日志聚合：**
1. **整合ELK（Elasticsearch, Logstash, Kibana）：**
	- 配置日志输出为JSON格式，方便Logstash收集
		```
		logging:
		  pattern:
		    console: '{"timestamp": "%d{yyyy-MM-dd HH:mm:ss}", "level": "%p", "message": "%m", "thread": "%t"}'
		```
2. **日志收集：**
	- 配置Logstash来收集日志，并将其存入Elasticsearch。
3. **查看日志：**
	- 使用Kibana来展示和查询日志数据，进行聚合分析。
4. **Spring Cloud与ELK集成：**
	- 可以结合Spring Boot应用和Logstash，使用日志聚合分析工具，进行更细致的服务监控。
### [如何使用Spring Cloud Gateway进行请求的日志记录？](https://notes.kamacoder.com/questions/500693)
#### 简要回答

1. **使用Spring Cloud Gateway的过滤器记录日志：**
	- Spring Cloud Gateway允许通过自定义过滤器来记录请求日志。可以创建一个`GatewayFilter`来处理日志记录。
2. **自定义过滤器实现：**
	- 创建一个日志记录过滤器，实现`GatewayFilter`接口。
		```
		@Component
		public class RequestLoggingFilter implements GatewayFilter {
		    private static final Logger logger = LoggerFactory.getLogger(RequestLoggingFilter.class);
		    @Override
		    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
		        HttpServletRequest request = exchange.getRequest();
		        logger.info("Request Method: {}, Request URI: {}", request.getMethod(), request.getRequestURI());
		        return chain.filter(exchange);
		    }
		}
		```
3. **配置过滤器：**
	- 将过滤器配置到路由中：
		```
		@Configuration
		public class GatewayConfig {
		    @Bean
		    public RouteLocator routeLocator(RouteLocatorBuilder builder) {
		        return builder.routes()
		                .route(r -> r.path("/api/**")
		                        .filters(f -> f.filter(new RequestLoggingFilter()))
		                        .uri("http://localhost:8080"))
		                .build();
		    }
		}
		```
4. **集成日志框架：**
	- 配置日志框架（如Logback）以输出日志，可以在`application.yml`中配置日志级别：
		```
		logging:
		  level:
		    org.springframework.web: DEBUG
		    org.springframework.cloud.gateway: DEBUG
		```


----

#### 详细回答

- **自定义日志过滤器：**
	Spring Cloud Gateway提供了`GatewayFilter`接口，可以在请求处理的过程中插入自定义的逻辑，如日志记录。在上面的示例中，我们在过滤器中获取`HttpServletRequest`对象，通过`request.getMethod()`和`request.getRequestURI()`获取请求的HTTP方法和URI，并将它们记录到日志中。
- **日志级别配置：**
	在Spring Cloud Gateway中，你可以使用`application.yml`来配置不同包的日志级别，以便对特定的请求和过滤器进行日志记录。例如，设置`org.springframework.cloud.gateway`包的日志级别为`DEBUG`，以便打印更多细节。
- **日志框架的使用：**
	使用`SLF4J`与`Logback`等日志框架，可以更加灵活地输出日志。通过自定义过滤器和日志配置，能够高效地对请求进行详细的记录。

----

#### 延伸问答

1. **如何实现全局日志记录？**
	- 除了为单个路由配置过滤器，还可以使用`GlobalFilter`来实现全局日志记录，`GlobalFilter`会在整个应用的所有请求上执行。
		```
		@Component
		public class GlobalRequestLoggingFilter implements GlobalFilter {
		    private static final Logger logger = LoggerFactory.getLogger(GlobalRequestLoggingFilter.class);
		    @Override
		    public Mono<Void> filter(ServerWebExchange exchange, GlobalFilterChain chain) {
		        HttpServletRequest request = exchange.getRequest();
		        logger.info("Global Request Method: {}, Request URI: {}", request.getMethod(), request.getRequestURI());
		        return chain.filter(exchange);
		    }
		}
		```
2. **如何通过日志追踪请求的生命周期？**
	- 可以使用**Spring Cloud Sleuth**来集成**日志追踪**，并将追踪ID与请求日志相关联。这样，所有微服务间的请求都会携带一个统一的追踪ID，有助于查看跨服务调用的日志。
# 前端开发
## Vue
### [MVVM模式和MVC模式有什么区别？](https://notes.kamacoder.com/questions/501891)
#### 简洁回答
##### 主要区别
|**特性**|**MVC**|**MVVM**|
|:-:|:-:|:-:|
|**核心组件**|Model, View, Controller|Model, View, ViewModel|
|**交互方式**|View 和 Model 直接交互，由 Controller 调节|View 和 Model 不直接交互，依赖 ViewModel|
|**数据绑定**|手动通知 View 更新|双向绑定自动更新|
|**适用场景**|后端 Web 框架（Spring MVC）|前端框架（Angular、Vue、React 等）|

----

#### 详细回答
##### MVC 模式
- **组成：**
	- **Model（模型）：** 处理业务逻辑和数据，负责状态管理。
	- **View（视图）：** 展示数据给用户，负责用户界面。
	- **Controller（控制器）：** 接收用户输入，协调 Model 和 View 的交互。
- **特点：**
	- 控制器集中处理输入，视图直接依赖于模型。
	- 更新数据需要手动通知视图刷新，数据和视图耦合较高。
	- 适合后端系统，如传统 Web 应用（Spring MVC）。
- **示例：**
	用户点击按钮后，Controller 接收请求，调用 Model 更新数据，并将新数据传递给 View。

##### MVVM 模式
- **组成：**
	- **Model（模型）：** 数据和业务逻辑层，与 MVC 模式相同。
	- **View（视图）：** 展示数据给用户，用户操作通过绑定传递给 ViewModel。
	- **ViewModel（视图模型）：** 中介层，负责数据与视图的双向绑定。
- **特点：**
	- View 和 Model 之间没有直接联系，依赖于 ViewModel 作为桥梁。
	- 通过双向绑定（Data Binding），数据和界面实时同步，降低开发复杂度。
	- 适合前端框架（如 Angular、React+Redux、Vue）。
- **示例：**
	用户修改界面内容，ViewModel 通过双向绑定自动更新 Model，反之亦然。

----

#### 延伸问答
- [x] **为什么 MVVM 更适合前端框架？**
	- 前端应用需要频繁更新视图状态，而 MVVM 的双向绑定特性可以自动同步数据与界面，减少开发者手动更新的负担。
# 代码随想录
## 数组
### [《代码随想录》数组：数组理论基础](https://notes.kamacoder.com/questions/501946)
#### 代码随想录算法训练营Day01 | 74.27.977.

1. 数组：下标从0开始、内存地址连续
2. Java 数组
- **逻辑上**：Java 数组是连续的，支持通过索引快速访问。
- **物理上**：Java 数组的内存分配不一定是连续的。
	- 数组本身是一个 **对象引用**。
	- JVM 会将数组对象分配在 **堆内存** 中，而堆内存是 **自动管理的、非连续的**。
	- JVM 的 **垃圾回收机制（GC）** 会不断移动和整理内存，这使得数组的实际物理内存位置可能发生变化。
### [《代码随想录》数组：二分查找](https://notes.kamacoder.com/questions/501947)
#### 代码随想录算法训练营Day01 | 74.27.977.

```java
// 代码随想录
// 二分查找
// 时间logn、空间1
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if (target < nums[0] || target > nums[n-1]) return -1;
        int left = 0, right = n -1;

        while (left <= right) {
            int mid = (left+right) >> 1;
            if (target < nums[mid]) {
                right = mid-1;
            } else if (target > nums[mid]) {
                left = mid+1;
            } else {
                return mid;
            }
        }

        return -1;
    }
}
```
### [《代码随想录》数组：移除元素](https://notes.kamacoder.com/questions/501948)
#### 代码随想录算法训练营Day01 | 74.27.977.

```java
// 代码随想录
// 快慢指针，fast快速找到不需要移除的元素，slow慢慢把元素排列紧密
// 时间On、空间O1
class Solution {
    public int removeElement(int[] nums, int val) {
        int n = nums.length;
        int slow = 0, fast = 0;

        while (fast < n) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }

        return slow;
    }
}
```

### [《代码随想录》数组：有序数组的平方](https://notes.kamacoder.com/questions/501949)
#### 代码随想录算法训练营Day01 | 74.27.977.

```java
// 代码随想录
// 双指针
// 时间On、空间On
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int left = 0, right = n-1, idx = n-1;
        int[] res = new int[n];

        while (idx >= 0) {
            int l2 = nums[left]*nums[left];
            int r2 = nums[right]*nums[right];
            if (l2 > r2) {
                res[idx--] = l2;
                left++;
            } else {
                res[idx--] = r2;
                right--;
            }
        }

        return res;
    }
}
```
### [《代码随想录》数组：长度最小的子数组](https://notes.kamacoder.com/questions/501950)
#### 代码随想录算法训练营Day02 | 209.59.@58.@44.

```java
// 代码随想录
// 数组、滑动窗口
// 时间On、空间O1
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int res = Integer.MAX_VALUE;
        int sum = 0;
        int left = 0;
        for (int right = 0; right < n; right++) {
            sum += nums[right];
            while (sum >= target) {
                res = Math.min(res, right-left+1);
                sum -= nums[left];
                left++;
            }
        }
        return res==Integer.MAX_VALUE ? 0 : res;
    }
}
```

### [《代码随想录》数组：螺旋矩阵II](https://notes.kamacoder.com/questions/501951)
#### 代码随想录算法训练营Day02 | 209.59.@58.@44.

```java
// 代码随想录
// 数组、模拟
// 时间On2、空间On2
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int loop = n / 2;
        int u=0, d=n-1, l=0, r=n-1;
        int num = 1;

        while (loop != 0) {
            for (int j = l; j < r; j++)   res[u][j] = num++;
            for (int i = u; i < d; i++)   res[i][r] = num++;
            for (int j = r; j > l; j--)   res[d][j] = num++;
            for (int i = d; i > u; i--)   res[i][l] = num++;
            u++;
            d--;
            l++;
            r--;
            loop--;
        }

        if (n%2 == 1) {
            res[n/2][n/2] = num;
        }

        return res;
    }
}
```
### [《代码随想录》数组：区间和](https://notes.kamacoder.com/questions/501952)
#### 代码随想录算法训练营Day02 | 209.59.@58.@44.

1. `import java.util.*;`
2. `public static void main(String args[])`记得`String args[]`
3. 输入输出处理
	```java
	Scanner scanner = new Scanner(System.in);
	int n = scanner.nextInt();
	while (scanner.hasNextInt()) {}
	```

---

```java
// 代码随想录
// 前缀和
// 时间On+k、空间On
import java.util.*;

class Main {
    public static void main(String args[]) {
        // IO处理
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] array = new int[n];
        for (int i = 0; i < n ; i++){
            array[i] = scanner.nextInt();
        }
        
        // 前缀和 [1,2,3,4,5] 的前缀和为 [0,1,3,6,10,15]
        int[] prefixSum = new int[n + 1];
        prefixSum[0] = 0;
        for(int i = 1; i < n+1; i++){
            prefixSum[i]  = prefixSum[i-1] + array[i - 1];
        }

        while (scanner.hasNextInt()) {
            int left = scanner.nextInt();
            int right = scanner.nextInt();
            int res = prefixSum[right+1] - prefixSum[left];
            System.out.println(res);
        }
        // return;
    }
}
```
### [《代码随想录》数组：开发商购买土地](https://notes.kamacoder.com/questions/501953)
#### 代码随想录算法训练营Day02 | 209.59.@44.

```java
// 卡码刷题
// 前缀和、模拟
// 时间Omn、空间Omn
import java.util.Scanner;

public class Main {
    public static void main (String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = 0, n = 0;
        m = scanner.nextInt();
        n = scanner.nextInt();
        
        int[][] land = new int[m][n];
        int[] rowSumPrefix = new int[m];  // 行前缀和
        int[] colSumPrefix = new int[n];  // 列前缀和
        
        // 读取land数组
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                land[i][j] = scanner.nextInt();
            }
        }
        
        // 行前缀和
        int rowSum = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                rowSum += land[i][j];
            }
            rowSumPrefix[i] = rowSum;
        }
        
        // 列前缀和
        int colSum = 0;
        for (int j = 0; j < n; j++) {
            for (int i = 0; i < m; i++) {
                colSum += land[i][j];
            }
            colSumPrefix[j] = colSum;
        }
        
        System.out.println(Math.min(Main.help(rowSumPrefix), Main.help(colSumPrefix)));
    }
    
    public static int help(int[] array) {
        int res = Integer.MAX_VALUE;
        int n = array.length;
        int total = array[n-1];
        for (int i = 0; i < n-1; i++) { // 因为至少要有1
            res = Math.min(res, Math.abs(total-array[i] - array[i]));
        }
        return res;
    } 
}
```
### [《代码随想录》数组：数组总结篇](https://notes.kamacoder.com/questions/501954)
#### 代码随想录算法训练营Day02 | 209.59.@58.@44.

二分法、双指针、循环不变量、滑动窗口、前缀和
## 链表
### [《代码随想录》链表：链表理论基础](https://notes.kamacoder.com/questions/501955)
#### 代码随想录算法训练营Day03 | 203.707.206.

#### 链表类型
1. 双向链表
2. 循环链表：解决**约瑟夫环问题**
##### 约瑟夫环问题
- **约瑟夫环（Josephus Problem）** 描述了一群人**按特定规则被依次淘汰**的过程。
- 📖 **问题描述：** 有 **n** 个人（编号为 1 到 n）围成一个圆圈，从第 1 个人开始依次报数。每报到第 **k** 个人时，这个人会被淘汰，接着从下一个人继续报数，直到圈里只剩下一个人为止。问**最后剩下的人的编号**是多少？
- 🧩 **解题思路：** 通过**递归公式**和**循环链表**来解决。
	- ✅ **递归公式解法**：通过递归地计算每一轮淘汰的位置，缩小问题规模，定位幸存者。
	- ✅ **循环链表解法**：模拟报数和淘汰过程，使用列表（循环链表）动态移除被淘汰的人，直到剩下最后一个人。
- 🔎 **应用场景**
	- 操作系统中的**任务调度**
	- **密码学**中的密钥交换
	- **游戏开发**中的淘汰机制

#### 链表的存储方式
- **数组**是在内存中是**连续分布**的
- **链表**在内存中**不是**连续分布的。

#### 性能分析
- **数组**适合**查询**
- **链表**适合**插删**

![image.png](http://cdn.kamacoder.com/67807cb6b8016-phpie2TMK.png)

#### 链表的定义
![image.png](http://cdn.kamacoder.com/676b5f9d4ad20-phpEwHIL0.png)
### [《代码随想录》链表：移除链表元素](https://notes.kamacoder.com/questions/501956)
#### 代码随想录算法训练营Day03 | 203.707.206.
- **虚拟头结点`dummy_head`：** 使得第一个实际节点与后续节点一样，都有前置节点。
- 遍历方式：`while (cur != null)`

```
// 代码随想录
// 链表
// 时间On、空间O1
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null)   return null;
        ListNode dummy = new ListNode(-1, head);
        ListNode pre = dummy;
        ListNode cur = dummy.next;

        while (cur != null) {
            if (cur.val == val)
                pre.next = cur.next;
            else
                pre = cur;
            
            cur = cur.next;
        }

        return dummy.next;
    }
}
```
### [《代码随想录》链表：设计链表](https://notes.kamacoder.com/questions/501957)
#### 代码随想录算法训练营Day03 | 203.707.206.

1. index从0开始，**有index就判断是否越界**：`if (index<0 || index>=size)`
2. 注意遍历的区别
	- `get(int index)`的遍历：for (int i = 0; i **<=** index; i++)，这将使得`cur`指到`index`，从而直接`return cur.val`
	- `addAtIndex(int index, int val)`和`deleteAtIndex(int index)`的遍历：for (int i = 0; i **<** index; i++)，这将使得 `cur.next`指到`index`，从而通过`next`对`index`插入、删除。

```java
class MyLinkedList {

    class ListNode {
        int val;
        ListNode next;
        ListNode(){};
        ListNode(int val) {
            this.val = val;
        }
        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    private int size;
    private ListNode head;

    public MyLinkedList() {
        this.size = 0;
        this.head = new ListNode(0);
    }
    
    // cur指到index
    public int get(int index) { // index从0开始
        if (index<0 || index>=size) {
            return -1;
        }
        ListNode cur = head;

        // dummy->1->2->3->4
        // index：0  1  2  3
        for (int i = 0; i <= index; i++) {
            cur = cur.next;
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        ListNode node = new ListNode(val);
        node.next = head.next;
        head.next = node;
        size++;
    }
    
    public void addAtTail(int val) {
        ListNode node = new ListNode(val);
        ListNode cur = head;
        while (cur.next != null) {
            cur = cur.next;
        }
        cur.next = node;
        node.next = null;
        size++;
    }
    
    // cur.next指到index
    public void addAtIndex(int index, int val) {
        if (index<0 || index>=size) {
            return;
        }
        ListNode node = new ListNode(val);
        ListNode cur = head;

        // dummy->1->2->3->4
        // index：0  1  2  3
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        node.next = cur.next;
        cur.next = node;
        size++;
    }
    
    // cur.next指到index
    public void deleteAtIndex(int index) {
        if (index<0 || index>=size) {
            return;
        }
        ListNode cur = head;

        // dummy->1->2->3->4
        // index：0  1  2  3
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        cur.next = cur.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### [《代码随想录》链表：翻转链表](https://notes.kamacoder.com/questions/501958)
#### 代码随想录算法训练营Day03 | 203.707.206.
1. `pre`表示已经反转部分的队首，`cur`表示需要处理部分的队首
2. 遍历方式：`while (cur != null)`
3. 核心步骤：`cur.next = pre;`核心其实只有这一步：修改cur的指针，指向后->指向前
4. 其他细节
	- ` ListNode tmp = cur.next;`暂存用于后续更新cur，否则会丢失
	- `return pre;`结束后`pre`表示已经反转部分的队首
	- 没有用到`dummy_head`

```java
// 代码随想录
// 链表
// 时间On、空间O1
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;    // 已经反转部分的队首
        ListNode cur = head;    // 需要处理部分的队首
        
        while (cur != null) {
            ListNode tmp = cur.next;    // 暂存用于更新cur，否则会丢失
            cur.next = pre; // *核心其实只有这一步：修改cur的指针，指向后->指向前
            pre = cur;  // 更新pre：现在cur成了“已经反转部分的队首”
            cur = tmp;  // 更新cur
        }
        
        return pre;
    }
}
```
### [《代码随想录》链表：两两交换链表中的节点](https://notes.kamacoder.com/questions/501959)
#### 代码随想录算法训练营Day04 | 24.19.面试题0207.142.

```java
// 代码随想录
// 链表
// 时间On、空间O1
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0, head);
        ListNode cur = dummy;
        while (cur.next != null && cur.next.next != null) {
            ListNode node1 = cur.next;// 第 1 个节点
            ListNode node2 = cur.next.next;// 第 2 个节点
            cur.next = node2; // 步骤 1
            node1.next = node2.next;// 步骤 3
            node2.next = node1;// 步骤 2
            cur = cur.next.next;
        }
        return dummy.next;
    }
}
```
### [《代码随想录》链表：删除链表的倒数第N个节点](https://notes.kamacoder.com/questions/501960)
#### 代码随想录算法训练营Day04 | 24.19.面试题0207.142.

根据题目描述，不会空链表。
需要给自己盘一下**只有一个节点**特殊情况：
1. while中fast从dummy移动1到head
2. while出来再次移动到null
3. slow原本是dummy，指向head，现在改为指向null
4. 成功删除唯一的节点，没问题。

---

```java
// 代码随想录
// 链表
// 时间On、空间O1
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1, head);
        ListNode slow = dummy, fast = dummy;

        while(n != 0) {
            fast = fast.next;
            n--;
        }
        fast = fast.next;   // 为了获取要删除节点的前一个节点
        while(fast != null) {
            slow = slow.next;
            fast = fast.next;
        }

        slow.next = slow.next.next;

        return dummy.next;
    }
}
```
### [《代码随想录》链表：链表相交](https://notes.kamacoder.com/questions/501961)
#### 代码随想录算法训练营Day04 | 24.19.面试题0207.142.

```java
// 代码随想录
// 链表
// 时间On+m、空间O1
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pA = headA;
        ListNode pB = headB;

        while (pA != pB) {
            pA = pA==null ? headB : pA.next;
            pB = pB==null ? headA : pB.next;
        }

        return pA;
    }
}
```

---

错误写法：`pA = pA.next==null ? headB : pA.next;`
错误原因：忽略了不相交的情况
错误示例：
![image.png](http://cdn.kamacoder.com/6781d6803e9cd-phpkBvuXj.png)

### [《代码随想录》链表：环形链表II](https://notes.kamacoder.com/questions/501962)
#### 代码随想录算法训练营Day04 | 24.19.面试题0207.142.

**思路：**
- 从head结点走到入环点需要走 ： a + nb， 而因为f=2s，f=s+nb，即slow已经走了nb，那么slow再走a步就是入环点了。 
- if(fast == null || fast.next == null)可以避免空链表。

---

```java
// 代码随想录、Hot100
// 环形链表
// 时间On、空间O1
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null)   return null;
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) { // 有环
                ListNode index1 = fast;
                ListNode index2 = head;
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }

        return null;
    }
}
```
### [《代码随想录》链表：链表总结篇](https://notes.kamacoder.com/questions/501963)
#### 代码随想录算法训练营Day03 | 203.707.206.

1.链表题目常用解决措施：双指针、虚拟头结点（涉及链表的增删改操作时）。
2. 特殊情况的处理（链表为NULL，链表只有一个节点）

## 哈希表
### [《代码随想录》哈希表：哈希表理论基础](https://notes.kamacoder.com/questions/501964)
#### 代码随想录算法训练营Day06 | 242.349.202.1.


##### 基本概念
- 哈希表基于哈希函数通过 **键值对（key-value）** 存储数据。
- 哈希函数将任意大小的数据**映射**为固定大小的整数，通过哈希值可以快速**定位**存储位置。
- **目标**：提供快速的**增、删、查**操作，平均时间复杂度为 O(1)
- 负载因子 = 元素个数 / 数组长度
	- 负载因子越高，冲突越多，性能越差。
	- 合适的负载因子（如 α ≤ 0.75）能在性能和空间之间取得平衡。
	- 动态扩容：负载因子超过一定阈值，哈希表会扩容并重新分配已有元素到新的位置（ rehashing）。

---

##### 哈希冲突
哈希冲突：由于数组的大小有限，**不同的键**可能映射到**同一索引值**。
解决方法：
###### 1. 链地址法：链表存储
**缺点**：
	- 额外指针增加了空间消耗。
	- 链表长度过长时，查找性能可能退化为 O(n)。

###### 2. 开放寻址法：查找下一个可用位置
1. **线性探测**：按固定步长（通常为 1）依次查找。
2. **二次探测**：步长为二次方，避免聚集效应。
3. **双重哈希**：用第二个哈希函数决定步长。
- **缺点**：插入和查找效率在负载因子较高时下降。

######  3. 再哈希法：冲突时重新计算哈希值，直到找到空位。

######  4. 扩展数组：动态增加数组大小，重新分配元素（常见于 `HashMap` 等实现）

---

##### 哈希表的优缺点
- **空间换时间**：增删查的平均时间复杂度为 O(1)。
- **无法顺序存储**：哈希表中的元素通常是无序的。

---

##### 红黑树

##### 二叉搜索树（BST）
- 可以O（logn）的效率进行增删查
- 但当数据有序时，二叉搜索树的构建会变成链表状态且效率退化为O（n）

###### 二叉搜索树之 平衡二叉树（AVL）
- 通过旋转操作让树保持平衡
- 任一结点左右子树高度相差不超过1。（相比红黑树，对平衡的要求更加严格）
- 相比红黑树**查询更高效**。

###### 二叉搜索树之 红黑树
- 左根右，根叶黑，不红红，黑路同。
- 任一结点左右子树高度相差不超过两倍。
- 相比平衡二叉树**增删更高效**。
- 应用更广泛，如C++的STL的map和set。

### [《代码随想录》哈希表：有效的字母异位词](https://notes.kamacoder.com/questions/501965)
#### 代码随想录算法训练营Day06 | 242.349.202.1.

```java
// 代码随想录
// 哈希表
// 时间Om+n、空间O1
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] record = new int[26];

        for (int i = 0; i < s.length(); i++) {
            record[s.charAt(i) - 'a']++;
        }

        for (int i = 0; i < t.length(); i++) {
            record[t.charAt(i) - 'a']--;
        }

        for (int r : record)
            if (r != 0)
                return false;
        
        return true;
    }
}
```
### [《代码随想录》哈希表：查找常用字符](https://notes.kamacoder.com/questions/501966)
#### 代码随想录算法训练营Day05 | 242.349.202.1.

```java

```
### [《代码随想录》哈希表：两个数组的交集](https://notes.kamacoder.com/questions/501967)
#### 代码随想录算法训练营Day06 | 242.349.202.1.

```java
// 代码随想录
// 哈希表
// 时间On+m+k、空间On+k
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0)
            return new int[0];
        
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> res = new HashSet<>();

        for (int i : nums1) {
            set1.add(i);
        }
        for (int i : nums2) {
            if (set1.contains(i)) {
                res.add(i);
            }
        }

        return res.stream().mapToInt(Integer::intValue).toArray();
        // stream() 是 List 接口提供的方法，用于将集合 res 转换成一个 Stream<Integer>
        // mapToInt() 是 Stream 的一个中间操作，用于将 Stream<Integer> 转换成 IntStream
        // Integer::intValue 是一个 方法引用，表示调用每个 Integer 对象的 intValue() 方法，将其转换为基本类型 int
        // toArray() 是 IntStream 的一个终端操作，用于将流中的元素收集到一个 int[] 数组 中
    }
}
```
### [《代码随想录》哈希表：快乐数](https://notes.kamacoder.com/questions/501968)
#### 代码随想录算法训练营Day06 | 242.349.202.1.

```java
// 代码随想录
// 哈希表
// 时间Ologn、空间O1
// 任意一个数字 n 的平方和最终会收敛到一个小的循环（如 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4）。
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);
        }
        return n == 1;
    }

    private int getNextNumber(int n) {
        int res = 0;
        while (n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n /= 10;
        }
        return res;
    }
}
```
### [《代码随想录》哈希表：两数之和](https://notes.kamacoder.com/questions/501969)
#### 代码随想录算法训练营Day06 | 242.349.202.1.

##### ❓return new int[0];和return null;的区别？
|**返回方式**|**含义**|**内存分配**|**访问方式**|
|:-:|:-:|:-:|:-:|
|`return new int[0];`|返回一个**空数组对象**，数组长度为 0|分配了内存空间|可以安全地调用数组方法|
|`return null;`|返回一个**空引用**，没有数组对象|没有分配内存空间|调用数组方法会抛异常|

---

##### ❓为什么推荐 `return new int[0];`？
- 更安全：避免 `NullPointerException`。
- 更简洁：调用时不需要 `null` 检查。


---

##### ❓`return new int[0];` 分配了多少内存？

###### 🔢为什么空数组仍然占内存？
Java 的数组是一个**对象**，即使长度为 0，仍然需要：
1. 存储数组的元数据（对象头部）。
2. 确保数组对象在 JVM 中有唯一的内存地址。

###### 🔢示例：`new int[0]` 内存对比
|数组长度|内存占用（64位JVM）|
|:-:|:-:|
|`new int[0]`|16 字节|
|`new int[1]`|20 字节|
|`new int[10]`|56 字节|

###### 🔢计算方法
64 位 JVM 下：
- **数组头部** = 16 字节
- **每个 `int` 元素** = 4 字节
- 总大小 = `16 + 4 × 数组长度`

---

```java
// 代码随想录
// 哈希表
// 时间On、空间On
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        HashMap<Integer, Integer> mp = new HashMap<>();
        for (int i = 0; i < n; i++) {
            if (mp.containsKey(target-nums[i])) {
                return new int[]{i, mp.get(target-nums[i])};
            }
            mp.put(nums[i], i);
        }
        return new int[0];  
        // 返回一个空数组对象，数组长度为 0，分配了内存空间，可以安全地调用数组方法，不想返回实际数据，但希望避免异常
        // 为什么推荐 return new int[0];？更安全：避免 NullPointerException。更简洁：调用时不需要 null 检查。
        
        // return null;    
        // // 返回一个空引用，没有数组对象，没有分配内存空间，调用数组方法会抛异常，表示数据不存在
    }
}
}
```
### [《代码随想录》哈希表：四数相加II](https://notes.kamacoder.com/questions/501970)
#### 代码随想录算法训练营Day07 | 454.383.15.18

```java
// 代码随想录
// 哈希表
// 时间On^2、空间On^2
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int res = 0;
        HashMap<Integer, Integer> mp = new HashMap<>();

        for (int num1 : nums1) {
            for (int num2 : nums2) {
                mp.put(num1+num2, mp.getOrDefault(num1+num2, 0)+1);
            }
        }
        for (int num3 : nums3) {
            for (int num4 : nums4) {
                    res += mp.getOrDefault(0-num3-num4, 0);
            }
        }
        
        return res;
    }
}
```
### [《代码随想录》哈希表：赎金信](https://notes.kamacoder.com/questions/501971)
#### 代码随想录算法训练营Day07 | 454.383.15.18

```java
// 代码随想录
// 哈希表（数组）
// 时间Om+n：其中m为ransomNote的长度，n为magazine的长度
// 空间O1
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] hash = new int[26];

        for (char mm : magazine.toCharArray()) {
            hash[mm-'a']++;
        } 

        for (char rr : ransomNote.toCharArray()) {
            hash[rr-'a']--;
            if (hash[rr-'a'] < 0) {
                return false;
            }
        }

        return true;
    }
}
```
### [《代码随想录》哈希表：三数之和](https://notes.kamacoder.com/questions/501972)
#### 代码随想录算法训练营Day07 | 454.383.15.18

```java
// Hot100、代码随想录
// 双指针、去重
// 时间On^2、空间On^2
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums==null || nums.length==0)  return res; 
        int n = nums.length;
        Arrays.sort(nums);

        for (int i = 0; i < n-2; i++) {
            if (nums[i] > 0)    return res;
            if (i>0 && nums[i]==nums[i-1])  continue;
            int left = i+1;
            int right = n-1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    while (left < right && nums[left] == nums[left+1])  left++;
                    left++;
                    while (left < right && nums[right] == nums[right-1])  right--;
                    right--;
                }
            }
        }

        return res;
    }
}
```
### [《代码随想录》哈希表：四数之和](https://notes.kamacoder.com/questions/501973)
#### 代码随想录算法训练营Day07 | 454.383.15.18

```java
// 代码随想录
// 双指针
// 时间On^3
// 空间O1（res空间On^2）
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        if (nums==null || nums.length==0)   return res;
        int n = nums.length;
        Arrays.sort(nums);

        for (int i = 0 ; i < n; i++) {
            if (nums[i]>target && nums[i]>=0)    break;
            if (i>0 && nums[i]==nums[i-1])  continue;
            for (int j = i + 1; j < n; j++) {   // 注意是j = i+1
                // 第二级剪枝
                if (nums[i]+nums[j]>target && nums[i]+nums[j]>=0)    break; // 注意是break不是return res，否则会有遗漏
                if (j>i+1 && nums[j]==nums[j-1])  continue;

                int left = j + 1;
                int right = n - 1;
                while (left < right) {
                    long sum = (long) nums[i]+nums[j]+nums[left]+nums[right];
                    if (sum < target) {
                        left++;
                    } else if (sum > target) {
                        right--;
                    } else {
                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));

                        while (left<right && nums[left]==nums[left+1])  left++;
                        left++;
                        while (left<right && nums[right]==nums[right-1])  right--;
                        right--;
                    }
                }
            }
        }


        return res;
    }
}
```
### [《代码随想录》哈希表：哈希表总结](https://notes.kamacoder.com/questions/501974)
#### 代码随想录算法训练营Day07 | 454.383.15.18

1. 数组作为哈希表：范围有限如字母表
2. set作为哈希表：范围不定
3. map作为哈希表：需要记录key和value两个信息
## 字符串
### [《代码随想录》字符串：反转字符串](https://notes.kamacoder.com/questions/501975)
#### 代码随想录算法训练营Day08 | 344.541.@54.

```java
// 代码随想录
// 位运算
// 时间On
// 空间O1
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length-1;
        while (left < right) {
            s[left] ^= s[right];  //构造 a ^ b 的结果，并放在 a 中
            s[right] ^= s[left];  //将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b
            s[left] ^= s[right];  //a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换
            left++;
            right--;
        }
        return;
    }
}
```
### [《代码随想录》字符串：反转字符串II](https://notes.kamacoder.com/questions/501976)
#### 代码随想录算法训练营Day08 | 344.541.@54.

```java
// 代码随想录
// 每隔2k个反转前k个，尾数不够k个时候全部反转
// 时间On、空间On
class Solution {
    public String reverseStr(String s, int k) {
        char[] ch = s.toCharArray();
        for(int i = 0; i < ch.length; i += 2 * k){
            int start = i;
            //这里是判断尾数够不够k个来取决end指针的位置
            int end = Math.min(ch.length - 1, start + k - 1);   // 关键
            //用异或运算反转 
            while(start < end){
                ch[start] ^= ch[end];
                ch[end] ^= ch[start];
                ch[start] ^= ch[end];
                start++;
                end--;
            }
        }
        return new String(ch);
    }
}
```
### [《代码随想录》字符串：替换数字](https://notes.kamacoder.com/questions/501977)
#### 代码随想录算法训练营Day08 | 344.541.@54.

```java
// 代码随想录
// 字符串
// 时间On
// 空间On
import java.util.Scanner;

class Main {
    public static void main(String[] args) { // String[] args不要忘
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            StringBuilder sb = new StringBuilder();
            char[] ch = scanner.nextLine().toCharArray();   // scanner.nextLine()
            for (char c : ch) {
                if (c>='a' && c <='z') {
                    sb.append(c);
                } else {
                    sb.append("number");
                }
            }
            System.out.println(sb.toString());
        }
        return;
    }
}
```
### [《代码随想录》字符串：翻转字符串里的单词](https://notes.kamacoder.com/questions/501978)


```java
// 代码随想录
// 字符串
// 时间On
// 空间O1（除了StringBuilder）
class Solution {
    public String reverseWords(String s) {
        // 1.去除首尾以及中间多余空格
        StringBuilder sb = removeSpace(s);
        // 2.反转整个字符串
        reverseString(sb, 0, sb.length() - 1);
        // 3.反转各个单词
        reverseEachWord(sb);
        return sb.toString();
    }

    public StringBuilder removeSpace(String s) {
        int start = 0;
        int end = s.length() - 1;
        while (s.charAt(start) == ' ') start++;
        while (s.charAt(end) == ' ') end--;
        StringBuilder sb = new StringBuilder();
        for (int i = start; i <= end; i++) {
            if (s.charAt(i) != ' ' || sb.charAt(sb.length()-1) != ' ') {    // 去除中间多余空格
                sb.append(s.charAt(i));
            }
        }
        return sb;
    }

    public void reverseString(StringBuilder sb, int start, int end) {
        while (start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
        }
    }

    private void reverseEachWord(StringBuilder sb) {
        int start = 0;
        int end = 0;
        int n = sb.length();
        while (start < n) {
            while (end < n && sb.charAt(end) != ' ') {
                end++;
            }   // 右边界找到下一个空格处
            reverseString(sb, start, end - 1);
            start = end + 1;    // 更新左边界
            end = start + 1;    // 右边界重新找
        }
    }
}
```
### [《代码随想录》字符串：右旋字符串](https://notes.kamacoder.com/questions/501979)
#### 代码随想录算法训练营Day09 | 151.@55.459.

#### 关于Scanner读取
##### 输入样例
```
2
abcdefg
```

##### 错误示范
```java
        int k =  sc.nextInt()
        String s = sc.nextLine();
```
**解释：** 执行流程如下
1. `sc.nextInt()` 读取 **`2`**，只读取了数字部分，并将光标停留在 **`2` 的后面**。
2. **`nextInt()` 不会自动跳过换行符**，因此换行符仍然留在输入缓冲区中。
3. 当执行 **`sc.nextLine()`** 时，读取的只是 **前面遗留的换行符**，并返回一个 **空字符串**。


##### 正确示范
```java
        int k =  Integer.parseInt(sc.nextLine());
        String s = sc.nextLine();
```
**解释：** 执行流程如下
1. **`sc.nextLine()`** 读取整行输入（包括换行符）并返回字符串。
2. `Integer.parseInt()` 将字符串转换为整数。
3. 接着，再次使用 **`sc.nextLine()`** 读取下一行输入。

---

#### 版本一：substring
```java
// 代码随想录
// 字符串
// 时间On
// 空间On
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int k =  Integer.parseInt(sc.nextLine());   // 标准写法
        String s = sc.nextLine();
        int n = s.length();
        System.out.println((s + s).substring(n - k, n * 2 - k));
    } 
}
```

#### 版本二：先整体再局部
```java
```
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = Integer.parseInt(in.nextLine());
        String s = in.nextLine();

        int len = s.length();  //获取字符串长度
        char[] chars = s.toCharArray();
        reverseString(chars, 0, len - n - 1);  //反转前一段字符串，此时的字符串首尾是0,len - n - 1
        reverseString(chars, len - n, len - 1);  //反转后一段字符串，此时的字符串首尾是len - n,len - 1
        reverseString(chars, 0, len - 1);  //反转整个字符串

        System.out.println(chars);

    }

    public static void reverseString(char[] ch, int start, int end) {
        //异或法反转字符串，参照题目 344.反转字符串的解释
        while (start < end) {
            ch[start] ^= ch[end];
            ch[end] ^= ch[start];
            ch[start] ^= ch[end];
            start++;
            end--;
        }
    }
}
```
```
### [《代码随想录》字符串：KMP算法](https://notes.kamacoder.com/questions/501980)
#### 代码随想录算法训练营Day09 | 151.@55.459.

**HARD**

```java
// 代码随想录
// KMP：根据最长相等前缀后缀构建前缀表next、找到不匹配的位置时 看前一个字符的前缀表的数值是多少 继续匹配
// 时间Om+n
// 空间On
class Solution {
    public int strStr(String haystack, String needle) {
        int m = haystack.length();
        int n = needle.length();
        if (n == 0) return 0;
        
        // （1）构建模式串needle的前缀表
        int[] next = new int[n];    // 前缀表（最长相等前缀后缀）
        int j = 0;  // j指向后缀尾巴，用于对比
        next[0] = 0;
        for (int i = 1; i < n; i++) {   // i指向前缀尾巴，用于对比
            // 回退
            while (j > 0 && needle.charAt(j) != needle.charAt(i))  // 只要前缀后缀还不一致，就回退j直到起点为止
                j = next[j-1];  // 前一个字符是满足的，j指向前一个字符对应的镜像下标

            // 填入
            if (needle.charAt(j) == needle.charAt(i))
                j++;
            next[i] = j;    // 与匹配不一样的地方
        }

        // （2）匹配
        j = 0;  // j指向模式串needle中已经匹配成功的
        for (int i = 0; i < m; i++) {   // 注意这里是从0遍历haystck
            while (j > 0 && needle.charAt(j) != haystack.charAt(i))
                j = next[j-1];
            if (needle.charAt(j) == haystack.charAt(i))
                j++;
            if (j == n) // 与构建前缀表不一样的地方
                return i-n+1;
        }

        return -1;
    }
}
```
### [《代码随想录》字符串：重复的子字符串](https://notes.kamacoder.com/questions/501981)
#### 代码随想录算法训练营Day09 | 151.@55.459.

**Hard**

```java
// 代码随想录
// KMP的前缀表的值：以该位置结尾的字符串的最长相等前后缀的长度
// 充分条件：如果字符串s是由重复子串组成，那么 最长相等前后缀不包含的子串 一定是 s的最小重复子串。
// 必要条件：如果字符串s的最长相等前后缀不包含的子串 是 s最小重复子串，那么 s是由重复子串组成。
// 故：当 最长相等前后缀不包含的子串的长度 可以被 字符串s的长度整除，那么不包含的子串 就是s的最小重复子串。
// 时间 On
// 空间 On
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        if (s.equals(""))   return false;   // 边界判断（可以去掉，因为题目范围是1 <= s.length <= 10^4）
        int n = s.length();

        // （1）构建KMP算法的前缀表
        int[] next = new int[n];
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            while (j>0 && s.charAt(i) != s.charAt(j))
                j = next[j-1];
            if (s.charAt(i) == s.charAt(j))
                j++;
            next[i] = j;
        }

        // （2）判断重复子字符串
        if (next[n-1] > 0 && n % (n-next[n-1])== 0) {   // 当 最长相等前后缀不包含的子串的长度 可以被 字符串s的长度整除
            return true;    // 那么字符串s是由重复子串组成，且不包含的子串就是s的最小重复子串
        } else {
            return false;
        }

    }
}
```
### [《代码随想录》字符串：字符串总结](https://notes.kamacoder.com/questions/501982)
#### 代码随想录算法训练营Day09 | 151.@55.459.

#### 双指针
双指针在数组、链表、字符串中很常用

---

#### 反转系列
先整体反转再局部反转

---

####  KMP
KMP核心思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息**避免从头再去做匹配**了
前缀：指**不包含**最后一个字符的所有以第一个字符开头的连续子串。
后缀：指**不包含**第一个字符的所有以最后一个字符结尾的连续子串
前缀表：**前缀表的值**表示以该位置结尾的字符串的**最长相等前后缀**的长度
## 栈与队列
### [《代码随想录》栈与队列：栈与队列理论基础](https://notes.kamacoder.com/questions/501983)
#### 代码随想录算法训练营Day10 | 232.225.20.1047.


- **栈**提供push 和 pop 等等接口，所有元素必须符合**先进后出**规则，所以栈**不提供走访功能，也不提供迭代器(iterator)**。 不像是set 或者map 提供迭代器iterator来遍历所有元素.
- **队列**中**先进先出**的数据结构，同样**不允许有遍历行为，不提供迭代器**。
### [《代码随想录》栈与队列：用栈实现队列](https://notes.kamacoder.com/questions/501984)
#### 代码随想录算法训练营Day10 | 232.225.20.1047.

```java
// 代码随想录
// pop时先清空输出栈，再倒腾输入栈，清空输入栈
// 时间 O1
// 空间 On
class MyQueue {
    private Stack<Integer> A;
    private Stack<Integer> B;

    public MyQueue() {
        A = new Stack<>();
        B = new Stack<>();
    }

    public void push(int x) {
        A.push(x);
    }

    public int peek() {
        if (!B.isEmpty())   return B.peek();
        if (A.isEmpty())    return -1;
        while (!A.isEmpty()){
            B.push(A.pop());
        }
        return B.peek();
    }

    public int pop() {
        int peek = peek();
        return B.pop();
    }

    public boolean empty() {
        return A.isEmpty() && B.isEmpty();
    }
}
```
### [《代码随想录》栈与队列：用队列实现栈](https://notes.kamacoder.com/questions/501985)
#### 代码随想录算法训练营Day10 | 232.225.20.1047.

```java
// 代码随想录
// 出栈时用另一个队列备份除了出栈元素外的所有数据
// 时间 push On、其他 O1
// 空间 On
class MyStack {
    Queue<Integer> A;   // A和栈中保持一样元素的队列
    Queue<Integer> B;   // B辅助队列

    public MyStack() {
        A = new LinkedList<Integer>();
        B = new LinkedList<Integer>();
    }
    
    public void push(int x) {
        while (A.size() > 0) {
            B.add(A.poll());
        }
        A.add(x);
        while (B.size() > 0) {
            A.add(B.poll());
        }
    }
    
    public int pop() {
        return A.poll();    // 因为A中的元素和栈中的保持一致，所以这个和下面两个的操作只看queue1即可
    }
    
    public int top() {
        return A.peek();
    }
    
    public boolean empty() {
        return A.isEmpty();
    }
}
```
### [《代码随想录》栈与队列：有效的括号](https://notes.kamacoder.com/questions/501986)
#### 代码随想录算法训练营Day10 | 232.225.20.1047.

```java
// 代码随想录
// 栈
// 时间 On
// 空间 On
class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        if (n % 2 == 1) {
            return false;
        }
        Deque<Character> deque = new LinkedList<>();
        char ch;
        for (int i = 0; i < n; i++) {
            ch = s.charAt(i);
            if (ch == '(')  deque.push(')');
            else if (ch == '[')  deque.push(']');
            else if (ch == '{')  deque.push('}');
            else if (deque.isEmpty() || deque.peek() != ch)  return false;
            else    deque.pop();
        }
        return deque.isEmpty();
    }
}
```
### [《代码随想录》栈与队列：删除字符串中的所有相邻重复项](https://notes.kamacoder.com/questions/501987)
#### 代码随想录算法训练营Day10 | 232.225.20.1047.

```java
// 代码随想录
// 栈
// 时间 On
// 空间 O1（不算res）
class Solution {
    public String removeDuplicates(String s) {
        StringBuilder res = new StringBuilder();
        int idx = -1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (idx >= 0 && res.charAt(idx) == c) {
                res.deleteCharAt(idx);
                idx--;
            } else {
                res.append(c);
                idx++;
            }
        }
        return res.toString();
    }
}
```
### [《代码随想录》栈与队列：逆波兰表达式求值](https://notes.kamacoder.com/questions/501988)
#### 代码随想录算法训练营Day11 | 150.239.347

```java
// 代码随想录
// 栈，注意-和/的顺序
// 时间 On
// 空间 On
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> st = new Stack<>();
        for (String tt : tokens) {
            if (tt.equals("+")) {
                int val = st.pop()+st.pop();
                st.push(val);
            } else if (tt.equals("*")) {
                int val = st.pop()*st.pop();
                st.push(val);
            } else if (tt.equals("-")) {
                int tmp1 = st.pop();
                int tmp2 = st.pop();
                st.push(tmp2-tmp1);
            } else if (tt.equals("/")) {
                int tmp1 = st.pop();
                int tmp2 = st.pop();
                st.push(tmp2/tmp1);
            } else {
                st.push(Integer.valueOf(tt));
            }
        }
        return st.pop();
    }
}
```
### [《代码随想录》栈与队列：滑动窗口最大值](https://notes.kamacoder.com/questions/501989)
#### 代码随想录算法训练营Day11 | 150.239.347

```java
// Hot100
// 升序单调队列ArrayDeque存放下标，淘汰一定不是候选的，去掉窗口之外的
// 时间On
// 空间Ok
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> que = new ArrayDeque<>();
        int n = nums.length;
        int[] res = new int[n-k+1];

        for (int i = 0; i < n; i++) {
            // 淘汰一定不是候选的
            while(!que.isEmpty() && nums[i] >= nums[que.getLast()]) {
                que.removeLast();
            }
            // 加入
            que.addLast(i);
            // 去掉窗口之外的
            if(i-que.getFirst() == k) {
                que.removeFirst();
            }
            // 更新
            if(i>=k-1) {
                res[i-(k-1)] = nums[que.getFirst()];
            }
        }
        return res;
    }
}
```
### [《代码随想录》栈与队列：前K个高频元素](https://notes.kamacoder.com/questions/501990)
#### 代码随想录算法训练营Day11 | 150.239.347

- 正则表达式写法`PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->b[1]-a[1]);`
- `for (Map.Entry<Integer, Integer> entry : mp.entrySet())`
- **优先队列**的**添加、弹出**的时间复杂度为**Ologn**

---

```java
// 代码随想录
// 哈希表、优先队列
// 时间 Onlogn
// 空间 On
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> mp = new HashMap<>();
        int[] res = new int[k];
        
        for (int num : nums) {
            mp.put(num, mp.getOrDefault(num, 0)+1);
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->b[1]-a[1]);
        
        for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {
            pq.add(new int[]{entry.getKey(), entry.getValue()});

        }

        for (int i = 0; i < k; i++) {
            res[i] = pq.poll()[0];
        }

        return res;
    }
}
```
### [《代码随想录》栈与队列：栈与队列总结](https://notes.kamacoder.com/questions/501991)
#### 代码随想录算法训练营Day11 | 150.239.347

---

##### 栈 经典题目
- 括号匹配
- 字符串去重，消除相邻重复项
- 逆波兰表达式

---

##### 队列 经典题目
**单调队列**：队列没有必要维护窗口里的所有元素，**只需要维护有可能成为窗口里最大值的元素**就可以了，同时保证队列里的元素数值是由大到小的。
- 求前 K 个高频元素

---

##### 什么是堆呢？
**堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。** 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。
## 二叉树
### [《代码随想录》二叉树：二叉树理论基础](https://notes.kamacoder.com/questions/501992)
#### 代码随想录算法训练营Day13 | 144.145.94.102.107.199.637.429.515.116.117.104.111.

- **优先级队列**其实是一个**堆**，堆就是一棵**完全二叉树**，同时保证父子节点的顺序关系。
- **平衡二叉搜索树**：又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的**高度差的绝对值不超过1**，并且左右两个子树都是一棵平衡二叉树。
- 中间节点的顺序就是所谓的遍历方式
	- 前序遍历：中左右
	- 中序遍历：左中右
	- 后序遍历：左右中
### [《代码随想录》二叉树：二叉树的递归遍历](https://notes.kamacoder.com/questions/501993)
#### 代码随想录算法训练营Day13 | 144.145.94.102.107.199.637.429.515.116.117.104.111.

Easy

### [《代码随想录》二叉树：二叉树的迭代遍历](https://notes.kamacoder.com/questions/501994)
#### 代码随想录算法训练营Day13 | 144.145.94.102.107.199.637.429.515.116.117.104.111.

转 统一迭代法
### [《代码随想录》二叉树：二叉树的统一迭代法](https://notes.kamacoder.com/questions/501995)
#### 代码随想录算法训练营Day13 | 144.145.94.102.107.199.637.429.515.116.117.104.111.

关键：
1. 栈 反序 存放
2. null标记处理
### [《代码随想录》二叉树：二叉树的层序遍历](https://notes.kamacoder.com/questions/501996)
#### 代码随想录算法训练营Day13 | 144.145.94.102.107.199.637.429.515.116.117.104.111.

---

##### Java知识
###### Java中queue.offer(null)时，size会++吗？
- 如果不做`if(root == null)    return res;`判断，那么`queue.offer(root);`不会报错且`queue.size()`正常增加。
- 但是后续`level.add(node.val);`会报错，所以尽量保持queue中不要有null。
###### Java中的Queue有哪些具体实现
- **`LinkedList`**：基于链表的常规队列实现，适合一般用途。
- **`PriorityQueue`**：优先级队列，按照优先级顺序处理元素。
- **`ArrayDeque`**：基于动态数组的高效队列实现，适用于需要高效队列操作的场景。
- **`ConcurrentLinkedQueue`**：线程安全的队列实现，适用于并发场景。
- **`BlockingQueue`**：用于线程间协调的阻塞队列，适用于多线程编程。
- **`Deque`**：双端队列，支持从两端进行插入和删除操作。


---

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if (root == null)   return res;
        queue.offer(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> path = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                path.add(node.val);
                if (node.left != null)   queue.offer(node.left);
                if (node.right != null)   queue.offer(node.right);
            }
            res.add(path);
        }
        
        return res;
    }
}
```
### [《代码随想录》二叉树：翻转二叉树](https://notes.kamacoder.com/questions/501997)
#### 代码随想录算法训练营Day14 | 226.101.104.111.

```java
// 代码随想录
// 唯独中序遍历不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）
// 时间 On
// 空间 On
/*
    空间复杂度主要取决于递归调用的栈空间。
    在最坏情况下，如果二叉树是一个链式结构，On
    在最好情况下，如果二叉树是完全平衡的，Ologn
*/
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null)   return null;
        invertTree(root.left);
        invertTree(root.right);
        swapChildren(root);
        return root;
    }

    private void swapChildren(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
}
```
### [《代码随想录》二叉树：对称二叉树](https://notes.kamacoder.com/questions/501998)
#### 代码随想录算法训练营Day14 | 226.101.104.111.

```java
// 代码随想录
// 二叉树、递归
// 时间 On
// 空间 On
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return help(root.left, root.right);
    }
    public boolean help(TreeNode left, TreeNode right) {
        if(left == null && right == null)   return true;
        if(left == null || right == null)   return false;
        return left.val == right.val 
            && help(left.left, right.right) 
            && help(left.right, right.left);

    }
}
```
### [《代码随想录》二叉树：二叉树的最大深度](https://notes.kamacoder.com/questions/501999)
#### 代码随想录算法训练营Day14 | 226.101.104.111.

```java
// 代码随想录
// 二叉树、深度
// 时间 On
// 空间 On
class Solution {
    public int maxDepth(TreeNode root) {
        int res = 0;
        Queue<TreeNode> queue = new LinkedList<>();
        if (root == null)   return res;
        queue.offer(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null)   queue.offer(node.left);
                if (node.right != null)   queue.offer(node.right);
            }
            res++;
        }
        
        return res;
    }
}
```
### [《代码随想录》二叉树：二叉树的最小深度](https://notes.kamacoder.com/questions/502000)
#### 代码随想录算法训练营Day14 | 226.101.104.111.

```java
// 代码随想录
// 二叉树、深度。if (node.left==null && node.right==null)    return res;
// 时间 On
// 空间 On
class Solution {
    public int minDepth(TreeNode root) {
        int res = 0;
        Queue<TreeNode> queue = new LinkedList<>();
        if (root == null)   return res;
        queue.offer(root);

        while (!queue.isEmpty()) {
            res++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left==null && node.right==null)    return res;
                if (node.left != null)   queue.offer(node.left);
                if (node.right != null)   queue.offer(node.right);
            }
        }
        
        return res;
    }
}
```
### [《代码随想录》二叉树：完全二叉树的节点个数](https://notes.kamacoder.com/questions/502001)
#### 代码随想录算法训练营Day15 | 110.257.404.222.

```java
// 代码随想录
// 二叉树、递归
// 时间 On
// 空间 Ologn
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null)   return 0;
        return countNodes(root.left)+countNodes(root.right)+1;
    }
}
```
### [《代码随想录》二叉树：平衡二叉树](https://notes.kamacoder.com/questions/502002)
#### 代码随想录算法训练营Day15 | 110.257.404.222.

```java
// 代码随想录
// 二叉树、递归
// 时间 On
// 空间 On
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    private int getHeight(TreeNode root) {
        if (root == null)   return 0;
        
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) return -1;

        if (Math.abs(leftHeight-rightHeight) > 1)   return -1;
        return Math.max(leftHeight, rightHeight)+1;
    }
}
```
### [《代码随想录》二叉树：二叉树的所有路径](https://notes.kamacoder.com/questions/502003)
#### 代码随想录算法训练营Day15 | 110.257.404.222.

```java
// 代码随想录
// 二叉树、递归
// 时间 On
// 空间 On
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null)   return res;
        List<Integer> path = new ArrayList<>();
        traversal(root, path, res);
        return res;
    }

    private void traversal(TreeNode root, List<Integer> path, List<String> res) {
        // 中
        path.add(root.val);
        if (root.left == null && root.right == null) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < path.size() - 1; i++) {
                sb.append(path.get(i)).append("->");
            }
            sb.append(path.get(path.size() - 1));
            res.add(sb.toString());
            return;
        }

        // 左
        if (root.left != null) { 
            traversal(root.left, path, res);
            path.remove(path.size() - 1);// 回溯
        }

        // 右
        if (root.right != null) { 
            traversal(root.right, path, res);
            path.remove(path.size() - 1);// 回溯
        }
    }
}
```
### [《代码随想录》二叉树：左叶子之和](https://notes.kamacoder.com/questions/502004)
#### 代码随想录算法训练营Day15 | 110.257.404.222.

```java
// 代码随想录
// 二叉树、递归、后序遍历
// 时间 On
// 空间 On
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        // 左
        int leftValue = sumOfLeftLeaves(root.left);
        // 右
        int rightValue = sumOfLeftLeaves(root.right);
        // 中
        int midValue = 0;
        if (root.left != null && root.left.left == null && root.left.right == null) { 
            midValue = root.left.val;
        }
        return midValue + leftValue + rightValue; 
    }
}
```
### [《代码随想录》二叉树：找树左下角的值](https://notes.kamacoder.com/questions/502005)
#### 代码随想录算法训练营Day16 | 513.112.113.106.105.

```java
// 代码随想录
// 迭代、层序遍历
// 时间 On
// 空间 On
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        int res = 0;    
        Queue<TreeNode> queue = new LinkedList<>();
        if (root!=null) queue.offer(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (i == 0) res = node.val;
                if (node.left != null)  queue.offer(node.left);
                if (node.right != null)  queue.offer(node.right);
            }
        }


        return res;
    }

}
```
### [《代码随想录》二叉树：路径总和](https://notes.kamacoder.com/questions/502006)
#### 代码随想录算法训练营Day16 | 513.112.113.106.105.

```java
// 代码随想录
// 递归
// 时间 On
// 空间 On
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null)   return false;

        targetSum -= root.val;
        if (root.left == null && root.right == null) {
            return targetSum == 0;
        }

        if (root.left != null) {
            boolean left = hasPathSum(root.left, targetSum);
            if (left) {      // 已经找到，提前返回
                return true;
            }
        }

        // 右边
        if (root.right != null) {
            boolean right = hasPathSum(root.right, targetSum);
            if (right) {     // 已经找到，提前返回
                return true;
            }
        }

        return false;
    }
}
```
### [《代码随想录》二叉树：从中序与后序遍历序列构造二叉树](https://notes.kamacoder.com/questions/502007)
#### 代码随想录算法训练营Day16 | 513.112.113.106.105.

```java
class Solution {
    int post_idx;
    int[] postorder;
    int[] inorder;
    Map<Integer, Integer> idx_map = new HashMap<Integer, Integer>();

    public TreeNode helper(int in_left, int in_right) {
        // 如果这里没有节点构造二叉树了，就结束
        if (in_left > in_right) {
            return null;
        }

        // 选择 post_idx 位置的元素作为当前子树根节点
        int root_val = postorder[post_idx];
        TreeNode root = new TreeNode(root_val);

        // 根据 root 所在位置分成左右两棵子树
        int index = idx_map.get(root_val);

        // 下标减一
        post_idx--;
        // 构造右子树
        root.right = helper(index + 1, in_right);
        // 构造左子树
        root.left = helper(in_left, index - 1);
        return root;
    }

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.postorder = postorder;
        this.inorder = inorder;
        // 从后序遍历的最后一个元素开始
        post_idx = postorder.length - 1;

        // 建立（元素，下标）键值对的哈希表
        int idx = 0;
        for (Integer val : inorder) {
            idx_map.put(val, idx++);
        }
        
        return helper(0, inorder.length - 1);
    }
}
```
### [《代码随想录》二叉树：最大二叉树](https://notes.kamacoder.com/questions/502008)
#### 代码随想录算法训练营Day17 | 654.617.700.98.

```java
// 代码随想录
// 递归，在区间内找出最大值，再划分为左右，分别递归构建左右子树
// 时间 On^2
// 空间 On
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return help(nums, 0, nums.length);  // 左闭右开
    }
    public TreeNode help(int[] nums, int left, int right) {
        // 终止条件
        if (left == right)      return null;
        if (left+1 == right)    return new TreeNode(nums[left]);

        // 中
        int maxVal = nums[left];
        int maxIdx = left;
        for (int i = left + 1; i < right; i++) {
            if (nums[i] > maxVal){
                maxVal = nums[i];
                maxIdx = i;
            }
        }
        TreeNode root = new TreeNode(maxVal);

        // 左
        root.left = help(nums, left, maxIdx);

        // 右
        root.right = help(nums, maxIdx + 1, right);

        return root;
    }
}
```
### [《代码随想录》二叉树：合并二叉树](https://notes.kamacoder.com/questions/502009)
#### 代码随想录算法训练营Day17 | 654.617.700.98.

```java
// 代码随想录
// 递归
// 时间 On
// 空间 On
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) return root2;
        if (root2 == null) return root1;

        root1.val += root2.val;
        root1.left = mergeTrees(root1.left,root2.left);
        root1.right = mergeTrees(root1.right,root2.right);

        return root1;
    }
}
```
### [《代码随想录》二叉树：二叉搜索树中的搜索](https://notes.kamacoder.com/questions/502010)
#### 代码随想录算法训练营Day17 | 654.617.700.98.

```java
// 代码随想录
// 二分查找
// 时间 On
// 空间 O1
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) {
            return root;
        }
        if (val < root.val) {
            return searchBST(root.left, val);
        } else {
            return searchBST(root.right, val);
        }
    }
}
```
### [《代码随想录》二叉树：验证二叉搜索树](https://notes.kamacoder.com/questions/502011)
#### 代码随想录算法训练营Day17 | 654.617.700.98.

```java
// 代码随想录
// 递归，二叉搜索树中序遍历（左中右）为升序、由于if (root.val <= pre)    return false;判断需要让pre初始值比Integer.MIN_VALUE还小，因此用Long
// 时间 On
// 空间 On
class Solution {
    Long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        // 终止条件
        if (root == null)   return true;

        // 左
        if (!isValidBST(root.left))  return false;

        // 中
        if (root.val <= pre)    return false;
        else                    pre = (long)root.val;

        // 右
        if (!isValidBST(root.right))  return false;

        return true;
    }
}
```
### [《代码随想录》二叉树：二叉搜索树的最小绝对差](https://notes.kamacoder.com/questions/502012)
#### 代码随想录算法训练营Day18 | 530.501.236.

```java
// 代码随想录
// 递归，中序遍历，pre记录
// 时间 O
// 空间 O
class Solution {
    TreeNode pre;
    int res = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        if (root == null)   return 0;
        traversal(root);
        return res;
    }
	
    public void traversal(TreeNode root) {
        // 终止条件
        if (root == null)   return;

        // 左
        traversal(root.left);

        // 中
        if (pre != null) {
            res = Math.min(res, Math.abs(root.val-pre.val));
        }
        pre = root;

        // 右
        traversal(root.right);
    }
}
```
### [《代码随想录》二叉树：二叉搜索树中的众数](https://notes.kamacoder.com/questions/502013)
#### 代码随想录算法训练营Day18 | 530.501.236.

```java
// 代码随想录
// 递归、中序遍历、res[i] = resList.get(i);
// 时间 On
// 空间 On
class Solution {
    ArrayList<Integer> resList;
    int maxCount;
    int count;
    TreeNode pre;

    public int[] findMode(TreeNode root) {
        resList = new ArrayList<>();
        maxCount = 0;
        count = 0;
        pre = null;
        
        traversal(root);
        
        int[] res = new int[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }
        return res;
    }

    public void traversal(TreeNode root) {
        if (root == null) {
            return;
        }

        // 左
        traversal(root.left);

        // 中
        if (pre == null || root.val != pre.val) {
            count = 1;
        } else {
            count++;
        }
        if (count > maxCount) {
            maxCount = count;
            resList.clear();
            resList.add(root.val);
        } else if (count == maxCount) {
            resList.add(root.val);
        }
        pre = root;

        // 右
        traversal(root.right);
    }
}
```
### [《代码随想录》二叉树：二叉树的最近公共祖先](https://notes.kamacoder.com/questions/502014)
#### 代码随想录算法训练营Day18 | 530.501.236.

1. 求最小公共祖先，需要**从底向上**遍历，那么二叉树，只能通过**后序遍历（即：回溯）** 实现从底向上的遍历方式。
2. 在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，**依然要把其他节点遍历完**，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。
3. 要理解如果返回值left为空，right不为空**为什么要返回right**，为什么可以用返回right传给上一层结果。

---

如果递归函数有返回值，**如何区分要搜索一条边，还是搜索整个树呢？**
搜索一条边的写法：
```
if (递归函数(root->left)) return ;
if (递归函数(root->right)) return ;
```

搜索整个树写法：
```
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

---

```java
// 代码随想录
// 后序遍历、注意要都处理完而不是半路就结束
// 时间 On
// 空间 On
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 终止条件
        if (root == null || root == p || root == q)   return root;

        // 左
        TreeNode left = lowestCommonAncestor(root.left, p, q);

        // 右
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // 中
        if(left == null && right == null) { // p和q都没找到，那就没有
            return null;
        } else if (left == null && right != null) { //左子树没有p也没有q，就返回右子树的结果
            return right;
        } else if (left != null && right == null) { //右子树没有p也没有q就返回左子树的结果
            return left;
        } else if (left != null && right != null) { //左右子树都找到p和q了，那就说明p和q分别在左右两个子树上，所以此时的最近公共祖先就是root
            return root;
        }

        return null;    // 其实走不到这边
    }
}
```
### [《代码随想录》二叉树：二叉搜索树的最近公共祖先](https://notes.kamacoder.com/questions/502015)
#### 代码随想录算法训练营Day20 | 235.701.450.

```java
// 代码随想录
// 二叉树：利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。
// 二叉搜索树：只要从上到下去遍历，遇到 cur节点是数值在[p, q]区间中则一定可以说明该节点cur就是p 和 q的公共祖先。（反证法）
// 时间 On
// 空间 On
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root.val > p.val && root.val > q.val)   // root大了，在左子树
            return lowestCommonAncestor(root.left, p, q);   // root小了，在右子树
        if (root.val < p.val && root.val < q.val) 
            return lowestCommonAncestor(root.right, p, q);
        // cur节点是数值在区间中，返回root
        return root;
    }
}
```
### [《代码随想录》二叉树：二叉搜索树中的插入操作](https://notes.kamacoder.com/questions/502016)
#### 代码随想录算法训练营Day20 | 235.701.450.

```java
// 代码随想录
// 递归
// 时间 On
// 空间 On
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        // 终止条件
        if (root == null) {
            return new TreeNode(val);
        }

        if (val < root.val) {
            root.left = insertIntoBST(root.left, val);
        } else {
            root.right = insertIntoBST(root.right, val);
        }

        return root;
    }
}
```
### [《代码随想录》二叉树：删除二叉搜索树中的节点](https://notes.kamacoder.com/questions/502017)
#### 代码随想录算法训练营Day20 | 235.701.450.

```java
// 代码随想录
// 左右孩子节点都不为空，则将 删除节点的左孩子 放到 删除节点的右孩子 的最左面节点的左孩子上，返回删除节点右孩子为新的根节点
// 时间 Oh
// 空间 Oh
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return root;
          
        if (key == root.val) {
            if (root.left == null) {
                return root.right;
            } else if (root.right == null) {
                return root.left;
            } else {
                TreeNode cur = root.right;
                while (cur.left != null) {
                    cur = cur.left;
                }
                cur.left = root.left;   // 将 删除节点的左孩子 放到 删除节点的右孩子 的最左面节点的左孩子上
                root = root.right;
                return root;
            }
        }

        if (key < root.val) 
            root.left = deleteNode(root.left, key); // 注意不是直接return！

        if (key > root.val) 
            root.right = deleteNode(root.right, key); // 注意不是直接return！

        return root;
    }
}
```
### [《代码随想录》二叉树：修剪二叉搜索树](https://notes.kamacoder.com/questions/502018)
#### 代码随想录算法训练营Day27 | 669.108.538.

```java
// 代码随想录
// 递归，返回符合条件的子树并接住
// 时间 On
// 空间 On
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null)   return null;
        if (root.val < low) return trimBST(root.right, low, high);
        if (root.val > high)    return trimBST(root.left, low, high);
        // 在范围内
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);    
        return root;
    }
}
```
### [《代码随想录》二叉树：将有序数组转换为二叉搜索树](https://notes.kamacoder.com/questions/502019)
#### 代码随想录算法训练营Day27 | 669.108.538.

```java
// 代码随想录
// 递归，每次取中间
// 时间 On
// 空间 Ologn
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return help(nums, 0, nums.length-1);
    }

    public TreeNode help(int[] nums, int left, int right) {
        if (left > right)   return null;
        int mid = left + (right-left)/2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = help(nums, left, mid-1);
        node.right = help(nums, mid+1, right);
        return node;
    }
}
```
### [《代码随想录》二叉树：把二叉搜索树转换为累加树](https://notes.kamacoder.com/questions/502020)
#### 代码随想录算法训练营Day27 | 669.108.538.

```java
// 代码随想录
// 右中左递归，sum作为全局变量累加
// 时间 On
// 空间 On
class Solution {
    int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        help(root);
        return root;
    }
    public void help(TreeNode root) {
        if (root == null)   return;

        help(root.right);
        sum += root.val;
        root.val = sum;
        help(root.left);
    }
}
```
### [《代码随想录》二叉树：二叉树总结篇](https://notes.kamacoder.com/questions/502021)
#### 代码随想录算法训练营Day27 | 669.108.538.

##### 二叉树
- 理论基础
- 遍历方式
	- 前中后序
	- 层序
- 属性
	- 是否对称（后序）
	- 最大/最小深度（后序）
	- 节点数目（层序）
	- 是否平衡（后序）
	- 所有路径（前序）
	- 左叶子之和（后序）
	- 左下角的值
	- 路经总和
- 修改与构造
	- 翻转二叉树（前序）
	- 构造二叉树（前序）
	- 构造最大的二叉树（前序）
	- 合并两个二叉树（前序）


##### 二叉搜索树
- 属性
	- 搜索
	- 是不是（中序）
	- 最小绝对差（中序）
	- 众数（中序）
	- 累加树（中序）
- 修改与构造
	- 插入
	- 删除（前序）
	- 修剪（前序）
	- 构造（前序）

##### 二叉树公共祖先问题


## 回溯算法
### [《代码随想录》回溯算法：回溯算法理论基础](https://notes.kamacoder.com/questions/502022)
#### 代码随想录算法训练营Day28 | 77.216.17.


回溯法，一般可以解决如下几种问题：
- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等



 
### [《代码随想录》回溯算法：组合](https://notes.kamacoder.com/questions/502023)
#### 代码随想录算法训练营Day28 | 77.216.17.

**n相当于树的宽度，k相当于树的深度**

---

```java
// 回溯法模板
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

---

```java
// 代码随想录
// n相当于树的宽度，k相当于树的深度
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }

    public void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.add(new ArrayList<>(path));
            return;
        }
        // 已经选择的元素个数：path.size();
        // 还需要的元素个数为: k - path.size();
        // 从i开始到末尾最多： n - i + 1（+1是因为i并不是下标，而是从1开始）
        for (int i = startIndex; n-i+1 >= k-path.size(); i++) {
            path.add(i);
            backtracking(n, k, i + 1);
            path.removeLast();
        }
    }
}
```

 
### [《代码随想录》回溯算法：组合优化](https://notes.kamacoder.com/questions/502024)
#### 代码随想录算法训练营Day28 | 77.216.17.

```java

```

 
### [《代码随想录》回溯算法：组合总和III](https://notes.kamacoder.com/questions/502025)
#### 代码随想录算法训练营Day28 | 77.216.17.


```java
// 代码随想录
// 时间 OC9k x k
// 空间 OC9k x k
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum3(int k, int targetSum) {
        backTracking(targetSum, k, 1, 0);
        return result;
    }

    private void backTracking(int targetSum, int k, int startIndex, int sum) {
        // 剪枝1
        if (sum > targetSum)    
            return;
        
        // 终止条件
        if (path.size() == k) {
            if (sum == targetSum) 
                result.add(new ArrayList<>(path));
            return;
        }

        // 剪枝2
        for (int i = startIndex; 9-i+1 >= k-path.size(); i++) {
            path.add(i);    sum += i;
            backTracking(targetSum, k, i + 1, sum);
            path.removeLast();  sum -= i;
        }
    }
}
```

 
### [《代码随想录》回溯算法：电话号码的字母组合](https://notes.kamacoder.com/questions/502026)
#### 代码随想录算法训练营Day28 | 77.216.17.

```java
// 代码随想录
// Map<Character, String>
// 时间 Om^n x n 其中，n为digits长度，m为每个数字对应字母的平均数目
// 空间 Om^n x n
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        if (digits.length() == 0) return res;
        StringBuilder path = new StringBuilder();
        
        Map<Character, String> map = new HashMap<>(){{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};

        backtrack(0, res, path, map, digits);
        return res;   
    }

    public void backtrack(int idx, List<String> res, StringBuilder path, Map<Character, String> map, String digits) {
        if (idx == digits.length()) {
            res.add(path.toString());
            return;
        }

        char digit = digits.charAt(idx);
        String s = map.get(digit);
        
        for (char c : s.toCharArray()) {
            path.append(c);
            backtrack(idx+1, res, path, map, digits);
            path.deleteCharAt(idx);
        }
    }
}
```

 
### [《代码随想录》回溯算法：组合总和](https://notes.kamacoder.com/questions/502027)
#### 代码随想录算法训练营Day29 | 39.40.131.

```java
// 代码随想录
// 回溯、排序、剪枝
// 时间 O2^n x k，其中k为组合平均长度
// 空间 O2^n x k
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        Arrays.sort(candidates);
        backtracking(0, res, path, candidates, target);
        return res;
    }

    void backtracking(int idx, List<List<Integer>> res, List<Integer> path, int[] candidates, int target) {
        if (target < 0)     return;
        if (target == 0) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = idx; i < candidates.length; i++) {
            if (i>idx && candidates[i]==candidates[i - 1])  // 避免重复元素顺序调换造成的重复
                continue;

            path.add(candidates[i]);
            backtracking(i + 1, res, path, candidates, target-candidates[i]);    // 一个元素不能选多次
            path.removeLast();
        }
    }
}
```
### [《代码随想录》回溯算法：组合总和II](https://notes.kamacoder.com/questions/502028)
#### 代码随想录算法训练营Day29 | 39.40.131.

```java

```
### [《代码随想录》回溯算法：分割回文串](https://notes.kamacoder.com/questions/502029)
#### 代码随想录算法训练营Day29 | 39.40.131.

```java
// 代码随想录
// 回溯，构建子串的回文表
// 时间 O2^n x n
// 空间 O2^n x n
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<>();
        List<String> path = new ArrayList<>();

        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        for (int right = 0; right < n; right++) {
            for (int left = 0; left <= right; left++) {
                if (s.charAt(left)==s.charAt(right) && (right-left<=2 || dp[left+1][right-1])) {
                    dp[left][right] = true;
                }
            }
        }

        backtracking(0, res, path, s, dp);
        return res;
    }

    public void backtracking(int left, List<List<String>> res, List<String> path, String s, boolean[][] dp) {
        if(left == s.length()) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int right = left; right < s.length(); right++) {   // 以left为左边界，贪心地取右边界，看能不能构成回文
            if(dp[left][right]) {   // 如果能构成回文
                path.add(s.substring(left, right+1));   // [)
                backtracking(right+1, res, path, s, dp);    // 以right+1为新的左边界继续找
                path.removeLast();
            }
        }
    }
}

/* 关于if (s.charAt(left)==s.charAt(right) && (right-left<=2 || dp[left+1][right-1]))的解释
    1. s.charAt(left) == s.charAt(right)
    这是判断一个子串是否为回文串的基本条件。回文串的特点是从左到右和从右到左读是一样的，所以子串的首尾字符必须相等。如果首尾字符不相等，那么这个子串肯定不是回文串。
    
    2. right - left <= 2
    这个条件用于处理子串长度较短的情况，具体分析如下：
    长度为 1 的子串：当 right - left == 0 时，子串只有一个字符，单个字符本身就是回文串，例如 "a"。
    长度为 2 的子串：当 right - left == 1 时，子串有两个字符。由于前面已经判断了 s.charAt(left) == s.charAt(right)，即首尾字符相等，所以这种情况下子串是回文串，例如 "aa"。
    长度为 3 的子串：当 right - left == 2 时，子串有三个字符。同样因为前面判断了首尾字符相等，中间的字符不影响回文性，所以子串是回文串，例如 "aba"。
    
    3. dp[left + 1][right - 1]
    这个条件用于处理子串长度大于 3 的情况。当子串长度大于 3 时，要判断该子串是否为回文串，除了首尾字符相等外，还需要判断去掉首尾字符后的内部子串是否为回文串。而 dp[left + 1][right - 1] 正好记录了这个内部子串是否为回文串的结果。如果 dp[left + 1][right - 1] 为 true，说明内部子串是回文串，再结合首尾字符相等，就可以确定整个子串是回文串。
*/
```
### [《代码随想录》回溯算法：复原IP地址](https://notes.kamacoder.com/questions/502030)
#### 代码随想录算法训练营Day30 | 93.78.90.

```java
// 代码随想录
// 回溯
// 时间 On
// 空间 On
class Solution {
    List<String> result = new ArrayList<String>();
    StringBuilder path = new StringBuilder();

    public List<String> restoreIpAddresses(String s) {
        restoreIpAddressesHandler(s, 0, 0);
        return result;
    }

    // number表示stringbuilder中ip段的数量
    public void restoreIpAddressesHandler(String s, int start, int number) {
        // 如果start等于s的长度并且ip段的数量是4，则加入结果集，并返回
        if (start == s.length() && number == 4) {
            result.add(path.toString());
            return;
        }
        // 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回
        if (start == s.length() || number == 4) {
            return;
        }
        // 剪枝：ip段的长度最大是3，并且ip段处于[0,255]
        for (int i = start; i < s.length() && i - start < 3 && Integer.parseInt(s.substring(start, i + 1)) >= 0
                && Integer.parseInt(s.substring(start, i + 1)) <= 255; i++) {
            if (i + 1 - start > 1 && s.charAt(start) - '0' == 0) {
                break;
            }
            path.append(s.substring(start, i + 1));
            // 当path里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点
            if (number < 3) {
                path.append(".");
            }
            number++;
            restoreIpAddressesHandler(s, i + 1, number);
            number--;
            // 删除当前path最后一个网段，注意考虑点的数量的问题
            path.delete(start + number, i + number + 2);
        }
    }
}
```
### [《代码随想录》回溯算法：子集](https://notes.kamacoder.com/questions/502031)
#### 代码随想录算法训练营Day30 | 93.78.90.

```java
// 代码随想录
// 时间 O2^n x n
// 空间 O2^n x n
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    
    public List<List<Integer>> subsets(int[] nums) {
        subsetsHelper(nums, 0);
        return result;
    }

    private void subsetsHelper(int[] nums, int startIndex){
        result.add(new ArrayList<>(path));
        if (startIndex >= nums.length){
            return;
        }
        
        for (int i = startIndex; i < nums.length; i++){
            path.add(nums[i]);
            subsetsHelper(nums, i + 1);
            path.removeLast();
        }
    }
}
```
### [《代码随想录》回溯算法：子集II](https://notes.kamacoder.com/questions/502032)
#### 代码随想录算法训练营Day30 | 93.78.90.

```java
// 每日一题、代码随想录
/* 
    考虑数组 [1,2,2]，选择前两个数，或者第一、三个数，都会得到相同的子集。
    也就是说，对于当前选择的数 x，若前面有与其相同的数 y，且没有选择 y，此时包含 x 的子集，必然会出现在包含 y 的所有子集中。
    在递归时，若发现没有选择上一个数，且当前数字与上一个数相同，则可以跳过当前生成的子集
*/
// 时间 On x 2^n
// 空间 On
class Solution {
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    List<Integer> path = new ArrayList<Integer>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        dfs(false, 0, nums);
        return res;
    }

    public void dfs(boolean choosePre, int idx, int[] nums) {
        if (idx == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        dfs(false, idx + 1, nums);
        if (!choosePre && idx > 0 && nums[idx - 1] == nums[idx]) {
            return;
        }
        path.add(nums[idx]);
        dfs(true, idx + 1, nums);
        path.removeLast();
    }
}
```
### [《代码随想录》回溯算法：递增子序列](https://notes.kamacoder.com/questions/502033)
#### 代码随想录算法训练营Day31 | 491.46.47.332.51.37.

```java
// 代码随想录
// res.add不要加return，要取树上的节点
// 通过局部HashMap实现去重，局部因为只需要关注当前层次有没有重复，避免漏掉4,6,7,7和4,7,7
// 时间 O2^n x k，其中k表示子序列的平均长度
// 空间 O2^n x k，其中k表示子序列的平均长度
class Solution {
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        backtracking(0, res, path, nums);
        return res;
    }

    public void backtracking(int idx, List<List<Integer>> res, List<Integer> path, int[] nums) {
        if (path.size() > 1) {
            res.add(new ArrayList<>(path)); 
            // 注意这里不要加return，要取树上的节点
        }

        Map<Integer, Integer> mp = new HashMap<>(); // 因为只需要关注当前层次有没有重复，所以定义局部HashMap即可

        for (int i = idx; i < nums.length; i++) {
            // 非递减
            if (!path.isEmpty() && nums[i] < path.getLast())    continue;
            // 去重
            if (mp.getOrDefault(nums[i], 0) > 0)    continue;
            mp.put(nums[i], mp.getOrDefault(nums[i], 0)+1);

            path.add(nums[i]);
            backtracking(i+1, res, path, nums);
            path.removeLast();
        }
    }
}
```
### [《代码随想录》回溯算法：全排列](https://notes.kamacoder.com/questions/502034)
#### 代码随想录算法训练营Day31 | 491.46.47.332.51.37.

```java
// 代码随想录
// if (path.size() == nums.length) 不需要idx，但这次要return，因为只需要叶子
// 时间 On x n!
// 空间 On x n!
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        boolean[] used = new boolean[nums.length];

        backtracking(res, path, used, nums);
        return res;
    }

    public void backtracking(List<List<Integer>> res, List<Integer> path, boolean[] used, int[] nums) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return; // 注意return，只需要收集叶子节点
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i] == false) {
                path.add(nums[i]); used[i] = true;
                backtracking(res, path, used, nums);
                path.removeLast(); used[i] = false;
            }
        }
    }
}
```
### [《代码随想录》回溯算法：全排列II](https://notes.kamacoder.com/questions/502035)
#### 代码随想录算法训练营Day31 | 491.46.47.332.51.37.

```java
// 代码随想录
// Arrays.sort(nums);  // 关键
// used[i] == true，因为for循环从头到尾，需要跳过已使用的元素
// used[i - 1] == true，说明同一树枝nums[i - 1]使用过，没关系，需要你
// used[i - 1] == false，说明同一树层nums[i - 1]使用过，同一树层，相同元素的作用是等价的，因此则直接跳过
// 时间 On x n!
// 空间 On x n!
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        Arrays.sort(nums);  // 关键
        backtracking(res, path, used, nums);
        return res;
    }

    public void backtracking(List<List<Integer>> res, List<Integer> path, boolean[] used, int[] nums) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            // used[i] == true，因为for循环从头到尾，需要跳过已使用的元素
            // used[i - 1] == true，说明同一树枝nums[i - 1]使用过，没关系，需要你
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过，同一树层，相同元素的作用是等价的，因此则直接跳过
            if (used[i]==true || (i>0 && nums[i]==nums[i-1] && used[i-1]==false)) continue;

            path.add(nums[i]); used[i] = true;
            backtracking(res, path, used, nums);
            path.removeLast(); used[i] = false;
        }

    }
}
```
### [《代码随想录》回溯算法：回溯算法去重问题的另一种写法](https://notes.kamacoder.com/questions/502036)
#### 代码随想录算法训练营Day31 | 491.46.47.332.51.37.

**性能分析**

需要注意的是：**使用set去重的版本相对于used数组的版本效率都要低很多**，大家在leetcode上提交，能明显发现。

原因在[回溯算法：递增子序列 (opens new window)](https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html)中也分析过，主要是因为程序运行的时候对unordered_set 频繁的insert，unordered_set需要做哈希映射（也就是把key通过hash function映射为唯一的哈希值）相对费时间，而且insert的时候其底层的符号表也要做相应的扩充，也是费时的。

**而使用used数组在时间复杂度上几乎没有额外负担！**

**使用set去重，不仅时间复杂度高了，空间复杂度也高了**，在[本周小结！（回溯算法系列三） (opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201112%E5%9B%9E%E6%BA%AF%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)中分析过，组合，子集，排列问题的空间复杂度都是O(n)，但如果使用set去重，空间复杂度就变成了O(n^2)，因为每一层递归都有一个set集合，系统栈空间是n，每一个空间都有set集合。
那有同学可能疑惑 用used数组也是占用O(n)的空间啊？
used数组可是全局变量，每层与每层之间公用一个used数组，所以空间复杂度是O(n + n)，最终空间复杂度还是O(n)。
### [《代码随想录》回溯算法：重新安排行程](https://notes.kamacoder.com/questions/502037)
#### 代码随想录算法训练营Day31 | 491.46.47.332.51.37.

```java
// 代码随想录
// Map<出发机场, TreeMap<到达机场, 航班次数>> targets
// 时间 On!（？）
// 空间 On
class Solution {
    // Map<出发机场, TreeMap<到达机场, 航班次数>> targets
    // TreeMap会根据键的自然顺序（对于字符串来说就是字典顺序）对键进行排序
    private Map<String, TreeMap<String, Integer>> targets = new HashMap<>();

    public List<String> findItinerary(List<List<String>> tickets) {
        List<String> result = new ArrayList<>();
        for (List<String> ticket : tickets) {
            String from = ticket.get(0);
            String to = ticket.get(1);
            targets.computeIfAbsent(from, k -> new TreeMap<>()).put(to, targets.get(from).getOrDefault(to, 0) + 1);
        }
        result.add("JFK"); // 起始机场
        backtracking(tickets.size(), result);
        return result;
    }

    private boolean backtracking(int ticketNum, List<String> result) {
        if (result.size() == ticketNum + 1) { // 站点数 = 机票数 + 1
            return true;
        }

        String lastAirport = result.get(result.size() - 1);
        if (targets.containsKey(lastAirport)) {
            for (Map.Entry<String, Integer> entry : targets.get(lastAirport).entrySet()) {
                String targetAirport = entry.getKey();
                int count = entry.getValue();
                if (count > 0) {
                    result.add(targetAirport);
                    entry.setValue(count - 1);
                    if (backtracking(ticketNum, result)) {
                        return true;
                    }
                    result.remove(result.size() - 1);
                    entry.setValue(count);
                }
            }
        }
        return false;
    }
}
```
### [《代码随想录》回溯算法：N皇后](https://notes.kamacoder.com/questions/502038)
#### 代码随想录算法训练营Day31 | 491.46.47.332.51.37.

```java
// 代码随想录
// 按row回溯，isValid判断上、左上、右上
// 时间 On!
// 空间 On^2
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> res = new ArrayList<>();
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }

        dfs(0, n, chessboard, res);
        return res;
    }

    public void dfs(int row, int n, char[][] chessboard, List<List<String>> res) {
        if (row == n) {
            res.add(Array2List(chessboard));
            return;
        }

        for (int col = 0; col < n; col++) {
            if (isValid(chessboard, row, col, n)) {
                chessboard[row][col] = 'Q';
                dfs(row + 1, n, chessboard, res);
                chessboard[row][col] = '.';
            }
        }
    }

    List<String> Array2List(char[][] chessboard) {
        List<String> path = new ArrayList<>();
        for (char[] c : chessboard) {
            path.add(String.copyValueOf(c));
        }
        return path;
    }

    boolean isValid(char[][] chessboard, int row, int col, int n) {
        for (int i = 0; i < row; i++) 
            if (chessboard[i][col] == 'Q') 
                return false;
        
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) 
            if (chessboard[i][j] == 'Q') 
                return false;
        
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) 
            if (chessboard[i][j] == 'Q') 
                return false;

        return true;
    }
}
```
### [《代码随想录》回溯算法：解数独](https://notes.kamacoder.com/questions/502039)
#### 代码随想录算法训练营Day31 | 491.46.47.332.51.37.

```java
// 代码随想录
// N皇后变式
// 时间 O9^n
// 空间 On
class Solution {
    public void solveSudoku(char[][] board) {
        backtracking(board);
    }

    private boolean backtracking(char[][] board){
        //一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！
        for (int i = 0; i < 9; i++){ // 遍历行
            for (int j = 0; j < 9; j++){ // 遍历列
                if (board[i][j] != '.'){ // 跳过原始数字
                    continue;
                }
                for (char k = '1'; k <= '9'; k++){ // (i, j) 这个位置放k是否合适
                    if (isValidSudoku(i, j, k, board)){
                        board[i][j] = k;
                        if (backtracking(board)){ // 如果找到合适一组立刻返回
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                // 9个数都试完了，都不行，那么就返回false
                return false;
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
            }
        }
        // 遍历完没有返回false，说明找到了合适棋盘位置了
        return true;
    }

    /**
     * 判断棋盘是否合法有如下三个维度:
     *     同行是否重复
     *     同列是否重复
     *     9宫格里是否重复
     */
    private boolean isValidSudoku(int row, int col, char val, char[][] board){
        // 同行是否重复
        for (int i = 0; i < 9; i++){
            if (board[row][i] == val){
                return false;
            }
        }
        // 同列是否重复
        for (int j = 0; j < 9; j++){
            if (board[j][col] == val){
                return false;
            }
        }
        // 9宫格里是否重复
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++){
            for (int j = startCol; j < startCol + 3; j++){
                if (board[i][j] == val){
                    return false;
                }
            }
        }
        return true;
    }
}
```
### [《代码随想录》回溯算法：回溯总结](https://notes.kamacoder.com/questions/502040)
#### 代码随想录算法训练营Day31 | 491.46.47.332.51.37.

##### 只要有递归就会有回溯
所以回溯法也经常和**二叉树遍历，深度优先搜索**混在一起，因为这两种方式都是用了递归。

##### 回溯算法能解决如下问题
- 组合问题：N个数里面按一定规则找出k个数的集合
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 棋盘问题：N皇后，解数独等等

##### 回溯法的模板
```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



## 贪心算法
### [《代码随想录》贪心算法：贪心算法理论基础](https://notes.kamacoder.com/questions/502041)
#### 代码随想录算法训练营Day32 | 455.376.53.

贪心算法一般分为如下四步：
- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解
### [《代码随想录》贪心算法：分发饼干](https://notes.kamacoder.com/questions/502042)
#### 代码随想录算法训练营Day32 | 455.376.53.

```java
// 代码随想录
// 排序，遍历饼干，小饼干先喂饱小胃口
// 时间 Onlogn
// 空间 O1
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int gIdx = 0;
        int res = 0;
        // 遍历饼干，小饼干先喂饱小胃口
        for (int sIdx = 0; sIdx < s.length && gIdx < g.length; sIdx++) {
            if (s[sIdx] >= g[gIdx]) {
                gIdx++;
                res++;
            }
        }
        return res;
    }
}
```
### [《代码随想录》贪心算法：摆动序列](https://notes.kamacoder.com/questions/502043)
#### 代码随想录算法训练营Day32 | 455.376.53.

```java
// 代码随想录
// 贪心 if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) // 等于0的情况表示初始时的preDiff
// 时间 On^2
// 空间 On
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int curDiff = 0;
        int preDiff = 0;
        int count = 1;

        for (int i = 1; i < nums.length; i++) {
            curDiff = nums[i] - nums[i - 1];
            // 如果当前差值和上一个差值为一正一负
            // 等于0的情况表示初始时的preDiff
            if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
                count++;
                preDiff = curDiff;
            }
        }

        return count;
    }
}
```
### [《代码随想录》贪心算法：最大子序和](https://notes.kamacoder.com/questions/502044)
#### 代码随想录算法训练营Day32 | 455.376.53.

```java
// Hot100、代码随想录
// 贪心，前面加起来是副作用则重新开始
// 时间 On
// 空间 O1
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int res = nums[0];
        int sum = 0;

        for (int num : nums) {
            if (sum < 0) {
                sum = num;
            } else {
                sum += num;
            }
            res = Math.max(res, sum);
        }
        
        return res;
    }
}
```
### [《代码随想录》贪心算法：买卖股票的最佳时机II](https://notes.kamacoder.com/questions/502045)
#### 代码随想录算法训练营Day33 | 122.55.45.1005.

```java
// 代码随想录
// 二维dp数组，0表示当天不持有股票、1表示当天持有股票
// 时间 On
// 空间 On
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];

        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for(int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]);  // 前一天就没持有 or 当天卖出去
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);  // 前一天就持有 or 当天买入了
        }

        return dp[n-1][0];
    }
}
```
### [《代码随想录》贪心算法：跳跃游戏](https://notes.kamacoder.com/questions/502046)
#### 代码随想录算法训练营Day33 | 122.55.45.1005.

```java
// 代码随想录
// 贪心，遍历过程根据nums[i]不断更新far
// 时间 On
// 空间 O1
class Solution {
    public boolean canJump(int[] nums) {
        int maxDis = 0;
        for (int i = 0; i < nums.length; i++) {
            if(i > maxDis)    return false;
            maxDis = Math.max(maxDis, i+nums[i]);
            if (maxDis >= nums.length-1)    break;
        }
        return true;
    }
}
```
### [《代码随想录》贪心算法：跳跃游戏II](https://notes.kamacoder.com/questions/502047)
#### 代码随想录算法训练营Day33 | 122.55.45.1005.

```java
// 代码随想录、每日一题
// 贪心，i < n-1
// 时间 On
// 空间 O1
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int maxJump = 0;
        int curJump = 0;
        int res = 0;

        for (int i = 0; i < n-1; i++) {
            maxJump = Math.max(maxJump, i+nums[i]);
            if (i == curJump) {
                res++;
                curJump = maxJump;
            }
        }

        return res;
    }
}
```
### [《代码随想录》贪心算法：K次取反后最大化的数组和](https://notes.kamacoder.com/questions/502048)
#### 代码随想录算法训练营Day33 | 122.55.45.1005.

```java
// 代码随想录
// 按绝对值逆序排序，遍历负变正，k还有余反转最小的
// 时间 Onlogn
// 空间 O1
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        int res = 0;
        nums = IntStream.of(nums)
             .boxed()
             .sorted((o1, o2) -> Math.abs(o2) - Math.abs(o1))
             .mapToInt(Integer::intValue).toArray();
        
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] <= 0 && k > 0) {
                nums[i] = -nums[i];
                k--;
            }
                
        }
        if (k % 2 == 1) 
            nums[nums.length - 1] = -nums[nums.length - 1];
        
        return Arrays.stream(nums).sum();
    }
}
```
### [《代码随想录》贪心算法：加油站](https://notes.kamacoder.com/questions/502049)
#### 代码随想录算法训练营Day30 | 93.78.90.

```java
// 代码随想录
// i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。
// 时间 On
// 空间 O1

class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int res = 0;

        int curSum = 0, totalSum = 0;
        for (int i = 0; i < gas.length; i++) {
            curSum += gas[i]-cost[i];
            totalSum += gas[i]-cost[i];
            if (curSum < 0) {
                res = i+1;
                curSum = 0;
            }
        }

        if (totalSum < 0)   return -1;
        return res;
    }

}
```
### [《代码随想录》贪心算法：分发糖果](https://notes.kamacoder.com/questions/502050)
#### 代码随想录算法训练营Day34 | 134.135.860.406.

```java
// 代码随想录
// 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
// 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。
// 时间 On
// 空间 On
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int[] candy = new int[n];
        Arrays.fill(candy, 1);

        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i-1])
                candy[i] = candy[i-1]+1;
        }

        for (int i = n-2; i >=0; i--) {
            if (ratings[i] > ratings[i+1])
                candy[i] = Math.max(candy[i], candy[i+1]+1);
        }

        return Arrays.stream(candy).sum();
    }
}
```
### [《代码随想录》贪心算法：柠檬水找零](https://notes.kamacoder.com/questions/502051)
#### 代码随想录算法训练营Day34 | 134.135.860.406.

```java
// 代码随想录
/*
    情况一：账单是5，直接收下。
    情况二：账单是10，消耗一个5，增加一个10
    情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5
        账单是20的情况，为什么要优先消耗一个10和一个5呢？
        因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！
*/
// 时间 On
// 空间 O1
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0;
        int ten = 0;
        
        for (int i = 0; i < bills.length; i++) {
            if (bills[i] == 5) {
                five++;
            } else if (bills[i] == 10) {
                five--;
                ten++;
            } else if (bills[i] == 20) {
                if (ten > 0) {
                    ten--;
                    five--;
                } else {
                    five -= 3;
                }
            }
            if (five < 0 || ten < 0) return false;
        }

        return true;
    }
}
```
### [《代码随想录》贪心算法：根据身高重建队列](https://notes.kamacoder.com/questions/502052)
#### 代码随想录算法训练营Day34 | 134.135.860.406.

```java
// 代码随想录
// 如果两个维度一起考虑一定会顾此失彼
// 身高一定是从大到小排（身高相同的话则k小的站前面）
// 时间 On^2
// 空间 On
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];   // 身高相同，按k升序
            return b[0] - a[0];   // 先按身高降序
        });

        LinkedList<int[]> res = new LinkedList<>();

        for (int[] p : people) {
            res.add(p[1], p);   // Linkedlist.add(index, value)，會將value插入到指定index裡
        }

        return res.toArray(new int[people.length][]);
    }
}
```
### [《代码随想录》贪心算法：根据身高重建队列（vector原理讲解）](https://notes.kamacoder.com/questions/502053)
#### 代码随想录算法训练营Day34 | 134.135.860.406.

```java

```
### [《代码随想录》贪心算法：用最少数量的箭引爆气球](https://notes.kamacoder.com/questions/502054)
#### 代码随想录算法训练营Day35 | 452.435.763.

```java
// 代码随想录
// 遍历顺序：按照起始位置排序，那么就从前向后遍历气球数组
// 箭：如果气球重叠了，重叠气球中右边边界的最小值之前的区间一定需要一个弓箭
// 过程：更新重叠区域的最小右边界
// 时间 Onlogn
// 空间 On
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));
        
        int count = 1;  // points 不为空至少需要一支箭
        
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > points[i - 1][1]) {  // 不重叠
                count++; // 需要一支箭
            } else {  // 重叠
                points[i][1] = Math.min(points[i][1], points[i - 1][1]); // 更新重叠气球最小右边界
            }
        }
        
        return count;
    }
}
```
### [《代码随想录》贪心算法：无重叠区间](https://notes.kamacoder.com/questions/502055)
#### 代码随想录算法训练营Day35 | 452.435.763.

```java
// 代码随想录
// 按照左边界排序，如果重叠，remove++，并且借助intervals[i][1]更新最小右边界
// 时间 Onlogn
// 空间 On
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a,b)-> {
            return Integer.compare(a[0],b[0]);
        });

        int remove = 0; // 不是1
        
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] < intervals[i - 1][1]) {  // 重叠，注意[1,2][2,3]不算重叠
                remove++;
                intervals[i][1] = Math.min(intervals[i][1], intervals[i - 1][1]); // 利用intervals[i][1]更新重叠最小右边界
            }
        }

        return remove;
    }
}
```
### [《代码随想录》贪心算法：划分字母区间](https://notes.kamacoder.com/questions/502056)
#### 代码随想录算法训练营Day35 | 452.435.763.

```java
// 代码随想录
// 第一次遍历：last[]记录每个字母最后出现idx
// 第二次遍历：遍历过程不断更新end，发现i达到end则保存到res并重置start
// 时间 On
// 空间 O1
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        int start = 0, end = 0;
        List<Integer> res = new ArrayList();

        for (int i = 0; i < s.length(); i++) {
            last[s.charAt(i)-'a'] = i;
        }

        for (int i = 0; i < s.length(); i++) {
            end = Math.max(end, last[s.charAt(i)-'a']);
            if (i == end) {
                res.add(end-start+1);
                start = end+1;
            }
        }

        return res;
    }
}
```
### [《代码随想录》贪心算法：合并区间](https://notes.kamacoder.com/questions/502057)
#### 代码随想录算法训练营Day36 | 56.738.968.

```java
// Hot100、代码随想录
// 按L升序排序，对于每个区间，判断L与res右的关系，加入区间或更新res右
// 时间 Onlogn
// 空间 On
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> res = new ArrayList<>();
        int n = intervals.length;
        if (n == 0) return new int[n][];

        Arrays.sort(intervals, (a, b) -> {
            return a[0] - b[0];
        });

        res.add(intervals[0]);

        for (int i = 1; i < n; i++) {
            int L = intervals[i][0];
            int R = intervals[i][1];
            if (L > res.getLast()[1]) {
                res.add(intervals[i]);
            } else {
                res.getLast()[1] = Math.max(res.getLast()[1], R);
            }
        }

        return res.toArray(new int[res.size()][]);
    }
}
```
### [《代码随想录》贪心算法：单调递增的数字](https://notes.kamacoder.com/questions/502058)
#### 代码随想录算法训练营Day36 | 56.738.968.

```java
// 代码随想录
// 例如：98，一旦出现前 > 后，首先想让前--，然后后给为9（保证整个数小于等于n），这样这个整数就是89
// 从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -> 329 -> 299
// 时间 Ok，其中k表示n的位数
// 空间 Ok，其中k表示n的位数
class Solution {
    public int monotoneIncreasingDigits(int n) {
        String s = String.valueOf(n);
        char[] chars = s.toCharArray();

        int start = s.length(); // start后面全变9
        for (int i = s.length() - 2; i >= 0; i--) {
            if (chars[i] > chars[i + 1]) {
                chars[i]--;
                start = i+1;
            }
        }
        for (int i = start; i < s.length(); i++) {
            chars[i] = '9';
        }
        return Integer.parseInt(String.valueOf(chars));
    }
}
```
### [《代码随想录》贪心算法：监控二叉树](https://notes.kamacoder.com/questions/502059)
#### 代码随想录算法训练营Day36 | 56.738.968.

```java
// 代码随想录
/* 从下往上看（后序遍历）
        局部最优：让叶子节点的父节点安摄像头，所用摄像头最少
        整体最优：全部摄像头数量所用最少

    0：该节点无覆盖（空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了）
    1：本节点有摄像头（空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了）
    2：本节点有覆盖（排除法，空节点的状态只能是有覆盖）

    情况1：左右节点都有覆盖，那么父节点是无覆盖 return 0
    情况2：左右节点至少有一个无覆盖，那么摄像头++，并且放摄像头 return 1
    情况3：左右节点至少有一个摄像头，那么其父节点是覆盖 return 2
    情况4：头结点没有覆盖，result++
*/
// 时间 On
// 空间 On
class Solution {
    int res = 0;

    public int minCameraCover(TreeNode root) {
        // 情况4：头结点没有覆盖，result++
        if (minCame(root) == 0) res++;
        return res;
    }

    public int minCame(TreeNode root) {
        if (root == null) // 空节点默认为有覆盖状态
            return 2;

        int left = minCame(root.left);  // 左
        int right = minCame(root.right);    // 右

        // 中
        if (left == 2 && right == 2) {  // 情况1：左右节点都有覆盖，那么父节点是无覆盖 return 0
            return 0;
        } else if (left == 0 || right == 0) {   // 情况2：左右节点至少有一个无覆盖，那么摄像头++，并且放摄像头 return 1
            res++;
            return 1;
        } else {    // 情况3：左右节点至少有一个摄像头，那么其父节点是覆盖 return 2
            return 2;
        }
    }
}
```
### [《代码随想录》贪心算法：贪心算法总结篇](https://notes.kamacoder.com/questions/502060)
#### 代码随想录算法训练营Day36 | 56.738.968.

1. 贪心解决股票问题
2. 贪心解决两个维度权衡问题
3. 贪心解决区间问题
4. 贪心解决其他问题
## 动态规划
### [《代码随想录》动态规划：动态规划理论基础](https://notes.kamacoder.com/questions/502061)
#### 代码随想录算法训练营Day37 | 509.70.746.

##### 动态规划解决的问题
- **基础题目**
- **背包问题**
	- 01背包
	- 完全背包
	- 多重背包
- **打家劫舍**
- **股票问题**
- **子序列问题**
	- 子序列（不连续）
	- 子序列（连续）
	- 编辑距离
	- 回文

---

##### 动态规划和贪心的区别
动态规划，英文：Dynamic Programming，简称DP
- 动态规划中每一个状态一定是**由上一个状态推导**出来的
- 贪心**没有状态推导**，而是从局部直接选最优的

---

##### 动态规划的解题步骤
1. 确定dp数组以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

---

##### 动态规划的Debug步骤
**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**
- 这道题目我举例推导状态转移公式了么？
- 我打印dp数组的日志了么？
- 打印出来了dp数组和我想的一样么？



### [《代码随想录》动态规划：斐波那契数](https://notes.kamacoder.com/questions/502062)
#### 代码随想录算法训练营Day37 | 509.70.746.

```java
// 代码随想录
// 动态规划，压缩数组后for (int i = 1; i < n; i++)
// 时间 On
// 空间 O1
class Solution {
    public int fib(int n) {
        if (n < 2)  return n;
        int a = 0, b = 1, c = 0;
        for (int i = 1; i < n; i++) {
            c = a+b;
            a = b;
            b = c;
        }
        return c;
    }
}
```
### [《代码随想录》动态规划：爬楼梯](https://notes.kamacoder.com/questions/502063)
#### 代码随想录算法训练营Day37 | 509.70.746.

```java
// 代码随想录
// 不考虑dp[0]的斐波那契数列
// 时间 On
// 空间 On
class Solution {
    public int climbStairs(int n) {
        if (n < 2)  return n;
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i<=n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        } 
        return dp[n];
    }
}
```
### [《代码随想录》动态规划：使用最小花费爬楼梯](https://notes.kamacoder.com/questions/502064)
#### 代码随想录算法训练营Day37 | 509.70.746.

```java
// 代码随想录
// 动态规划，最好要到达第n个台阶而不是第n-1个哦
// 时间 On
// 空间 O1
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[3];

        dp[0] = 0;
        dp[1] = 0;

        for (int i = 2; i <= n; i++) {
            dp[2] = Math.min(dp[0] + cost[i - 2], dp[1] + cost[i - 1]);
            dp[0] = dp[1];
            dp[1] = dp[2];
        }

        return dp[2];
    }
}
```
### [《代码随想录》动态规划：不同路径](https://notes.kamacoder.com/questions/502065)
#### 代码随想录算法训练营Day38 | 62.63.343.96.

```java
// 代码随想录
/* 动态规划五部曲
    1、dp数组及下标的含义：从(0,0)出发，到(i,j)有dp[i][j]条不同的路径
    2、递推公式：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    3、dp数组初始化：dp[i][0]和dp[0][j]都是1
    4、遍历顺序：从其上方和左方推导而来
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int uniquePaths(int m, int n) {
        // 1、dp数组及下标的含义：从(0,0)出发，到(i,j)有dp[i][j]条不同的路径
        int[][] dp = new int[m][n];

        // 3、dp数组初始化：dp[i][0]和dp[0][j]都是1
        for (int i = 0; i < m; i++)
            dp[i][0] = 1;
        for (int j = 0; j < n; j++)
            dp[0][j] = 1;

        // 4、遍历顺序：从其上方和左方推导而来
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 2、递推公式：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        
        return dp[m - 1][n - 1];
    }
}
```
### [《代码随想录》动态规划：不同路径II](https://notes.kamacoder.com/questions/502066)
#### 代码随想录算法训练营Day38 | 62.63.343.96.

##### 动态规划
```java
// 每日一题、代码随想录
/* 动态规划五部曲
    1、dp数组及下标的含义：从(0,0)出发，到(i,j)有dp[i][j]条不同的路径
    2、递推公式：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，注意(i, j)如果就是障碍的话应该就保持初始状态0
    3、dp数组初始化：如果(i, 0)这条边有了障碍之后，障碍之后都是走不到的位置0
    4、遍历顺序：从左到右
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        // 1、dp数组及下标的含义：从(0,0)出发，到(i,j)有dp[i][j]条不同的路径
        int[][] dp = new int[m][n];

        // 3、dp数组初始化：如果(i, 0)这条边有了障碍之后，障碍之后都是走不到的位置0
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++)  dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++)  dp[0][j] = 1;

        // 4、遍历顺序：从左到右
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 2、递推公式：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，注意(i, j)如果就是障碍的话应该就保持初始状态0
                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;
            }
        }
        
        return dp[m - 1][n - 1];
    }
}
```

##### 状态压缩
```java
// 每日一题、代码随想录
/* 动态规划五部曲
    1、dp数组及下标的含义：从(0,0)出发，到(i,j)有dp[i][j]条不同的路径
    2、递推公式：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，注意(i, j)如果就是障碍的话应该就保持初始状态0
    3、dp数组初始化：如果(i, 0)这条边有了障碍之后，障碍之后都是走不到的位置0
    4、遍历顺序：从左到右
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 On
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[] dp = new int[n];

        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++)  dp[j] = 1;  // 仅考虑了第一行有障碍物

        for (int i = 1; i < m; i++) {
            for (int j = 0; j < n; j++) {   // j从0开始，为了考虑到第一列也有可能有障碍物的情况
                if (obstacleGrid[i][j] == 1)
                    dp[j] = 0;
                else if (j != 0)    // 保证j-1有意义
                    dp[j] += dp[j - 1];
            }
        }

        return dp[n - 1];
    }
}
```


### [《代码随想录》动态规划：整数拆分](https://notes.kamacoder.com/questions/502067)
#### 代码随想录算法训练营Day38 | 62.63.343.96.

```java
// 代码随想录
/* 动态规划五部曲
    1、dp数组及下标的含义：分拆数字i，可以得到的最大乘积为dp[i]
    2、递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))
        枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0，求最大乘积就没有意义了
        拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的
    3、dp数组初始化：dp[2] = 1
    4、遍历顺序：从前向后
    5、举例推导dp数组
*/
// 时间 On^2
// 空间 On
class Solution {
    public int integerBreak(int n) {
        // 1、dp数组及下标的含义：分拆数字i，可以得到的最大乘积为dp[i]
        int[] dp = new int[n + 1];

        // 3、dp数组初始化：dp[2] = 1
        dp[2] = 1;

        // 4、遍历顺序：从前向后
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j <= i / 2; j++) {  
                // j <= i / 2 是因为要想拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
                // dp[i]不断更新为max
                // j * (i - j) 是把 i 拆分为两个数，再相乘
                // j * dp[i - j]是借助之前结果将 i 拆分成两个以上的数，再相乘
            }
        }

        return dp[n];
    }
}
```

---
证明：
`j <= i / 2` 是因为要想拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的

![image.png](http://cdn.notes.kamacoder.com/8dd9cb80-49f6-4333-b4aa-05e9673c80eb.png)
### [《代码随想录》动态规划：不同的二叉搜索树](https://notes.kamacoder.com/questions/502068)
#### 代码随想录算法训练营Day38 | 62.63.343.96.

```java
// 代码随想录
/* 动态规划五部曲
    1、dp数组及下标的含义：1到i为节点组成的二叉搜索树的个数为dp[i]
    2、递推公式：dp[i] += dp[j - 1] * dp[i - j];
    3、dp数组初始化：dp[0] = 1
    4、遍历顺序：i∈[1,n]、j∈[1,i]
    5、举例推导dp数组
*/
// 时间 On^2
// 空间 On
class Solution {
    public int numTrees(int n) {
        // 1、dp数组及下标的含义：1到i为节点组成的二叉搜索树的个数为dp[i]
        int[] dp = new int[n + 1];

        // 3、dp数组初始化：dp[0] = 1
        dp[0] = 1;

        // 4、遍历顺序：遍历每一个数作为头结点i∈[1,n]、j∈[1,i]
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                // 2、递推公式：dp[i] += dp[j - 1] * dp[i - j];
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }

        return dp[n];
    }
}
```
### [《代码随想录》动态规划：01背包理论基础之一](https://notes.kamacoder.com/questions/502069)
#### 代码随想录算法训练营Day39 | 416.

##### 01 背包 二维数组
有**n件物品**和一个**容量w的背包**
第i件物品的重量是weight[i]，得到的价值是value[i] 
**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

1. 确定dp数组以及下标的含义：`dp[i][j]`表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少
2. 确定递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`
3. dp数组初始化：
	- `dp[i][0]`，无论是选取哪些物品，背包价值总和一定为0
	-  当`j >= weight[0]`时，`dp[0][j]` 应该是`value[0]`
4. 确定遍历顺序：左上角
	- Z：外层遍历物品i，内层遍历背包容量j（优先填满第一行）
	- N：外层遍历背包容量j，内层遍历物品i（优先填满第一列）
5. 举例推导dp数组

### [《代码随想录》动态规划：01背包理论基础之二](https://notes.kamacoder.com/questions/502070)
#### 代码随想录算法训练营Day39 | 416.

##### 01 背包 状态压缩的滚动数组
有**n件物品**和一个**容量w的背包**
第i件物品的重量是weight[i]，得到的价值是value[i] 
**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

1. **确定dp数组以及下标的含义：** `dp[j]`表示：容量为`j`的背包所背的物品价值可以最大为`dp[j]`
2. **确定递推公式：** `dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`
3. **dp数组初始化：** `dp[0]=0`
4. **确定遍历顺序：** Z：外层遍历物品i，内层**倒序**遍历背包容量j（优先**倒序**填满第一行）
	- 	```java
		for(int i = 0; i < weight.size(); i++) { // 遍历物品i
    		for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量j
        		dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    		}
		}
		```
	- **倒序**是为了保证物品i只被放入一次。
		- Q：为什么二维dp数组遍历的时候不用倒序呢？
		- A：因为对于二维dp，`dp[i][j]`都是通过上一层即`dp[i - 1][j]`计算而来，本层的`dp[i][j]`并**不会被覆盖**！
		- 不可以先遍历背包容量嵌套遍历物品
5. **举例推导dp数组**

### [《代码随想录》动态规划：分割等和子集](https://notes.kamacoder.com/questions/502071)
#### 代码随想录算法训练营Day39 | 416.

```java
// 代码随想录
/* 01背包
    1、dp数组及下标的含义：容量为j的背包所背物品价值最大可以为dp[j]
    2、递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
    3、dp数组初始化：
        如果题目给的价值都是正整数，那么非0下标都初始化为0就可以了
        如果题目给的价值有负数，那么非0下标就要初始化为负无穷。
    4、遍历顺序：
        因为使用状态压缩的一维滚动数组，
        所以外层遍历物品i，内层倒序遍历背包容量j
    5、举例推导dp数组
*/
// 时间 On^2
// 空间 On
class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        int sum = 0;
        for (int num : nums)
            sum += num;
        if (sum % 2 == 1)
            return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];

        for (int i = 0; i < n; i++) {
            for (int j = target; j >= nums[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
            if (dp[target] == target)
                return true;
        }

        return dp[target] == target;
    }
}
```
### [《代码随想录》动态规划：最后一块石头的重量II](https://notes.kamacoder.com/questions/502072)
#### 代码随想录算法训练营Day41 | 1049.494.474.

```java
// 代码随想录
/* 01背包
    1、dp数组及下标的含义：容量为j的背包所背物品重量最大可以为dp[j]
    2、递推公式：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
    3、dp数组初始化：
        因为提示中给出1 <= stones.length <= 30，1 <= stones[i] <= 1000，所以最大重量就是30 * 1000
        而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了
        因为重量都不会是负数，所以dp[j]都初始化为0就可以
    4、遍历顺序：
        因为使用状态压缩的一维滚动数组，
        所以外层遍历物品i，内层倒序遍历背包容量j
    5、举例推导dp数组
*/
// 时间 Omxn，其中m是石头总重量的一半，n为石头块数
// 空间 On
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int n = stones.length;
        int sum = 0;
        for (int stone : stones)
            sum += stone;
        int target = sum >> 1;
        int[] dp = new int[target + 1];

        for (int i = 0; i < n; i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }

        return (sum - dp[target]) - dp[target];
    }
}
```
### [《代码随想录》动态规划：目标和](https://notes.kamacoder.com/questions/502073)
#### 代码随想录算法训练营Day41 | 1049.494.474.

```java
// 代码随想录
/* 01背包
    假设加法的总和为x，那么减法对应的总和就是sum - x
    所以我们要求的是 x - (sum - x) = target，即x = (target + sum) / 2
    此时问题就转化为，用nums装满容量为x的背包，有几种方法
    1、dp数组及下标的含义：填满容量为j的背包有dp[j]种方法
    2、递推公式：dp[j] += dp[j - nums[i]];
        容量为j的背包，如果不放物品i有几种方法：dp[i-1][j]
        容量为j的背包，如果放物品i有几种方法：dp[i-1][j-nums[i]]，即物品i预定一个位置
    3、dp数组初始化：
        dp[0]=1 ,表示装满背包为0的方法有一种，即放0件物品
    4、遍历顺序：
        因为使用状态压缩的一维滚动数组，
        所以外层遍历物品i，内层倒序遍历背包容量j
    5、举例推导dp数组
*/
// 时间 Omxn，其中m为背包容量，n为正数个数
// 空间 On
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        int sum = 0;
        for (int num : nums)
            sum += num;
        // 剪枝：两种无解的情况
        if (Math.abs(target) > sum || (target + sum) % 2 == 1) {
            return 0;
        }

        int bagSize = (target + sum) / 2;
        int[] dp = new int[bagSize + 1];
        dp[0] = 1;

        for (int i = 0; i < n; i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
}
```
### [《代码随想录》动态规划：一和零](https://notes.kamacoder.com/questions/502074)
#### 代码随想录算法训练营Day41 | 1049.494.474.

```java
// 代码随想录
/* 二维01背包
    本题中strs 数组里的元素就是物品，每个物品都是一个！
    而m和n相当于是一个背包，两个维度的背包。
    1、dp数组及下标的含义：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]
    2、递推公式：dp[i][j] = max(dp[i][j], dp[i-zeroNum][j-oneNum] + 1);
        +1是因为两个维度都归纳于str一个物品
    3、dp数组初始化：
        01背包的dp数组初始化为0就可以
        因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖
    4、遍历顺序：外层遍历物品i，内层倒序遍历背包容量j
    5、举例推导dp数组
*/
// 时间 Okxmxn，其中k为strs长度
// 空间 Omxn
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];

        for (String str : strs) { // 外层遍历物品i
            int zeroNum = 0;
            int oneNum = 0;
            for (char c : str.toCharArray()) {
                if (c == '0') {
                    zeroNum++;
                } else {
                    oneNum++;
                }
            }
            for (int i = m; i >= zeroNum; i--) { // 内层倒序遍历背包容量j（0的维度）
                for (int j = n; j >= oneNum; j--) { // 内层倒序遍历背包容量j（1的维度）
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }

        return dp[m][n];
    }
}
```
### [《代码随想录》动态规划：完全背包理论基础](https://notes.kamacoder.com/questions/502075)
#### 代码随想录算法训练营Day42 | 518.377.70

##### 完全背包
有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。
**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

---

##### 1、确定dp数组以及下标的含义
`dp[i][j]` 表示从下标为`[0-i]`的物品，每个物品可以取**无限次**，放进容量为`j`的背包，价值总和最大是多少。

---

##### 2、确定递推公式
- 完全背包：`dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);`
- 01背包：`dp[i][j] = max(dp[i - 1][j], dp[i-1][j - weight[i]] + value[i]);`

**解释：**
求取 `dp[1][4]`有两种情况：
1. 放物品1
2. 还是不放物品1
![image.png](http://cdn.notes.kamacoder.com/0f3ba13e-460d-4408-933d-11a327433bc1.png)

**注意 这里和 01背包有所不同!**
- 01背包每个物品只有一个，既然空出物品1，那背包中也**不会再有物品1**
- 在完全背包中，物品是可以放**无限个**，所以 即使空出物品1空间重量，那背包中也**可能还有物品1**
- 所以此时我们依然考虑放 物品0 和 物品1 的最大价值即： `dp[1][1]`， 而不是`dp[0][1]`

---

##### 3、dp数组初始化
`dp[i][0]=0`，因为背包容量j为0
当 `j < weight[0]`的时候，`dp[0][j]=0` ，因为背包容量比编号0的物品重量还小。
当`j >= weight[0]`时，`dp[0][j]`如果能放下`weight[0]`的话，就一直装，每一种物品有无限个。
```java
for (int i = 1; i < weight.size(); i++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。
    dp[i][0] = 0;
}

// 正序遍历，如果能放下就一直装物品0
for (int j = weight[0]; j <= bagWeight; j++)
    dp[0][j] = dp[0][j - weight[0]] + value[0];
```

---

##### 4、确定遍历顺序
既可以 先遍历物品再遍历背包，也可以 先遍历背包再遍历物品

---

##### 5、举例推导dp数组

### [《代码随想录》动态规划：零钱兑换II](https://notes.kamacoder.com/questions/502076)
#### 代码随想录算法训练营Day42 | 518.377.70

##### 完全背包（组合）
**包装物品是排列**
- 如果求组合数就是外层for循环遍历物品，内层for遍历背包
- 如果求排列数就是外层for遍历背包，内层for循环遍历物品
```java
for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
}
```
在组合中因为内层遍历背包，直接从`nums[i]`开始即可
而排列导致外层遍历背包，所以需要条件判断`if (j >= nums[i])`

---

```java
// 代码随想录
/* 二维完全背包
    1、dp数组及下标的含义：使用下标为[0, i]的coins[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种组合方法
    2、递推公式：dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])
    3、dp数组初始化：
        dp[i][0]=1，用coins[i]装满容量为0的背包有几种组合方法，都有一种方法，即不装。
        dp[0][j]的含义：用即coins[0]装满背包容量为j的背包有几种组合方法， 如果j可以整除物品0，那么就有1种组合方法
    4、遍历顺序
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int change(int amount, int[] coins) {
        int[][] dp = new int[coins.length][amount + 1];

        for (int i = 0; i < coins.length; i++) {
            dp[i][0] = 1;
        }
        for (int j = coins[0]; j <= amount; j++) {
            dp[0][j] += dp[0][j - coins[0]];    // 易错
        }

        for (int i = 1; i < coins.length; i++) {
            for (int j = 1; j <= amount; j++) {
                if (j < coins[i])   // 背包容量不足：装不下coins[i]
                    dp[i][j] = dp[i - 1][j];
                else    // 背包容量充足：装coins[i] + 不装coins[i]
                    dp[i][j] = dp[i][j - coins[i]] + dp[i - 1][j];
            }
        }

        return dp[coins.length - 1][amount];
    }
}
```

---

##### 一维完全背包的遍历顺序
- 纯完全背包的两个for循环的先后顺序都是可以的，因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！
- 而本题要求凑成总和的组合数，元素之间明确要求没有顺序（**组合数**）
- 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）：**这种遍历顺序中dp[j]里计算的是组合数**
- 外层for循环遍历背包（金钱总额），内层for遍历物品（钱币）：**这种遍历顺序中dp[j]里计算的是排列数**（包装物品是排列）

```java
// 代码随想录
/* 一维完全背包
    1、dp数组及下标的含义：凑成总金额j的货币组合数为dp[j]
    2、递推公式：dp[j] += dp[j - coins[i]]
    3、dp数组初始化：装满背包容量为0 的方法是1，即不放任何物品，dp[0] = 1
    4、遍历顺序
        本题要求凑成总和的组合数，元素之间明确要求没有顺序（组合数）
        外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）：这种遍历顺序中dp[j]里计算的是组合数
    5、举例推导dp数组
*/
// 时间 Omxn，其中m是amount，n是coins的长度
// 空间 Om
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;

        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] += dp[j - coins[i]];
            }
        }

        return dp[amount];
    }
}
```
### [《代码随想录》动态规划：组合总和Ⅳ](https://notes.kamacoder.com/questions/502077)
#### 代码随想录算法训练营Day42 | 518.377.70

##### 完全背包（排列）
**包装物品是排列**
- 如果求组合数就是外层for循环遍历物品，内层for遍历背包
- 如果求排列数就是外层for遍历背包，内层for循环遍历物品
```java
for (int j = 0; j <= target; j++) { // 外层遍历背包
            for (int i = 0; i < n; i++) { // 内层遍历物品
                if (j >= nums[i])
                    dp[j] += dp[j - nums[i]];
            }
}
```
由于排列导致外层遍历背包，所以需要条件判断`if (j >= nums[i])`
而在组合中，无需这个判断，因为内层遍历背包直接从`nums[i]`开始即可

---


```java
// 代码随想录
/* 完全背包
    1、dp数组及下标的含义：凑成目标正整数为j的排列个数为dp[j]
    2、递推公式：
        dp[j]（考虑nums[i]）可以由 dp[j - nums[i]]（不考虑nums[i]） 推导出来。因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分。
        dp[j] += dp[j - nums[i]];
    3、dp数组初始化：dp[0]=1
    4、遍历顺序
        包装物品是排列
        如果求组合数就是外层for循环遍历物品，内层for遍历背包
        如果求排列数就是外层for遍历背包，内层for循环遍历物品
        本题要求的是排列
    5、举例推导dp数组
*/
// 时间 Omxn，其中m表示target
// 空间 Om

class Solution {
    public int combinationSum4(int[] nums, int target) {
        int n = nums.length;
        int[] dp = new int[target + 1];
        dp[0] = 1;

        for (int j = 0; j <= target; j++) { // 外层遍历背包
            for (int i = 0; i < n; i++) { // 内层遍历物品
                if (j >= nums[i])   // 判断很重要
                    dp[j] += dp[j - nums[i]];
            }
        }

        return dp[target];
    }
}
```
### [《代码随想录》动态规划：爬楼梯完全背包版本](https://notes.kamacoder.com/questions/502078)
#### 代码随想录算法训练营Day42 | 518.377.70

```java
// 代码随想录
/* 完全背包
    1、dp数组及下标的含义：j阶台阶有dp[j]种方法
    2、递推公式：dp[j] += dp[j-i]
    3、dp数组初始化：dp[0]=1
    4、遍历顺序：排列数，外层背包j，内层物品i，条件判断
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Om

import java.util.Scanner;

class Main {
    public static void main(String [] args){
        Scanner sc = new Scanner(System.in);
        int m, n;
        while (sc.hasNextInt()) {
            n = sc.nextInt();   // 背包
            m = sc.nextInt();   // 物品
    
            // 求排列问题，先遍历背包再遍历物品
            int[] dp = new int[n + 1];
            dp[0] = 1;
            
            for (int j = 1; j <= n; j++) {
                for (int i = 1; i <= m; i++) {
                    if (j - i >= 0) 
                        dp[j] += dp[j - i];
                }
            }
            
            System.out.println(dp[n]);
    }
}
}


```
### [《代码随想录》动态规划：零钱兑换](https://notes.kamacoder.com/questions/502079)
#### 代码随想录算法训练营Day43 | 322.279.139.

```java
// 代码随想录
/* 完全背包
    1、dp数组及下标的含义：凑足总额为j所需钱币的最少个数为dp[j]
    2、递推公式：
        凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1
        dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
        下标非0的元素都应该是最大值
    3、dp数组初始化：
        dp[0] = 0
    4、遍历顺序
        本题求钱币最小个数，并不强调集合是组合还是排列
    5、举例推导dp数组
*/
// 时间 Omxn，其中m表示amount，n表示coins的长度
// 空间 Om
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];

        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        for (int i = 0; i < coins.length; i++) {    // 外层遍历物品
            for (int j = coins[i]; j <= amount; j++) {  // 内层遍历背包
                if (dp[j - coins[i]] != Integer.MAX_VALUE)  // dp[j - coins[i]]是初始值 -> 目前凑不到dp[j - coins[i]] ->跳过
                    dp[j] = Math.min(dp[j], dp[j-coins[i]]+1);
            }
        }

        return dp[amount]==Integer.MAX_VALUE ? -1 : dp[amount]; // 有可能不存在哦
    }
}
```
### [《代码随想录》动态规划：完全平方数](https://notes.kamacoder.com/questions/502080)
#### 代码随想录算法训练营Day43 | 322.279.139.

```java
// 代码随想录
/* 完全背包
    完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？
    1、dp数组及下标的含义：和为j的完全平方数的最少数量为dp[j]
    2、递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);
    3、dp数组初始化：
        dp[0]=0
        非0下标的dp[j]一定要初始为最大值
    4、遍历顺序
        都可以
    5、举例推导dp数组
*/
// 时间 On根号n
// 空间 On
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n+1];

        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        for (int j = 1; j <= n; j++) {  // 外层背包
            for (int i = 1; i*i <= j; i++) {    // 内层物品
                dp[j] = Math.min(dp[j], dp[j-i*i]+1);
            }
        }

        return dp[n];
    }
}
```

### [《代码随想录》动态规划：单词拆分](https://notes.kamacoder.com/questions/502081)
#### 代码随想录算法训练营Day43 | 322.279.139.

```java
// 代码随想录
/* 完全背包
    1、dp数组及下标的含义：dp[i]为true表示[0,i-1]的字符串可以拆分为一个或多个在字典中出现的单词
    2、递推公式：
        if dp[i]==true && [i,j-1]的子串在字典里，那么dp[j]一定是true
    3、dp数组初始化：
        dp[0]就是递推的根基，dp[0]一定要为true
    4、遍历顺序
        s = "applepenapple", wordDict = ["apple", "pen"] 
        "apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，强调物品之间顺序
        排列要包装：先遍历背包，再遍历物品
    5、举例推导dp数组
*/
// 时间 On^3，substr返回子串的副本是O(n)的复杂度
// 空间 On
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        Set<String> wordSet = new HashSet<>(wordDict);
        boolean[] dp = new boolean[n+1];

        dp[0] = true;

        for (int j = 1; j <= n; j++) { // 外层遍历背包
            for (int i = 0; i < j; i++) {   // 内层遍历物品
                if(dp[i] && wordSet.contains(s.substring(i, j))) {
                    dp[j] = true;
                    break;  // 剪枝：能凑到true了，下一个背包容量
                }
            }
        }

        return dp[n];
    }
}
```
### [《代码随想录》动态规划：多重背包理论基础](https://notes.kamacoder.com/questions/502082)
#### 代码随想录算法训练营Day43 | 322.279.139.

有**N种物品**和一个**容量为V的背包**。第i种物品**最多有Mi件**，**重量是Ci** , **价值是Wi**

**求解：** 将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

把Mi件摊开，其实**就是一个01背包问题**，可以在01背包里面在加一个for循环遍历一个每种商品的数量。

---

```java
int[] dp = new int[bagWeight + 1];
for (int i = 0; i < n; i++) {	// 外层遍历物品
	for (int j = bagWeight; j >= weight[i]; j--) {	// 内层倒序遍历背包
		for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) {	// 额外遍历每种物品的个数
			dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);
		}
	}
}
return dp[bagWeight];
```

### [《代码随想录》动态规划：背包总结篇](https://notes.kamacoder.com/questions/502083)
#### 代码随想录算法训练营Day43 | 322.279.139.

##### 动规五部曲
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

---

##### 递推公式

- 问**能否能装满**背包或**最多装多少**：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])` 
	- 416.分割等和子集
	- 1049.最后一块石头的重量 II
- 问**装满**背包**有几种方法**：`dp[j] += dp[j - nums[i]] `
	- 494.目标和
	- 518.零钱兑换 II
	- 377.组合总和Ⅳ
	- 70.爬楼梯进阶版（完全背包）
- 问背包装满**最大价值**：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])` 
	- 474.一和零
- 问装满背包所有**物品最小个数**：`dp[j] = min(dp[j - coins[i]] + 1, dp[j])`
	- 322.零钱兑换
	- 279.完全平方数

---

##### 遍历顺序
一维dp数组情况下
1. 01背包：外层遍历物品，内层倒序遍历背包
2. 完全背包：排列要包装
	- 如果求**排列**数就是外层for遍历**背包**，内层for循环遍历物品
		- 由于排列导致外层遍历背包，所以需要条件判断`if (j >= nums[i])` 
	- 如果求**组合**数就是外层for循环遍历物品，内层for遍历背包
		- 在组合中，无需这个判断，因为内层遍历背包直接从`nums[i]`开始即可
	- 如果求最小数，都可以




### [《代码随想录》动态规划：打家劫舍](https://notes.kamacoder.com/questions/502084)
#### 代码随想录算法训练营Day44 | 198.213.337.

```java
// 代码随想录
/* 动规五部曲
    1、dp数组及下标的含义：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]
    2、递推公式：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
    3、dp数组初始化：
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1]);
    4、遍历顺序：从前到后
    5、举例推导dp数组
*/
// 时间 On
// 空间 On
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0; // nums == null要在n = nums.length之前
        int n = nums.length;
        if (n == 1)
            return nums[0];

        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
}
```
### [《代码随想录》动态规划：打家劫舍II](https://notes.kamacoder.com/questions/502085)
#### 代码随想录算法训练营Day44 | 198.213.337.

```java
// 代码随想录
/* 
    成环的话主要有如下三种情况：
        情况一：考虑不包含首尾元素（可略）
        情况二：考虑包含首元素，不包含尾元素
        情况三：考虑包含尾元素，不包含首元素
    动规五部曲
        1、dp数组及下标的含义：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]
        2、递推公式：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        3、dp数组初始化：
            dp[0] = nums[0]
            dp[1] = max(nums[0], nums[1]);
        4、遍历顺序：从前到后
        5、举例推导dp数组
*/
// 时间 On
// 空间 On
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        int n = nums.length;
        if (n == 1)
            return nums[0];
        if (n==2)
            return Math.max(nums[0], nums[1]);
        return Math.max(robAction(nums, 0, n - 2), robAction(nums, 1, n - 1));
    }

    public int robAction(int[] nums, int start, int end) {
        int[] dp = new int[end + 1];
        dp[start] = nums[start];
        dp[start + 1] = Math.max(nums[start], nums[start + 1]);

        for (int i = start + 2; i <= end; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[end];
    }
}
```
### [《代码随想录》动态规划：打家劫舍III](https://notes.kamacoder.com/questions/502086)
#### 代码随想录算法训练营Day44 | 198.213.337.

```java
// 代码随想录
/* 树形dp的入门题目，递归三部曲+动规五部曲：
    1、确定递归函数的参数和返回值：
        返回数组就是dp数组
        下标为0记录不偷该节点所得到的的最大金钱
        下标为1记录偷该节点所得到的的最大金钱
    2、确定终止条件：
        如果遇到空节点，无论偷还是不偷都是0，相当于dp数组的初始化
    3、确定遍历顺序：后序遍历
        因为通过递归函数的返回值来做下一步计算:
        如果抢了当前节点，两个孩子就不能动
        如果没抢当前节点，就可以考虑抢左右孩子
    4、确定单层递归的逻辑：
        如果是偷当前节点，那么左右孩子就不能偷，val1 = cur->val + left[0] + right[0];
        如果不偷当前节点，那么左右孩子就可以偷，val2 = max(left[0], left[1]) + max(right[0], right[1]);
    5、举例推导dp数组
*/
// 时间 On
// 空间 Ologn
class Solution {
    public int rob(TreeNode root) {
        int[] res = robAction(root);
        return Math.max(res[0], res[1]);
    }   
    public int[] robAction(TreeNode root) {
        int[] res = new int[2];
        
        // 终止条件
        if (root == null)
            return res;

        int[] left = robAction(root.left);  // 左
        int[] right = robAction(root.right);    // 右

        // 中
        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); // 不偷当前节点 -> 左右孩子就可以偷 -> max
        res[1] = root.val + left[0] + right[0]; // 偷当前节点 -> 左右孩子就不能偷 -> left[0]、right[0]

        return res;
    }
}
```
### [《代码随想录》动态规划：买卖股票的最佳时机](https://notes.kamacoder.com/questions/502087)
#### 代码随想录算法训练营Day45 | 121.122.123.

```java
// 代码随想录
/* 动规五部曲
    1、dp数组及下标的含义：
        dp[i][0] 表示第i天不持有股票所得最多现金
        dp[i][1] 表示第i天持有股票所得最多现金（未必当天买入）
    2、递推公式：
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = max(dp[i - 1][1], -prices[i]);   // 重点注意
    3、dp数组初始化：
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
    4、遍历顺序：从前到后
    5、举例推导dp数组
*/
// 时间 On
// 空间 O1
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0)
            return 0;
        int n = prices.length;
        
        int[] dp = new int[2];
        
        dp[0] = 0;
        dp[1] = -prices[0];

        for (int i = 0; i < n; i++) {
            dp[0] = Math.max(dp[0], dp[1] + prices[i]); // 前一天不持有或当天卖出
            dp[1] = Math.max(dp[1], -prices[i]);    // 前一天持有或当天买入
        }

        return dp[0];
    }
}
```
### [《代码随想录》动态规划：买卖股票的最佳时机II（动态规划）](https://notes.kamacoder.com/questions/502088)
#### 代码随想录算法训练营Day45 | 121.122.123.

```java
// 代码随想录
/* 动规五部曲
    1、dp数组及下标的含义：
        dp[i][0] 表示第i天不持有股票所得最多现金
        dp[i][1] 表示第i天持有股票所得最多现金（未必当天买入）
    2、递推公式：
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); 
        // 重点：对比121.这里dp[i - 1][1]可能已经买卖过一支股票了，所以要记录。121.不需要，因为全程只买卖一支
    3、dp数组初始化：
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
    4、遍历顺序：从前到后
    5、举例推导dp数组
*/
// 时间 On
// 空间 On
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];

        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); // 前一天就没持有 or 当天卖出去
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); // 前一天就持有 or 当天买入了
        }

        return dp[n - 1][0];
    }
}
```
### [《代码随想录》动态规划：买卖股票的最佳时机III](https://notes.kamacoder.com/questions/502089)
#### 代码随想录算法训练营Day45 | 121.122.123.

```java
// 代码随想录
/* 动规五部曲
    1、dp数组及下标的含义：
        0 没有操作 （其实我们也可以不设置这个状态）
        1 第一次持有股票（不一定当天买入）
        2 第一次不持有股票
        3 第二次持有股票
        4 第二次不持有股票
        dp[i][j]表示第i天状态j所剩最大现金
    2、递推公式：
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);   // 之前就有 or 当天买入
        dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);   // 之前就没有 or 当天卖出
        dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);   // 之前就有 or 当天买入（注意是在dp[i-1][2]的基础上）
        dp[i][4] = max(dp[i-1][4], dp[i-1][3] - prices[i]);   // 之前就没有 or 当天卖出（注意是在dp[i-1][3]的基础上）
    3、dp数组初始化：
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
    4、遍历顺序：从前到后
    5、举例推导dp数组
*/
// 时间 On
// 空间 On
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0)
            return 0;
        int n = prices.length;

        int[][] dp = new int[n][5];

        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;

        for (int i = 1; i < n; i++) {
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }

        return dp[n - 1][4];
    }
}
```
### [《代码随想录》动态规划：买卖股票的最佳时机IV](https://notes.kamacoder.com/questions/502090)
#### 代码随想录算法训练营Day46 | 188.309.714.

```java
// 代码随想录
/* 动规五部曲
    1、dp数组及下标的含义：
        0 没有操作 （其实我们也可以不设置这个状态）
        1 第一次持有股票（不一定当天买入）
        2 第一次不持有股票
        3 第二次持有股票
        4 第二次不持有股票
        ...
        偶数卖出，奇数买入
        dp[i][j]表示第i天状态j所剩最大现金
    2、递推公式：
    for (int j = 0; j < 2 * k - 1; j += 2)
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);   // 之前就有 or 当天买入
        dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);   // 之前就没有 or 当天卖出
        dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);   // 之前就有 or 当天买入（注意是在dp[i-1][2]的基础上）
        dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]);   // 之前就没有 or 当天卖出（注意是在dp[i-1][3]的基础上）
        ...
        dp[i][2*k-1] = max(dp[i-1][2*k-1], dp[i-1][2*k-2] - prices[i]);
        dp[i][2*k] = max(dp[i-1][2*k], dp[i-1][2*k-1] + prices[i]);
    3、dp数组初始化：
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
        ...
        dp[0][2*k-1] = 0;
        dp[0][2*k] = -prices[0];
        dp[0][j]当j为奇数的时候都初始化为 -prices[0]
    4、遍历顺序：从前到后
    5、举例推导dp数组
*/
// 时间 Onxk
// 空间 Onxk
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices == null || prices.length == 0)
            return 0;
        int n = prices.length;

        int[][] dp = new int[n][2*k+1]; // 注意不是k

        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }

        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= 2*k-2; j+=2) {
                dp[i][j+1] = Math.max(dp[i-1][j+1], dp[i-1][j] - prices[i]);
                dp[i][j+2] = Math.max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]);
            }
        }

        return dp[n - 1][k*2];
    }
}
```
### [《代码随想录》动态规划：最佳买卖股票时机含冷冻期](https://notes.kamacoder.com/questions/502091)
#### 代码随想录算法训练营Day46 | 188.309.714.

```java
// 代码随想录
/* 动规五部曲
    1、dp数组及下标的含义：dp[i][j]表示第i天状态j所剩最大现金
        j的状态：
        0 当天持有股票（不一定当天买入）
        1 保持卖出股票（两天前卖出）
        2 当天卖出股票
        3 当天冷冻期
    2、递推公式：
        // 0 当天持有股票（不一定当天买入）：昨天就持有、昨天冷冻期今天买入、昨天保持卖出今天买入
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);
        // 1 保持卖出股票（两天前卖出）：昨天就保持卖出、昨天是冷冻期
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
        // 2 当天卖出股票：昨天持有今天卖出
        dp[i][2] = dp[i - 1][0] + prices[i];
        // 3 当天冷冻期：昨天当天卖出
        dp[i][3] = dp[i - 1][2];
    3、dp数组初始化：
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        dp[0][3] = 0;
    4、遍历顺序：从前到后
    5、举例推导dp数组
*/
// 时间 On
// 空间 On
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0)
            return 0;
        int n = prices.length;
        int dp[][] = new int[n][4];
        dp[0][0] = -prices[0];

        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]), dp[i - 1][3] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return Math.max(Math.max(dp[n - 1][1], dp[n - 1][2]), dp[n - 1][3]);
    }
}
```
### [《代码随想录》动态规划：买卖股票的最佳时机含手续费（动态规划）](https://notes.kamacoder.com/questions/502092)
#### 代码随想录算法训练营Day46 | 188.309.714.

```java
// 代码随想录
/* 动规五部曲
    1、dp数组及下标的含义：
        dp[i][0] 表示第i天持有股票所得最多现金（偶数）
        dp[i][1] 表示第i天不持有股票所得最多现金（奇数）
    2、递推公式：
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 因为可以多次交易，所以是dp[i - 1][1] - prices[i]而不是- prices[i]
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);   // 卖出时支付手续费
    3、dp数组初始化：
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
    4、遍历顺序：从前到后
    5、举例推导dp数组
*/
// 时间 On
// 空间 On
class Solution {
    public int maxProfit(int[] prices, int fee) {
        if (prices == null || prices.length == 0)
            return 0;
        int n = prices.length;
        int[][] dp = new int[n][2];

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }

        return dp[n - 1][1];
    }
}
```
### [《代码随想录》动态规划：股票问题总结篇](https://notes.kamacoder.com/questions/502093)
#### 代码随想录算法训练营Day46 | 188.309.714.

- 121.买卖股票的最佳时机
	- 一次交易：`dp[i][0] = max(dp[i - 1][0], -prices[i]);`
- 122.买卖股票的最佳时机II
	- 多次交易：`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);`
- 123.买卖股票的最佳时机III
	- 最多2次：奇数持有、偶数不持
- 188.买卖股票的最佳时机IV
	- 最多k次：奇数持有、偶数不持
		- 注意数组大小、for循环的边界
- 309.最佳买卖股票时机含冷冻期
	- 0 当天持有股票（不一定当天买入）
	- 1 保持卖出股票（两天前卖出）
	- 2 当天卖出股票
	- 3 当天冷冻期
- 714.买卖股票的最佳时机含手续费
	- `dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);`

### [《代码随想录》动态规划：最长上升子序列](https://notes.kamacoder.com/questions/502094)
#### 代码随想录算法训练营Day48 | 300.674.718.


```java
// 代码随想录
/* 子序列问题（不连续）
    1、dp数组及下标的含义：dp[i]表示以nums[i]结尾的最长递增子序列的长度
    2、递推公式：
        if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
    3、dp数组初始化：dp[i] = 1;
    4、遍历顺序：从前向后
    5、举例推导dp数组
*/
// 
// 时间 On^2
// 空间 On
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        int n = nums.length;
        if (n == 1)
            return 1;

        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int res = 1;

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            res = Math.max(res, dp[i]); // 注意不是取dp[n-1]，而是maxdp[i]
        }

        return res;
    }
}
```
### [《代码随想录》动态规划：最长连续递增序列](https://notes.kamacoder.com/questions/502095)
#### 代码随想录算法训练营Day48 | 300.674.718.

```java
// 代码随想录
/* 子序列问题（不连续）
    1、dp数组及下标的含义：dp[i]表示以nums[i]结尾的最长连续递增子序列的长度
    2、递推公式：
        if (nums[i] > nums[i-1]) dp[i] = dp[i-1] + 1;
    3、dp数组初始化：dp[i] = 1;
    4、遍历顺序：从前向后
    5、举例推导dp数组
*/
// 时间 On
// 空间 On
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        int n = nums.length;

        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int res = 1;

        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            }
            res = Math.max(res, dp[i]);
        }

        return res;
    }
}
```
### [《代码随想录》动态规划：最长重复子数组](https://notes.kamacoder.com/questions/502096)
#### 代码随想录算法训练营Day48 | 300.674.718.

##### 二维数组

```java
// 代码随想录
/* 子序列问题（不连续）
    1、dp数组及下标的含义：以A[i-1]结尾的字符串，和以B[j-1]结尾的字符串，最长重复子数组长度为dp[i][j]
        定义决定遍历dp[i][j]的时候i和j都要从1开始
        如果不是i-1那么初始化会麻烦一些
    2、递推公式：
        if (A[i-1]== B[j-1]) dp[i][j] = dp[i-1][j-1] + 1
    3、dp数组初始化：
        为了方便递归公式，dp[i][0] 和dp[0][j]初始化为0
    4、遍历顺序：外层for循环遍历A，内层for循环遍历B
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int res = 0;
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        
        for (int i = 1; i < nums1.length + 1; i++) {
            for (int j = 1; j < nums2.length + 1; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                res = Math.max(res, dp[i][j]);
            }
        }
        
        return res;
    }
}
```

---

##### 滚动数组

```java
// 代码随想录
/* 子序列问题（不连续）
    1、dp数组及下标的含义：以A[i-1]结尾的字符串，和以B[j-1]结尾的字符串，最长重复子数组长度为dp[i][j]
        定义决定遍历dp[i][j]的时候i和j都要从1开始
        如果不是i-1那么初始化会麻烦一些
    2、递推公式：
        if (A[i-1]== B[j-1]) dp[i][j] = dp[i-1][j-1] + 1
    3、dp数组初始化：
        为了方便递归公式，dp[i][0] 和dp[0][j]初始化为0
    4、遍历顺序：
        滚动数组：遍历B数组时，从后向前，避免重复覆盖
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Om
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int[] dp = new int[nums2.length + 1];
        int res = 0;

        for (int i = 1; i <= nums1.length; i++) {
            for (int j = nums2.length; j > 0; j--) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[j] = dp[j - 1] + 1;
                } else {
                    dp[j] = 0;
                }
                res = Math.max(res, dp[j]);
            }
        }
        return res;
    }
}
```

---

##### dp定义另一版本

```java
// 代码随想录
/* 子序列问题（不连续）
    1、dp数组及下标的含义：以A[i]结尾的字符串，和以B[j]结尾的字符串，最长重复子数组长度为dp[i][j]
        初始化会麻烦一些
    2、递推公式：
        if (A[i-1]== B[j-1]) dp[i][j] = dp[i-1][j-1] + 1
    3、dp数组初始化：
        为了方便递归公式，dp[i][0] 和dp[0][j]初始化为0
    4、遍历顺序
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int res = 0;
        int[][] dp = new int[nums1.length][nums2.length];
        
        for (int i = 0; i < nums1.length; i++) if (nums1[i] == nums2[0]) dp[i][0] = 1;
        for (int j = 0; j < nums2.length; j++) if (nums1[0] == nums2[j]) dp[0][j] = 1;

        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                if (nums1[i] == nums2[j] && i > 0 && j > 0) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                res = Math.max(res, dp[i][j]);
            }
        }
        
        return res;
    }
}
```
### [《代码随想录》动态规划：最长公共子序列](https://notes.kamacoder.com/questions/502097)
#### 代码随想录算法训练营Day49 | 1143.1035.53.392.

```java
// 代码随想录
/* 动态规划
    1、dp数组及下标的含义：
        长度为[0, i-1]的字符串text1与长度为[0, j-1]的字符串text2的最长公共子序列为dp[i][j]
        规避初始化问题
    2、递推公式：
        如果text1[i-1]与text2[j-1]相同，dp[i][j] = dp[i-1][j-1] + 1;
        如果text1[i-1]与text2[j-1]不同，dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
    3、dp数组初始化：
        dp[i][0] = 0;
        dp[0][j] = 0
    4、遍历顺序：从前向后，从上到下
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) { // 注意是i-1和j-1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[m][n];
    }
}
```
### [《代码随想录》动态规划：不相交的线](https://notes.kamacoder.com/questions/502098)
#### 代码随想录算法训练营Day49 | 1143.1035.53.392.

```java
// 代码随想录
/* 动态规划
    直线不能相交，这就是说明在字符串nums1中 找到一个与字符串nums2相同的子序列
    本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！
    1、dp数组及下标的含义：
        长度为[0, i-1]的字符串text1与长度为[0, j-1]的字符串text2的最长公共子序列为dp[i][j]
        规避初始化问题
    2、递推公式：
        如果text1[i-1]与text2[j-1]相同，dp[i][j] = dp[i-1][j-1] + 1;
        如果text1[i-1]与text2[j-1]不同，dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
    3、dp数组初始化：
        dp[i][0] = 0;
        dp[0][j] = 0
    4、遍历顺序：从前向后，从上到下
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int maxUncrossedLines(int[] text1, int[] text2) {
        int m = text1.length;
        int n = text2.length;
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1[i - 1] == text2[j - 1]) { // 注意是i-1和j-1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[m][n];
    }
}
```
### [《代码随想录》动态规划：最大子序和（动态规划）](https://notes.kamacoder.com/questions/502099)
#### 代码随想录算法训练营Day49 | 1143.1035.53.392.

```java
// Hot100、代码随想录
/* 动态规划
    1、dp数组及下标的含义：以nums[i]为结尾的最大连续子序列和为dp[i]。
    2、递推公式：
        dp[i] = max(dp[i - 1] + nums[i], nums[i]);
    3、dp数组初始化：
        dp[0] = nums[0]
    4、遍历顺序：从前向后
    5、举例推导dp数组
*/
// 时间 On
// 空间 On
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) 
            return 0;
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        int res = nums[0];

        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i-1]+nums[i], nums[i]);
            res = Math.max(res, dp[i]);
        }

        return res;
    }
}
```
### [《代码随想录》动态规划：判断子序列](https://notes.kamacoder.com/questions/502100)
#### 代码随想录算法训练营Day49 | 1143.1035.53.392.

```java
// 代码随想录
/* 动态规划
    1、dp数组及下标的含义：以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]
    2、递推公式：
        if (s[i - 1] == t[j - 1])   dp[i][j] = dp[i - 1][j - 1] + 1;
        if (s[i - 1] != t[j - 1])   dp[i][j] = dp[i][j - 1];
    3、dp数组初始化：dp[0][0]和dp[i][0]初始化为0
    4、遍历顺序：从上到下，从左到右
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public boolean isSubsequence(String s, String t) {
        int m = s.length();
        int n = t.length();
        int[][] dp = new int[m+1][n+1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s.charAt(i-1) == t.charAt(j-1)) 
                    dp[i][j] = dp[i-1][j-1]+1;
                else 
                    dp[i][j] = dp[i][j-1];
            }
        }

        return dp[m][n] == s.length();
    }
}
```
### [《代码随想录》动态规划：不同的子序列](https://notes.kamacoder.com/questions/502101)
#### 代码随想录算法训练营Day50 | 115.583.72.

```java
// 代码随想录
/* 编辑距离
    1、dp数组及下标的含义：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]
    2、递推公式：
        当s[i - 1] 与 t[j - 1]相等时，
            用s[i - 1]来匹配，当前最后一位字母匹配成功，考虑前面的，个数为dp[i - 1][j - 1]
            不用s[i - 1]来匹配，个数为dp[i - 1][j]
        当s[i - 1] 与 t[j - 1]不相等时
            不用s[i - 1]来匹配，dp[i - 1][j]
    3、dp数组初始化：
        由左上、右推导而来
        dp[i][0]=1
        dp[0][j]=0
        dp[0][0]=1
    4、遍历顺序
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int numDistinct(String s, String t) {
        int[][] dp = new int[s.length() + 1][t.length() + 1];
        for (int i = 0; i < s.length() + 1; i++)
            dp[i][0] = 1;

        for (int i = 1; i < s.length() + 1; i++) {
            for (int j = 1; j < t.length() + 1; j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        return dp[s.length()][t.length()];
    }
}
```
### [《代码随想录》动态规划：两个字符串的删除操作](https://notes.kamacoder.com/questions/502102)
#### 代码随想录算法训练营Day50 | 115.583.72.

```java
// 代码随想录
/* 编辑距离
    1、dp数组及下标的含义：以i-1结尾和以j-1结尾相同最小步数dp[i][j]
    2、递推公式：
        word1[i-1]和word1[j-1]相等
            dp[i][j] = dp[i-1][j-1]
        word1[i-1]和word1[j-1]不等
            dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+2)
    3、dp数组初始化：
        dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素才能和word2相同呢？dp[i][0] = i;
        dp[0][j] = j;
    4、遍历顺序
        由左上、（左）、上推导而来
        从上到下，从左到右
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];

        for (int i = 0; i < word1.length() + 1; i++)
            dp[i][0] = i;
        for (int j = 0; j < word2.length() + 1; j++)
            dp[0][j] = j;

        for (int i = 1; i < word1.length() + 1; i++) {
            for (int j = 1; j < word2.length() + 1; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 2,
                            Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }

        return dp[word1.length()][word2.length()];
    }
}
```
### [《代码随想录》动态规划：编辑距离](https://notes.kamacoder.com/questions/502103)
#### 代码随想录算法训练营Day50 | 115.583.72.

```java
// 代码随想录
/* 编辑距离
    1、dp数组及下标的含义：以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]
    2、递推公式：
        if (word1[i - 1] == word2[j - 1])
            不操作：dp[i][j] = dp[i - 1][j - 1];
        if (word1[i - 1] != word2[j - 1])
            word1删除=增：dp[i][j] = dp[i - 1][j] + 1;
            word2删除=删：dp[i][j] = dp[i][j - 1] + 1;
            换：dp[i][j] = dp[i - 1][j - 1] + 1;    // 注意583.只能删除不能替换，这里是+2
    3、dp数组初始化：
        dp[i][0] = i;
        dp[0][j] = j;
    4、遍历顺序
        由左、左上、上推导而来
        从左到右，从上到下
    5、举例推导dp数组
*/
// 时间 Omxn
// 空间 Omxn
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 0; i <= m; i++)
            dp[i][0] = i;
        for (int j = 0; j <= n; j++)
            dp[0][j] = j;

        for (int i = 1; i < m + 1; i++) {
            for (int j = 1; j < n + 1; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j] + 1, Math.min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1));
                }
            }
        }

        return dp[m][n];
    }
}
```
### [《代码随想录》动态规划：编辑距离总结篇](https://notes.kamacoder.com/questions/502104)
#### 代码随想录算法训练营Day50 | 115.583.72.

##### 392.判断子序列
判断 s 是否为 t 的子序列
```java
if (s[i - 1] == t[j - 1]) 
	dp[i][j] = dp[i - 1][j - 1] + 1;
else 
	dp[i][j] = dp[i][j - 1];
```

---

##### 583.不同的子序列
计算在 s 的子序列中 t 出现的个数
```java
if (s[i - 1] == t[j - 1])
    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
else
    dp[i][j] = dp[i - 1][j];
```

---

##### 115.两个字符串的删除操作
每步可以删除任意一个字符串中的一个字符，找到使得 word1 和 word2 相同所需的最少步数
```java
if (word1[i - 1] == word2[j - 1])
    dp[i][j] = dp[i - 1][j - 1];
else
    dp[i][j] = min(dp[i - 1][j - 1] + 2, 
					dp[i - 1][j] + 1, 
					dp[i][j - 1] + 1);
```

---

##### 72.编辑距离
每步可以增删改任意一个字符串中的一个字符，找到使得 word1 和 word2 相同所需的最少步数
```java
if (word1[i - 1] == word2[j - 1])
    dp[i][j] = dp[i - 1][j - 1];
else
    dp[i][j] = min(dp[i - 1][j - 1] + 1, 
				dp[i - 1][j] + 1, 
				dp[i][j - 1] + 1);
```







### [《代码随想录》动态规划：回文子串](https://notes.kamacoder.com/questions/502105)
#### 代码随想录算法训练营Day51 | 647.516.

```java
// 代码随想录
/* 回文
    1、dp数组及下标的含义：dp[i][j]为true表示区间范围[i,j]是回文子串
    2、递推公式：
        当s[i]与s[j]不相等，dp[i][j]一定是false。
        当s[i]与s[j]相等时
            下标i与j相同，a，回文
            下标i与j相差为1，aa，回文
            下标i与j相差大于1，看dp[i + 1][j - 1]是否为true
    3、dp数组初始化：
        dp[i][j]初始化为false
    4、遍历顺序
        由左下角推导而来
        从下到上，从左到右
        for (int i = n - 1; i >= 0; i--) {
        for (int j = i; j < n; j++) {
    5、举例推导dp数组
*/
// 时间 On^2
// 空间 O1
class Solution {
    public int countSubstrings(String s) {
        char[] chars = s.toCharArray();
        int n = chars.length;
        boolean[][] dp = new boolean[n][n];
        int result = 0;

        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (chars[i] == chars[j]) {
                    if (j - i <= 1) { // 情况一 和 情况二
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { //情况三
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }

        return result;
    }
}
```
### [《代码随想录》动态规划：最长回文子序列](https://notes.kamacoder.com/questions/502106)
#### 代码随想录算法训练营Day51 | 647.516.

```java
// 代码随想录
/* 回文
    1、dp数组及下标的含义：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]
    2、递推公式：
        如果s[i]与s[j]相同，dp[i][j] = dp[i + 1][j - 1] + 2;
        如果s[i]与s[j]不相同，dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            不加i加j 的回文子序列长度为dp[i + 1][j]
            加i不加j 的回文子序列长度为dp[i][j - 1]
    3、dp数组初始化：
        当i与j相同，那么dp[i][j]等于1
    4、遍历顺序
        由左、左下、下推导而来
        从下到上，从左向右（右上三角形）
    5、举例推导dp数组
*/
// 时间 On^2
// 空间 On^2
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];

        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1; // 初始化
            for (int j = i + 1; j < n; j++) {   // j=i+1而不是i，因为i=j的情况已经初始化，如果在这里处理会使得最下面一行判断dp[i + 1][j - 1]时越界
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
}
```
### [《代码随想录》动态规划：动态规划总结篇](https://notes.kamacoder.com/questions/502107)
#### 代码随想录算法训练营Day51 | 647.516.

##### 动规五部曲
1. dp数组下标含义
2. 递推公式
3. 初始化
4. 遍历顺序
5. 举例推导

---

##### 背包问题
- 01背包
- 完全背包
- 多重背包


---

##### 打家劫舍

---

##### 买卖股票

---

##### 子序列问题
- 子序列（不连续）
- 子序列（连续）
- 编辑距离
- 回文

## 单调栈
### [《代码随想录》单调栈：每日温度](https://notes.kamacoder.com/questions/502108)
#### 代码随想录算法训练营Day52 | 739.496.503

```java
// 代码随想录
/* 单调栈
    用于寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置
    本质是空间换时间
    单调栈里只需要存放元素的下标i就可以了
    从栈顶到栈底递增：
        栈里要加入元素i，栈顶元素x通过比较知道右边第一个比自己大的元素是i
        通俗解释，新元素i作为踢馆者，被踢馆的x知道这是有史以来第一个硬骨头认可i，直到遇到i踢不动的y，i才停下坐上交椅
    如果求一个元素右边第一个更大元素，单调栈就是递增的；
    如果求一个元素右边第一个更小元素，单调栈就是递减的。
*/
// 时间 On
// 空间 On
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] res = new int[temperatures.length];
        Stack<Integer> st = new Stack<>();

        for (int i = 0; i < temperatures.length; i++) {
            while (!st.isEmpty() && temperatures[i] > temperatures[st.peek()]) { // // temperatures[i]作为踢馆者肯定要while不停挑战
                int idx = st.pop(); // pop，下一位
                res[idx] = i - idx; // 被踢馆的temperatures[st.peek()]知道这是有史以来第一个硬骨头认可i
            }
            st.push(i); //直到遇到i踢不动的y，i才停下坐上交椅
        }

        return res;
    }
}
```
### [《代码随想录》单调栈：下一个更大元素I](https://notes.kamacoder.com/questions/502109)
#### 代码随想录算法训练营Day52 | 739.496.503

```java
// 代码随想录
// 单调栈
// 时间 On
// 空间 On
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] res = new int[nums1.length];
        Arrays.fill(res, -1);
        Deque<Integer> st = new LinkedList<>();
        HashMap<Integer, Integer> mp = new HashMap<>(); // 关键
        for (int i = 0; i < nums1.length; i++) {
            mp.put(nums1[i], i);
        }

        for (int i = 0; i < nums2.length; i++) {
            while (!st.isEmpty() && nums2[i] > nums2[st.peek()]) {  // 注意st.peek()是下标，所以nums2[st.peek()
                int idx = st.pop();
                if (mp.containsKey(nums2[idx]))
                    res[mp.get(nums2[idx])] = nums2[i]; // res存的是值
            }
            st.push(i);
        }

        return res;
    }
}
```
### [《代码随想录》单调栈：下一个更大元素II](https://notes.kamacoder.com/questions/502110)
#### 代码随想录算法训练营Day52 | 739.496.503

```java
// 代码随想录
// 单调栈
// 扩充nums数组相当于多了一个O(n)的操作，不如通过取余模拟遍历两遍
// 时间 On
// 空间 On
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        if (nums == null || nums.length <= 1)
            return new int[] { -1 };

        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        Stack<Integer> st = new Stack<>();  // st存放下标

        for (int i = 0; i < 2 * n; i++) {
            while (!st.empty() && nums[i % n] > nums[st.peek()]) {
                result[st.peek()] = nums[i % n];    // res存放的是值
                st.pop();
            }
            st.push(i % n);
        }

        return result;
    }
}
```
### [《代码随想录》单调栈：接雨水](https://notes.kamacoder.com/questions/502111)
#### 代码随想录算法训练营Day53 | 42.84.

```java
// Hot100、代码随想录
// 双指针：当前列雨水面积：min(左边柱子的最高高度，右边柱子的最高高度) - 当前柱子高度
// 时间 On
// 空间 O1
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int left = 0, right = n - 1;
        int res = 0;
        int lMax = height[left], rMax = height[right];

        while (left < right) {
            lMax = Math.max(lMax, height[left]);
            rMax = Math.max(rMax, height[right]);
            if (lMax < rMax) {
                res += lMax - height[left];
                left++;
            } else {
                res += rMax - height[right];
                right--;
            }
        }

        return res;
    }
}
```

---

```java
// Hot100、代码随想录
/* 单调栈
    接雨水正需要寻找右边最大元素以及左边最大元素
    单调栈是按照行方向来计算雨水
    从栈顶到栈底的顺序应该是从小到大的顺序，因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。
    遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。因为我们要求宽度的时候 如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度。
*/
// 时间 On
// 空间 On
class Solution {
    public int trap(int[] height) {
        if (height == null || height.length == 0)
            return 0;
        int n = height.length;
        if (n <= 2)
            return 0;

        Stack<Integer> st = new Stack<Integer>();
        st.push(0); // 初始化
        int res = 0;
        for (int i = 1; i < n; i++) {
            if (height[st.peek()] > height[i]) { // 左高右低，入栈
                st.push(i);
            } else if (height[st.peek()] == height[i]) { // 一样高，更新下标（方便计算宽度）
                st.pop();
                st.push(i);
            } else { // 左低右高
                while (!st.isEmpty() && height[i] > height[st.peek()]) { // 仍然满足左低右高
                    int mid = st.pop();
                    if (!st.isEmpty()) {
                        // 栈头元素mid就是凹槽底部的柱子
                        // 栈头第二个元素st.peek()就是凹槽左边的柱子
                        // 添加的元素i就是凹槽右边的柱子
                        int h = Math.min(height[st.peek()], height[i]) - height[mid];
                        int w = i - st.peek() - 1;
                        res += h * w;
                    }
                }
            }
            st.push(i);
        }

        return res;
    }
}
```
### [《代码随想录》单调栈：柱状图中最大的矩形](https://notes.kamacoder.com/questions/502112)
#### 代码随想录算法训练营Day53 | 42.84.

```java
// 代码随想路
// 单调栈
// 时间 On
// 空间 On
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        if (n == 0) return 0;
        if (n == 1) return heights[0];

        // 哨兵
        int[] newHeights = new int[n+2];
        System.arraycopy(heights, 0, newHeights, 1, n);
        n += 2;
        heights = newHeights;
        Stack<Integer> st = new Stack<>();
        st.push(0);
        int res = 0;

        // 核心
        for (int i = 1; i < n; i++) {
            // 注意heights[i] 是和heights[st.peek()] 比较 ，st.peek()是下标
            if (heights[i] > heights[st.peek()]) {
                st.push(i);
            } else if (heights[i] == heights[st.peek()]) {
                st.pop(); // 这个可以加，可以不加，效果一样，思路不同
                st.push(i);
            } else {
                while (heights[i] < heights[st.peek()]) { // 注意是while
                    int mid = st.peek();
                    st.pop();
                    int left = st.peek();
                    int right = i;
                    int w = right - left - 1;
                    int h = heights[mid];
                    res = Math.max(res, w * h);
                }
                st.push(i);
            }
        }

        return res;
    }
}
```
## 图论
### [《代码随想录》图论：图论理论基础](https://notes.kamacoder.com/questions/502113)
#### 代码随想录算法训练营Day55 | @98.


- ACM模式
- 连通性
	- 连通图
	- 强连通图
	- 连通分量
	- 强连通分量
- 图的构造
	- 邻接矩阵（适合稠密图）
	- 邻接表（适合稀疏图）
		- 检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。
- 图的遍历方式
### [《代码随想录》图论：深度优先搜索理论基础](https://notes.kamacoder.com/questions/502114)
#### 代码随想录算法训练营Day55 | @98.

```java
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```
### [《代码随想录》图论：所有可达路径](https://notes.kamacoder.com/questions/502115)
#### 代码随想录算法训练营Day55 | @98.

邻接矩阵
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    static List<List<Integer>> result = new ArrayList<>(); // 收集符合条件的路径
    static List<Integer> path = new ArrayList<>(); // 1节点到终点的路径

    public static void dfs(int[][] graph, int x, int n) {
        // 当前遍历的节点x 到达节点n
        if (x == n) { // 找到符合条件的一条路径
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 1; i <= n; i++) { // 遍历节点x链接的所有节点
            if (graph[x][i] == 1) { // 找到 x链接的节点
                path.add(i); // 遍历到的节点加入到路径中来
                dfs(graph, i, n); // 进入下一层递归
                path.remove(path.size() - 1); // 回溯，撤销本节点
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();

        // 节点编号从1到n，所以申请 n+1 这么大的数组
        int[][] graph = new int[n + 1][n + 1];

        for (int i = 0; i < m; i++) {
            int s = scanner.nextInt();
            int t = scanner.nextInt();
            // 使用邻接矩阵表示无向图，1 表示 s 与 t 是相连的
            graph[s][t] = 1;
        }

        path.add(1); // 无论什么路径已经是从1节点出发
        dfs(graph, 1, n); // 开始遍历

        // 输出结果
        if (result.isEmpty()) System.out.println(-1);
        for (List<Integer> pa : result) {
            for (int i = 0; i < pa.size() - 1; i++) {
                System.out.print(pa.get(i) + " ");
            }
            System.out.println(pa.get(pa.size() - 1));
        }
    }
}
```

---

邻接表
```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class Main {
    static List<List<Integer>> result = new ArrayList<>(); // 收集符合条件的路径
    static List<Integer> path = new ArrayList<>(); // 1节点到终点的路径

    public static void dfs(List<LinkedList<Integer>> graph, int x, int n) {
        if (x == n) { // 找到符合条件的一条路径
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i : graph.get(x)) { // 找到 x指向的节点
            path.add(i); // 遍历到的节点加入到路径中来
            dfs(graph, i, n); // 进入下一层递归
            path.remove(path.size() - 1); // 回溯，撤销本节点
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();

        // 节点编号从1到n，所以申请 n+1 这么大的数组
        List<LinkedList<Integer>> graph = new ArrayList<>(n + 1);
        for (int i = 0; i <= n; i++) {
            graph.add(new LinkedList<>());
        }

        while (m-- > 0) {
            int s = scanner.nextInt();
            int t = scanner.nextInt();
            // 使用邻接表表示 s -> t 是相连的
            graph.get(s).add(t);
        }

        path.add(1); // 无论什么路径已经是从1节点出发
        dfs(graph, 1, n); // 开始遍历

        // 输出结果
        if (result.isEmpty()) System.out.println(-1);
        for (List<Integer> pa : result) {
            for (int i = 0; i < pa.size() - 1; i++) {
                System.out.print(pa.get(i) + " ");
            }
            System.out.println(pa.get(pa.size() - 1));
        }
    }
}
```
### [《代码随想录》图论：广度优先搜索理论基础](https://notes.kamacoder.com/questions/502116)
#### 代码随想录算法训练营Day55 | @98.

仅仅需要一个容器，能保存我们要遍历过的元素就可以，**那么用队列，还是用栈，甚至用数组，都是可以的**。
- **用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针**。因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。
- **如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历**。因为栈是先进后出，加入元素和弹出元素的顺序改变了。
那么广搜需要注意 转圈搜索的顺序吗？ **不需要！**

```java
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
```
### [《代码随想录》图论：岛屿数量.深搜版](https://notes.kamacoder.com/questions/502117)
#### 代码随想录算法训练营Day56 | @99bfs.@99dfs.@100

**版本一的写法**是 ：下一个节点是否能合法已经判断完了，传进dfs函数的就是合法节点。

**版本二的写法**是：不管节点是否合法，上来就dfs，然后在终止条件的地方进行判断，不合法再return。

```java
import java.util.Scanner;

public class Main {
    public static int[][] dir = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };

    public static void dfs(boolean[][] visited, int x, int y, int[][] grid) {
        for (int i = 0; i < 4; i++) {
            int nextX = x + dir[i][0];
            int nextY = y + dir[i][1];
            if (nextY < 0 || nextX < 0 || nextX >= grid.length || nextY >= grid[0].length)
                continue;
            if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {
                visited[nextX][nextY] = true;
                dfs(visited, nextX, nextY, grid);
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        int[][] grid = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = sc.nextInt();
            }
        }
        boolean[][] visited = new boolean[m][n];
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!visited[i][j] && grid[i][j] == 1) {
                    ans++;
                    visited[i][j] = true;
                    dfs(visited, i, j, grid);
                }
            }
        }
        System.out.println(ans);
    }
}
```
### [《代码随想录》图论：岛屿数量.广搜版](https://notes.kamacoder.com/questions/502118)
#### 代码随想录算法训练营Day56 | @99bfs.@99dfs.@100

```java
import java.util.*;

public class Main {
    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//下右上左逆时针遍历

    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {
        Queue<pair> queue = new LinkedList<pair>();//定义坐标队列，没有现成的pair类，在下面自定义了
        queue.add(new pair(x, y));
        visited[x][y] = true;//遇到入队直接标记为优先，
        // 否则出队时才标记的话会导致重复访问，比如下方节点会在右下顺序的时候被第二次访问入队
        while (!queue.isEmpty()) {
            int curX = queue.peek().first;
            int curY = queue.poll().second;//当前横纵坐标
            for (int i = 0; i < 4; i++) {
                //顺时针遍历新节点next，下面记录坐标
                int nextX = curX + dir[i][0];
                int nextY = curY + dir[i][1];
                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {
                    continue;
                }//去除越界部分
                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {
                    queue.add(new pair(nextX, nextY));
                    visited[nextX][nextY] = true;//逻辑同上
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        int[][] grid = new int[m][n];
        boolean[][] visited = new boolean[m][n];
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = sc.nextInt();
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!visited[i][j] && grid[i][j] == 1) {
                    ans++;
                    bfs(grid, visited, i, j);
                }
            }
        }
        System.out.println(ans);
    }
}
```
### [《代码随想录》图论：岛屿的最大面积](https://notes.kamacoder.com/questions/502119)
#### 代码随想录算法训练营Day56 | @99bfs.@99dfs.@100

DFS版

```java
import java.util.*;
import java.math.*;

public class Main{

    static final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};
    static int result=0;
    static int count=0;

    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[][] map = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                map[i][j]=scanner.nextInt();
            }
        }
        boolean[][] visited = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(!visited[i][j]&&map[i][j]==1){
                    count=0;
                    dfs(map,visited,i,j);
                    result= Math.max(count, result);
                }
            }
        }
        System.out.println(result);
    }

    static void dfs(int[][] map,boolean[][] visited,int x,int y){
                count++;
                visited[x][y]=true;
                for (int i = 0; i < 4; i++) {
                    int nextX=x+dir[i][0];
                    int nextY=y+dir[i][1];
                    //水或者已经访问过的跳过
                    if(nextX<0||nextY<0
                    ||nextX>=map.length||nextY>=map[0].length
                    ||visited[nextX][nextY]||map[nextX][nextY]==0)continue;
                    
                    dfs(map,visited,nextX,nextY);
                }
            }
}
```

---

BFS版

```java
import java.util.*;
import java.math.*;

public class Main {
    static class Node {
        int x;
        int y;

        public Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    static int result = 0;
    static int count = 0;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[][] map = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                map[i][j] = scanner.nextInt();
            }
        }
        boolean[][] visited = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && map[i][j] == 1) {
                    count = 0;
                    bfs(map, visited, i, j);
                    result = Math.max(count, result);

                }
            }
        }
        System.out.println(result);
    }

    static void bfs(int[][] map, boolean[][] visited, int x, int y) {
        Queue<Node> q = new LinkedList<>();
        q.add(new Node(x, y));
        visited[x][y] = true;
        count++;
        while (!q.isEmpty()) {
            Node node = q.remove();
            for (int i = 0; i < 4; i++) {
                int nextX = node.x + dir[i][0];
                int nextY = node.y + dir[i][1];
                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)
                    continue;
                q.add(new Node(nextX, nextY));
                visited[nextX][nextY] = true;
                count++;
            }
        }
    }
}
```
